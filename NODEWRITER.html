<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Writer Studio (Offline)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Quill.js Rich Text Editor -->
    <link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
    <!-- PDF Generation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            /* Improved Dark Theme - Better Contrast & Readability */
            --bg-primary: #1a1b26;
            --bg-secondary: #1f2133;
            --bg-tertiary: #252836;
            --bg-elevated: #2d3041;
            --bg-hover: #363a4f;
            --border-subtle: rgba(255,255,255,0.08);
            --border-default: rgba(255,255,255,0.15);
            --text-primary: #e8e9ed;
            --text-secondary: #b4b8c8;
            --text-tertiary: #8b90a5;
            --accent-primary: #7c8aff;
            --accent-secondary: #6c7bff;
            --accent-gradient: linear-gradient(135deg, #6c7bff 0%, #9b7bff 100%);
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #f87171;
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;
            --radius-xl: 20px;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.25);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.35);
            --shadow-lg: 0 12px 40px rgba(0,0,0,0.45);
            --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Light Mode Variables - Clean & Professional */
        body.light-mode {
            --bg-primary: #ffffff;
            --bg-secondary: #fafbfc;
            --bg-tertiary: #f4f5f7;
            --bg-elevated: #ffffff;
            --bg-hover: #f0f1f3;
            --border-subtle: #e1e4e8;
            --border-default: #d0d7de;
            --text-primary: #1f2328;
            --text-secondary: #57606a;
            --text-tertiary: #6e7781;
            --accent-primary: #0969da;
            --accent-secondary: #0550ae;
            --accent-gradient: linear-gradient(135deg, #0969da 0%, #0550ae 100%);
            --success: #1a7f37;
            --warning: #9a6700;
            --danger: #cf222e;
            --shadow-sm: 0 1px 2px rgba(31, 35, 40, 0.04);
            --shadow-md: 0 3px 6px rgba(31, 35, 40, 0.08);
            --shadow-lg: 0 8px 24px rgba(31, 35, 40, 0.12);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            min-width: 1200px;
            color: var(--text-primary);
            overflow-x: auto;
            overflow-y: hidden;
            font-size: 14px;
            -webkit-font-smoothing: antialiased;
            line-height: 1.5;
        }

        html {
            min-width: 1200px;
            overflow-x: auto;
        }

        /* Modern Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Header - Clean Modern Style */
        .header {
            background: var(--bg-secondary);
            padding: 0 20px;
            height: 48px;
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            position: relative;
            z-index: 1000;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            letter-spacing: -0.3px;
        }

        .logo-icon {
            width: 26px;
            height: 26px;
            background: var(--accent-gradient);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            color: white;
        }

        .toolbar {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border-subtle);
            margin: 0 8px;
        }

        .toolbar button {
            padding: 6px 10px;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all var(--transition-fast);
            background: transparent;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar button:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .toolbar button.primary {
            background: var(--accent-gradient);
            color: white;
        }

        .toolbar button.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /* Modern Minimal Button Style - Works in both themes */
        .toolbar button {
            background: transparent !important;
            color: var(--text-secondary) !important;
            border: 1px solid transparent !important;
            font-weight: 500;
            font-size: 13px;
            padding: 7px 12px;
        }

        .toolbar button:hover {
            background: var(--bg-hover) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-subtle) !important;
        }

        /* Primary action buttons */
        .btn-primary {
            background: var(--accent-gradient) !important;
            color: white !important;
            border: none !important;
        }

        .btn-primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /* Light mode specific button overrides */
        body.light-mode .toolbar button {
            color: #57606a !important;
        }

        body.light-mode .toolbar button:hover {
            background: #f0f1f3 !important;
            color: #1f2328 !important;
            border-color: #d0d7de !important;
        }

        /* Accent buttons for key actions */
        .btn-accent {
            background: var(--accent-primary) !important;
            color: white !important;
        }

        body.light-mode .btn-accent {
            background: #0969da !important;
            color: white !important;
        }

        /* Danger button */
        .btn-danger {
            color: var(--danger) !important;
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.1) !important;
            color: var(--danger) !important;
        }

        body.light-mode .btn-danger {
            color: #cf222e !important;
        }

        body.light-mode .btn-danger:hover {
            background: rgba(207, 34, 46, 0.1) !important;
        }

        /* Stats Bar - Modern */
        .stats-bar {
            background: var(--bg-secondary);
            padding: 0 16px;
            height: 36px;
            display: flex;
            align-items: center;
            gap: 24px;
            font-size: 12px;
            color: var(--text-tertiary);
            border-bottom: 1px solid var(--border-subtle);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-item .stat-value {
            color: var(--accent-primary);
            font-weight: 600;
            font-size: 13px;
        }

        /* Main Layout */
        .main-layout {
            display: flex;
            height: calc(100vh - 88px);
        }

        /* Side Panel - Modern */
        .side-panel {
            width: 350px;
            min-width: 300px;
            max-width: 550px;
            background: var(--bg-secondary);
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
        }

        .panel-resize-handle {
            position: absolute;
            right: -3px;
            top: 0;
            width: 6px;
            height: 100%;
            background: transparent;
            cursor: ew-resize;
            z-index: 100;
        }

        .panel-resize-handle:hover,
        .panel-resize-handle.dragging {
            background: #e94560;
        }

        /* Global Search */
        /* Modern Search Modal - Raycast/Linear Style */
        .global-search-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(8px);
            z-index: 3000;
            justify-content: center;
            align-items: flex-start;
            padding-top: 12vh;
        }

        .global-search-modal.active {
            display: flex;
            animation: fadeIn 0.15s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-20px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .global-search-box {
            width: 680px;
            max-width: 90%;
            background: var(--bg-secondary);
            border-radius: 16px;
            box-shadow: 0 25px 80px rgba(0,0,0,0.5), 0 0 0 1px var(--border-default);
            overflow: hidden;
            animation: slideDown 0.2s ease;
        }

        .global-search-input-wrap {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-subtle);
            gap: 12px;
        }

        .global-search-input-wrap .search-icon {
            font-size: 20px;
            opacity: 0.5;
        }

        .global-search-input-wrap input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 16px;
            font-weight: 400;
            padding: 4px 0;
            outline: none;
        }

        .global-search-input-wrap input::placeholder {
            color: var(--text-tertiary);
        }

        .search-close-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: var(--bg-hover);
            border: 1px solid var(--border-subtle);
            color: var(--text-tertiary);
            font-size: 11px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .search-close-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        /* Search Mode Toggle - Pills Style */
        .global-search-mode {
            display: flex;
            gap: 6px;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
        }

        .search-mode-btn {
            padding: 6px 14px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-tertiary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .search-mode-btn:hover {
            background: var(--bg-hover);
            color: var(--text-secondary);
        }

        .search-mode-btn.active {
            background: var(--accent-primary);
            color: white;
        }

        /* Search Filters - Chip Style */
        .global-search-filters {
            display: flex;
            gap: 6px;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
            flex-wrap: wrap;
        }

        .search-filter-btn {
            padding: 5px 12px;
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .search-filter-btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-default);
        }

        .search-filter-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* Search Results */
        .global-search-results {
            max-height: 420px;
            overflow-y: auto;
            padding: 8px;
        }

        .search-results-header {
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-result-item {
            padding: 12px 16px;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 4px;
            background: transparent;
            border: 1px solid transparent;
            transition: all 0.15s;
        }

        .search-result-item:hover {
            background: var(--bg-hover);
            border-color: var(--border-subtle);
        }

        .search-result-item.selected {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .search-result-item.selected .search-result-title,
        .search-result-item.selected .search-result-context,
        .search-result-item.selected .search-result-meta {
            color: white;
        }

        .search-result-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .search-result-title .result-icon {
            font-size: 14px;
            opacity: 0.7;
        }

        .search-result-context {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .search-result-context mark {
            background: rgba(124, 138, 255, 0.3);
            color: var(--accent-primary);
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: 500;
        }

        .search-result-meta {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-top: 6px;
            display: flex;
            gap: 12px;
        }

        .search-result-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .search-empty-state {
            text-align: center;
            padding: 48px 20px;
            color: var(--text-tertiary);
        }

        .search-empty-state .empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .search-empty-state p {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .search-empty-state .hint {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .search-shortcut-hint {
            display: flex;
            justify-content: center;
            gap: 16px;
            padding: 12px;
            border-top: 1px solid var(--border-subtle);
            background: var(--bg-tertiary);
        }

        .search-shortcut-hint span {
            font-size: 11px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .search-shortcut-hint kbd {
            background: var(--bg-hover);
            border: 1px solid var(--border-subtle);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            font-family: inherit;
        }

        /* Comments */
        .comment-highlight {
            background: rgba(255, 193, 7, 0.3);
            border-bottom: 2px dashed #ffc107;
            cursor: pointer;
            position: relative;
        }

        .comment-tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8em;
            max-width: 250px;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .comment-tooltip::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 15px;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid #333;
        }

        .panel-tabs {
            display: flex;
            background: #0f0f1a;
            padding: 8px;
            gap: 4px;
        }

        .panel-tab {
            flex: 1;
            padding: 10px 8px;
            text-align: center;
            font-size: 0.75em;
            color: #6b7280;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .panel-tab:hover {
            color: #9ca3af;
            background: rgba(255,255,255,0.03);
        }

        .panel-tab.active {
            color: #fff;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .panel-content {
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            position: absolute;
            top: 55px; /* Below tabs */
            left: 0;
            right: 0;
            bottom: 0;
            display: none !important;
        }

        /* Active panel states - controlled by switchTab JS */
        .panel-content.active-panel {
            display: flex !important;
            flex-direction: column;
        }

        /* Projects Side Panel - Modern Design */
        #projectsPanel {
            padding: 0 !important;
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
        }

        #projectsPanel.active-panel {
            display: flex !important;
            flex-direction: column;
            overflow-y: auto;
        }

        .projects-side-header {
            padding: 20px 16px;
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.05) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }

        .projects-side-user {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-size: 0.95em;
            color: #fff;
            font-weight: 600;
            display: block;
        }

        .user-status {
            font-size: 0.75em;
            color: #6b7280;
            margin-top: 2px;
        }

        .projects-side-login {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .projects-side-login:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
        }

        .projects-side-toolbar {
            padding: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }

        .projects-side-btn {
            width: 100%;
            padding: 14px 16px;
            border: 2px dashed rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            background: transparent;
            color: #6366f1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .projects-side-btn.new:hover {
            background: rgba(99, 102, 241, 0.1);
            border-color: #6366f1;
            transform: scale(1.02);
        }

        .projects-side-list {
            flex: 1 1 auto;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px 16px;
            display: block;
            min-height: 200px;
        }

        .projects-side-list .proj-item {
            margin-bottom: 12px;
        }

        .projects-side-empty {
            text-align: center;
            padding: 40px 20px;
            color: #4b5563;
        }

        .projects-side-empty .empty-icon {
            font-size: 56px;
            margin-bottom: 16px;
            opacity: 0.4;
        }

        .projects-side-empty p {
            font-size: 0.9em;
            line-height: 1.5;
        }

        /* ============ PROJECT ITEM - PROFESSIONAL DESIGN ============ */
        .proj-item {
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, rgba(30, 30, 45, 0.8) 100%);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .proj-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #e94560 0%, #ff6b8a 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .proj-item:hover {
            background: linear-gradient(135deg, var(--bg-hover) 0%, rgba(40, 40, 60, 0.9) 100%);
            border-color: rgba(233, 69, 96, 0.4);
            transform: translateX(4px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .proj-item:hover::before {
            opacity: 1;
        }

        .proj-item.active {
            background: linear-gradient(135deg, rgba(233, 69, 96, 0.15) 0%, rgba(233, 69, 96, 0.05) 100%);
            border-color: #e94560;
            box-shadow: 0 0 0 2px rgba(233, 69, 96, 0.2), 0 8px 24px rgba(233, 69, 96, 0.15);
        }

        .proj-item.active::before {
            opacity: 1;
        }

        .proj-row {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 14px;
        }

        .proj-icon {
            font-size: 32px;
            line-height: 1;
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, rgba(233, 69, 96, 0.15) 0%, rgba(255, 107, 138, 0.1) 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .proj-main {
            flex: 1;
            min-width: 0;
        }

        .proj-name {
            font-size: 17px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .proj-updated {
            font-size: 12px;
            color: var(--text-tertiary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .proj-updated::before {
            content: 'üïê';
            font-size: 10px;
        }

        .proj-menu-btn {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .proj-menu-btn:hover {
            background: linear-gradient(135deg, #e94560 0%, #ff6b8a 100%);
            border-color: transparent;
            color: white;
            transform: scale(1.05);
        }

        .proj-info {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            padding: 14px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
            margin-bottom: 14px;
        }

        .proj-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
        }

        .proj-num {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, #e94560 0%, #ff6b8a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .proj-label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }

        .proj-progress {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 14px;
        }

        .proj-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            overflow: hidden;
        }

        .proj-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560 0%, #ff6b8a 50%, #ff8fa3 100%);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .proj-pct {
            font-size: 13px;
            font-weight: 700;
            color: #e94560;
            min-width: 40px;
            text-align: right;
        }

        .proj-actions {
            display: flex;
            gap: 10px;
        }

        .proj-actions button {
            flex: 1;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .proj-actions button:hover {
            background: linear-gradient(135deg, #e94560 0%, #ff6b8a 100%);
            border-color: transparent;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.3);
        }

        .projects-side-current {
            margin-top: auto;
            padding: 16px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.05) 100%);
            border-top: 1px solid rgba(16, 185, 129, 0.2);
        }

        .projects-side-current .current-label {
            font-size: 0.7em;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .projects-side-current .current-name {
            font-size: 0.95em;
            color: #10b981;
            font-weight: 600;
        }

        .project-side-item .project-meta {
            display: flex;
            gap: 10px;
            font-size: 0.75em;
            color: #888;
        }

        .projects-side-current {
            margin-top: auto;
            padding: 12px;
            background: rgba(233,69,96,0.1);
            border-radius: 10px;
            border: 1px solid rgba(233,69,96,0.2);
        }

        .projects-side-current .current-label {
            font-size: 0.7em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .projects-side-current .current-name {
            font-size: 0.9em;
            color: var(--accent-primary);
            font-weight: 600;
        }

        /* Project Context Menu - Compact */
        .project-context-menu {
            position: fixed;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: 10px;
            padding: 6px;
            min-width: 160px;
            max-width: 200px;
            box-shadow: var(--shadow-lg);
            z-index: 10000;
            animation: ctxIn 0.12s ease-out;
        }

        @keyframes ctxIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .ctx-header {
            padding: 8px 10px;
            border-bottom: 1px solid var(--border-subtle);
            margin-bottom: 4px;
        }

        .ctx-name {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ctx-stats {
            display: block;
            font-size: 11px;
            color: var(--text-tertiary);
            margin-top: 2px;
        }

        .ctx-item {
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.15s;
        }

        .ctx-item:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .ctx-danger {
            color: var(--danger);
        }

        .ctx-danger:hover {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }

        .ctx-divider {
            height: 1px;
            background: var(--border-subtle);
            margin: 4px 0;
        }

        /* More Button in Project Items */
        .project-side-item .more-btn {
            opacity: 0;
            background: var(--bg-hover);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            font-size: 14px;
            border-radius: var(--radius-sm);
            transition: all var(--transition-fast);
            font-weight: bold;
            letter-spacing: 1px;
        }

        .project-side-item:hover .more-btn {
            opacity: 1;
        }

        .project-side-item .more-btn:hover {
            background: var(--accent-secondary);
            color: white;
        }

        .panel-section {
            margin-bottom: 15px;
        }

        .panel-section-title {
            font-size: 0.7em;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }

        /* Stats Panel - Professional Design */
        #statsPanel {
            padding: 16px !important;
            overflow-y: auto !important;
            max-height: calc(100vh - 140px) !important;
        }

        .stats-cards {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .stats-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .stats-card.primary {
            background: var(--accent-gradient);
            border: none;
            grid-column: span 2;
        }

        .stats-card.primary .stats-card-value {
            color: white;
            font-size: 32px;
        }

        .stats-card.primary .stats-card-label {
            color: rgba(255,255,255,0.8);
        }

        .stats-card-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.2;
        }

        .stats-card-label {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stats-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .stats-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .stats-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .stats-section-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .stats-progress-bar {
            height: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .stats-progress-fill {
            height: 100%;
            background: var(--accent-gradient);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .stats-progress-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .stats-time-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stats-time-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .time-icon {
            font-size: 20px;
        }

        .time-value {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .time-label {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .stats-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .stats-list-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            font-size: 13px;
        }

        .list-type {
            flex: 1;
            font-weight: 500;
            color: var(--text-primary);
        }

        .list-count {
            color: var(--text-tertiary);
            font-size: 12px;
            margin-right: 12px;
        }

        .list-words {
            font-weight: 600;
            color: var(--accent-primary);
            min-width: 80px;
            text-align: right;
        }

        .stats-authors {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stats-author-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .author-info {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 100px;
        }

        .author-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .author-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .author-bar-wrap {
            flex: 1;
            height: 6px;
            background: var(--bg-secondary);
            border-radius: 3px;
            overflow: hidden;
        }

        .author-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .author-stats {
            font-size: 12px;
            color: var(--text-tertiary);
            min-width: 80px;
            text-align: right;
        }

        .stats-quick {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .quick-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-subtle);
            font-size: 13px;
        }

        .quick-item:last-child {
            border-bottom: none;
        }

        .quick-item span {
            color: var(--text-secondary);
        }

        .quick-item strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Task Status Cards */
        .stats-task-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .stats-task-card {
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .stats-task-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .stats-task-card.todo {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }

        .stats-task-card.complete {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
        }

        .stats-task-card.working {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .stats-task-card.urgent {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .stats-task-card.dontforget {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
        }

        .stats-task-card .task-count {
            font-size: 28px;
            font-weight: 700;
            line-height: 1.2;
        }

        .stats-task-card .task-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.9;
            margin-top: 4px;
        }

        /* Progress Section Dual */
        .stats-progress-dual {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .stats-progress-item {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 14px;
            text-align: center;
        }

        .stats-progress-item .progress-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stats-progress-item .progress-label {
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-top: 4px;
        }

        .stats-progress-item.realized .progress-value {
            color: #22c55e;
        }

        .stats-progress-item.planned .progress-value {
            color: #3b82f6;
        }

        /* ======== NEW STATS HERO SECTION ======== */
        .stats-hero {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d1b4e 100%);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }
        
        .stats-hero-main {
            text-align: center;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .stats-hero-number {
            font-size: 48px;
            font-weight: 800;
            background: linear-gradient(135deg, #8b5cf6, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.1;
        }
        
        .stats-hero-label {
            font-size: 14px;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 4px;
        }
        
        .stats-hero-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .stats-hero-item {
            text-align: center;
            padding: 10px 5px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
        }
        
        .stats-hero-item .hero-value {
            display: block;
            font-size: 20px;
            font-weight: 700;
            color: #fff;
        }
        
        .stats-hero-item .hero-label {
            display: block;
            font-size: 10px;
            color: rgba(255,255,255,0.5);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }
        
        /* ======== STATUS GRID ======== */
        .stats-status-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-top: 12px;
        }
        
        .stats-status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            font-size: 12px;
        }
        
        .stats-status-item .status-icon {
            font-size: 14px;
        }
        
        .stats-status-item .status-name {
            flex: 1;
            color: var(--text-secondary);
        }
        
        .stats-status-item .status-count {
            font-weight: 700;
            color: var(--text-primary);
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
        }
        
        /* ======== SPECIAL NODES GRID ======== */
        .stats-special-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .stats-special-card {
            padding: 12px 8px;
            border-radius: 12px;
            text-align: center;
            color: white;
        }
        
        .stats-special-card .special-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }
        
        .stats-special-card .special-value {
            font-size: 22px;
            font-weight: 700;
            display: block;
        }
        
        .stats-special-card .special-label {
            font-size: 10px;
            opacity: 0.85;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* ======== TASK MINI LIST ======== */
        .stats-task-mini {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }
        
        .task-mini-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-secondary);
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        
        .task-mini-item:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        
        .task-mini-item .mini-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        
        /* ======== CONNECTIONS STATS ======== */
        .stats-connections {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .conn-stat {
            text-align: center;
            padding: 12px 8px;
            background: var(--bg-secondary);
            border-radius: 10px;
        }
        
        .conn-stat .conn-value {
            display: block;
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-primary);
        }
        
        .conn-stat .conn-label {
            display: block;
            font-size: 10px;
            color: var(--text-tertiary);
            margin-top: 4px;
            text-transform: uppercase;
        }

        /* Task Filter Buttons */
        .task-filter-btn {
            background: #3a3a4a;
            color: #aaa;
            border: none;
            padding: 8px 14px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .task-filter-btn:hover {
            background: #4a4a5a;
            color: #fff;
        }

        .task-filter-btn.active {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: #fff;
        }
        
        /* Task Manager Sidebar Styles */
        .tm-sidebar-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 4px;
        }
        
        .tm-sidebar-item:hover {
            background: rgba(139, 92, 246, 0.15);
        }
        
        .tm-sidebar-item.active {
            background: rgba(139, 92, 246, 0.25);
            border-left: 3px solid #8b5cf6;
        }
        
        .tm-sidebar-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .tm-sidebar-info {
            flex: 1;
            min-width: 0;
        }
        
        .tm-sidebar-title {
            font-size: 13px;
            font-weight: 500;
            color: #e0e0e0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .tm-sidebar-count {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        
        /* Task View Toggle Buttons */
        .task-view-btn {
            background: #3a3a4a;
            color: #aaa;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .task-view-btn:hover {
            background: #4a4a5a;
            color: #fff;
        }
        
        .task-view-btn.active {
            background: #8b5cf6;
            color: #fff;
        }
        
        /* Timeline Scale Buttons */
        .timeline-scale-btn {
            background: #3a3a4a;
            color: #aaa;
            border: none;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }
        
        .timeline-scale-btn:hover {
            background: #4a4a5a;
            color: #fff;
        }
        
        .timeline-scale-btn.active {
            background: #22c55e;
            color: #fff;
        }
        
        /* White scale buttons for timeline header */
        .tl-scale-btn-white {
            background: rgba(255,255,255,0.2);
            color: #fff;
            border: none;
            padding: 6px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .tl-scale-btn-white:hover {
            background: rgba(255,255,255,0.35);
        }
        
        .tl-scale-btn-white.active {
            background: #fff;
            color: #8b5cf6;
            font-weight: 600;
        }
        
        .tl-zoom-btn-white {
            background: rgba(255,255,255,0.2);
            color: #fff;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .tl-zoom-btn-white:hover {
            background: rgba(255,255,255,0.35);
        }
        
        /* Timeline Container */
        .timeline-wrapper {
            display: flex;
            min-height: 100%;
        }
        
        .timeline-sidebar {
            width: 350px;
            min-width: 350px;
            background: #1a1a2e;
            border-right: 2px solid #444;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 5;
            overflow-y: auto;
        }
        
        .timeline-sidebar-header {
            padding: 10px 12px;
            background: #252538;
            border-bottom: 1px solid #333;
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            font-weight: 600;
        }
        
        .timeline-sidebar-item {
            padding: 10px 15px;
            border-bottom: 1px solid #2a2a3e;
            font-size: 13px;
            color: #e0e0e0;
            height: 40px;
            display: flex;
            align-items: center;
            gap: 10px;
            overflow: hidden;
        }
        
        .timeline-sidebar-item.parent-row {
            background: #252538;
            font-weight: 600;
            color: #8b5cf6;
        }
        
        .timeline-sidebar-item .task-title {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .timeline-chart {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
        }
        
        .timeline-header {
            display: flex;
            background: #252538;
            border-bottom: 1px solid #333;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .timeline-header-cell {
            min-width: 80px;
            padding: 10px 8px;
            text-align: center;
            font-size: 11px;
            color: #888;
            border-right: 1px solid #333;
            flex-shrink: 0;
        }
        
        .timeline-header-cell.today {
            background: rgba(139, 92, 246, 0.2);
            color: #8b5cf6;
        }
        
        .timeline-body {
            position: relative;
        }
        
        .timeline-row {
            height: 40px;
            display: flex;
            border-bottom: 1px solid #2a2a3e;
            position: relative;
        }
        
        .timeline-row.parent-row {
            background: #1e1e2e;
        }
        
        .timeline-cell {
            min-width: 80px;
            border-right: 1px solid #2a2a3e;
            flex-shrink: 0;
            position: relative;
        }
        
        .timeline-cell.today {
            background: rgba(139, 92, 246, 0.1);
        }
        
        .timeline-bar {
            position: absolute;
            height: 24px;
            top: 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 10px;
            color: #fff;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 5;
        }
        
        .timeline-bar:hover {
            transform: scaleY(1.1);
            z-index: 10;
        }
        
        .timeline-bar.todo { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); }
        .timeline-bar.ongoing { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }
        .timeline-bar.working { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }
        .timeline-bar.complete { background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); }
        .timeline-bar.done { background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); }
        .timeline-bar.urgent { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); }
        .timeline-bar.dontforget { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); }
        
        .timeline-dependency {
            position: absolute;
            pointer-events: none;
            z-index: 3;
        }
        
        .timeline-today-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 8;
        }
        
        /* ======== TIMELINE BAR (Fixed Top - Below Menu/Tabs) ======== */
        .timeline-bar-container {
            position: fixed;
            top: 47px;
            left: 0;
            right: 0;
            height: 230px;
            min-height: 180px;
            max-height: 220px;
            background: #1e1e2e;
            border-bottom: 2px solid #8b5cf6;
            z-index: 50;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .timeline-bar-container.collapsed {
            height: auto !important;
            min-height: auto;
        }
        
        .timeline-bar-container.collapsed .timeline-bar-content,
        .timeline-bar-container.collapsed .timeline-bar-ruler {
            display: none;
        }
        
        /* When timeline is open, push main layout down */
        body.timeline-open .main-layout {
            margin-top: 180px;
            height: calc(100vh - 88px - 180px);
        }
        
        body.timeline-open .canvas-container {
            margin-top: 0;
        }
        
        /* Timeline toggle button in header */
        #timelineToggleBtn.timeline-toggle-btn,
        .header-actions .timeline-toggle-btn {
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 6px !important;
            padding: 8px 16px !important;
            background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%) !important;
            border: none !important;
            border-radius: 8px !important;
            color: white !important;
            font-size: 13px !important;
            font-weight: 600 !important;
            cursor: pointer !important;
            transition: all 0.15s ease !important;
            margin-right: 10px !important;
            box-sizing: border-box !important;
            flex-shrink: 0 !important;
            white-space: nowrap !important;
            width: auto !important;
            height: auto !important;
            min-width: auto !important;
            min-height: auto !important;
        }
        
        #timelineToggleBtn.timeline-toggle-btn:hover,
        .header-actions .timeline-toggle-btn:hover {
            opacity: 0.9 !important;
            transform: translateY(-1px) !important;
        }
        
        #timelineToggleBtn.timeline-toggle-btn .arrow,
        .header-actions .timeline-toggle-btn .arrow {
            font-size: 12px !important;
            transition: transform 0.2s !important;
            display: inline-block !important;
            line-height: 1 !important;
            margin: 0 !important;
            padding: 0 !important;
            flex-shrink: 0 !important;
            color: white !important;
        }
        
        #timelineToggleBtn.timeline-toggle-btn.open .arrow,
        .header-actions .timeline-toggle-btn.open .arrow {
            transform: rotate(180deg) !important;
        }
        
        #timelineToggleBtn.timeline-toggle-btn.open,
        .header-actions .timeline-toggle-btn.open {
            background: linear-gradient(135deg, #8b5cf6 0%, #6d28d9 100%) !important;
            color: white !important;
        }
        
        #timelineToggleBtn.timeline-toggle-btn.open:hover,
        .header-actions .timeline-toggle-btn.open:hover {
            opacity: 0.9 !important;
            transform: translateY(-1px) !important;
        }
        
        #timelineToggleBtn.timeline-toggle-btn.open #timelineToggleBtnLabel,
        #timelineToggleBtn.timeline-toggle-btn #timelineToggleBtnLabel,
        .header-actions .timeline-toggle-btn.open #timelineToggleBtnLabel,
        .header-actions .timeline-toggle-btn #timelineToggleBtnLabel {
            color: white !important;
            background: none !important;
            padding: 0 !important;
            margin: 0 !important;
            border: none !important;
            font-weight: 600 !important;
            font-size: 13px !important;
            display: inline-block !important;
            line-height: 1 !important;
            white-space: nowrap !important;
            flex-shrink: 0 !important;
        }
        
        .timeline-bar-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: linear-gradient(135deg, #2a2a40 0%, #1e1e2e 100%);
            border-bottom: 1px solid #333;
            color: #fff;
        }
        
        .timeline-bar-toggle {
            background: rgba(255,255,255,0.2);
            border: none;
            color: #fff;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .timeline-bar-toggle:hover {
            background: rgba(255,255,255,0.35);
        }
        
        .timeline-bar-close {
            background: rgba(255,255,255,0.15);
            border: none;
            color: #fff;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }
        
        .timeline-bar-close:hover {
            background: rgba(239, 68, 68, 0.5);
        }
        
        .tl-scale-btn {
            background: #2a2a4a;
            color: #ccc;
            border: 1px solid #444;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }
        
        .tl-scale-btn:hover {
            background: #3a3a5a;
            color: #fff;
            border-color: #8b5cf6;
        }
        
        .tl-scale-btn.active {
            background: #8b5cf6;
            color: #fff;
            font-weight: 600;
            border-color: #8b5cf6;
        }
        
        .tl-zoom-btn {
            background: #2a2a4a;
            color: #ccc;
            border: 1px solid #444;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .tl-zoom-btn:hover {
            background: #3a3a5a;
            border-color: #8b5cf6;
            color: #fff;
        }
        
        .timeline-bar-resize {
            height: 8px;
            background: linear-gradient(180deg, #333 0%, #1a1a2e 100%);
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 10px;
            user-select: none;
        }
        
        .timeline-bar-resize:hover {
            background: linear-gradient(180deg, #8b5cf6 0%, #1a1a2e 100%);
            color: #8b5cf6;
        }
        
        .timeline-bar-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            background: #1e1e2e;
            position: relative;
            min-height: 0;
        }
        
        /* Enable vertical scrolling for both columns - synced scrolling */
        .timeline-bar-content .timeline-labels-column,
        .timeline-bar-content .timeline-tracks-column {
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #555 #1e1e2e;
        }
        
        /* Hide scrollbar on tracks column to avoid double scrollbar */
        .timeline-bar-content .timeline-tracks-column::-webkit-scrollbar-corner {
            background: transparent;
        }
        
        .timeline-labels-column {
            width: 280px !important;
            min-width: 280px !important;
            max-width: 280px !important;
            flex-shrink: 0 !important;
            background: #1e1e2e;
            display: block !important;
            visibility: visible !important;
            border-right: 2px solid #444;
            overflow-y: auto;
            overflow-x: hidden;
            position: sticky;
            left: 0;
            z-index: 5;
            resize: horizontal;
        }
        
        .timeline-labels-column::-webkit-scrollbar {
            width: 6px;
        }
        
        .timeline-labels-column::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }
        
        .timeline-tracks-column {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            background: #1a1a2a;
            z-index: 3;
        }
        
        /* Task Manager specific: Add space between tracks and ruler to prevent scroll bar overlap */
        #taskManagerTracksScroll {
            padding-bottom: 12px;
            padding-right: 8px;
            margin-bottom: 4px;
        }
        
        #taskManagerRuler {
            margin-top: 4px;
            margin-bottom: 0;
        }
        
        .timeline-tracks-column::-webkit-scrollbar {
            height: 8px;
            width: 8px;
        }
        
        .timeline-tracks-column::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        
        /* Task Manager: Ensure scroll bar is visible and doesn't overlap with ruler */
        #taskManagerTracksScroll::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        #taskManagerTracksScroll::-webkit-scrollbar-thumb {
            background: #666;
            border-radius: 5px;
            border: 1px solid #444;
        }
        
        #taskManagerTracksScroll::-webkit-scrollbar-track {
            background: #1a1a2a;
        }
        
        #taskManagerTracksScroll::-webkit-scrollbar-corner {
            background: #1a1a2a;
        }
        
        .timeline-lane {
            display: flex;
            align-items: stretch;
            height: 32px;
            min-height: 32px;
            max-height: 32px;
            border-bottom: 1px solid #333;
            position: relative;
            box-sizing: border-box;
        }
        
        .timeline-lane-label {
            width: 100%;
            height: 28px;
            min-height: 28px;
            max-height: 28px;
            padding: 0 12px;
            font-size: 12px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            line-height: 28px;
            color: #e0e0e0;
            background: #1e1e2e;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
            overflow: hidden;
            box-sizing: border-box;
            border-bottom: 1px solid #333;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .timeline-lane-label:hover {
            background: rgba(139, 92, 246, 0.2);
            border-left-width: 6px;
        }
        
        .timeline-lane-label:active {
            background: rgba(139, 92, 246, 0.3);
        }
        
        /* Hierarchical indentation visual guide for timeline labels */
        .timeline-lane-label[style*="padding-left:20px"]::before,
        .timeline-lane-label[style*="padding-left:40px"]::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to bottom, transparent, rgba(139, 92, 246, 0.5) 50%, transparent);
            z-index: 1;
        }
        
        .timeline-track-row {
            display: flex;
            align-items: center;
            position: relative;
            height: 28px;
            min-height: 28px;
            max-height: 28px;
            box-sizing: border-box;
            z-index: 2;
            line-height: 28px;
        }
        
        .timeline-track-row:hover {
            background: rgba(139, 92, 246, 0.08);
        }
        
        /* Hierarchical indentation visual guide for timeline tracks */
        .timeline-track-row[style*="padding-left:20px"]::before,
        .timeline-track-row[style*="padding-left:40px"]::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to bottom, transparent, rgba(139, 92, 246, 0.5) 50%, transparent);
            z-index: 1;
        }
        
        /* Toggle button styling for timeline dependencies */
        /* Small toggle buttons in timeline dependencies - NOT for header button */
        .timeline-lane-label .timeline-toggle-btn,
        .timeline-node-bar .timeline-toggle-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 3px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.4);
            color: #8b5cf6;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .timeline-lane-label .timeline-toggle-btn:hover,
        .timeline-node-bar .timeline-toggle-btn:hover {
            background: rgba(139, 92, 246, 0.4);
            border-color: #8b5cf6;
            transform: scale(1.1);
        }
        
        .tl-parent-name {
            font-size: 12px;
            color: #e0e0e0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: none;
            flex: 1;
        }
        
        /* Timeline parent/child row styles */
        .timeline-parent-row {
            background: #252538 !important;
            height: 32px !important;
            min-height: 32px !important;
        }
        
        .timeline-child-row {
            background: #1a1a2e;
            padding-left: 30px !important;
        }
        
        .timeline-child-row:hover {
            background: rgba(139, 92, 246, 0.1);
        }
        
        .tl-parent-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }
        
        .tl-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .tl-task-count {
            font-size: 10px;
            color: #888;
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 10px;
            flex-shrink: 0;
        }
        
        .tl-task-name {
            font-size: 12px !important;
            font-weight: 600 !important;
            color: #fff !important;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            flex: 1;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .tl-task-name:hover {
            color: #8b5cf6;
        }
        
        /* Ensure timeline labels column is always visible */
        .timeline-labels-column .timeline-lane-label {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .draggable-bar {
            cursor: grab;
        }
        
        .draggable-bar:active {
            cursor: grabbing;
        }
        
        .bar-text {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 11px;
            padding: 0 4px;
        }
        
        .bar-dep-label {
            position: absolute;
            left: -45px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            font-weight: 700;
            color: #ef4444;
            background: rgba(30, 30, 46, 0.9);
            padding: 2px 5px;
            border-radius: 3px;
            white-space: nowrap;
        }
        
        /* Timeline Date Columns */
        .timeline-dates-column {
            display: flex;
            flex-direction: column;
        }
        
        .timeline-date-row {
            display: flex;
            align-items: center;
            height: 28px;
            min-height: 28px;
            max-height: 28px;
            box-sizing: border-box;
        }
        
        .tl-date-col {
            width: 100px;
            min-width: 100px;
            padding: 0 8px;
            font-size: 11px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid #333;
            height: 100%;
            box-sizing: border-box;
            line-height: 28px;
        }
        
        .tl-date-col:last-child {
            border-right: none;
        }
        
        .tl-start-date {
            color: #3b82f6;
            font-weight: 500;
        }
        
        .tl-end-date {
            color: #ef4444;
            font-weight: 500;
        }
        
        .tl-duration {
            color: #8b5cf6;
            font-weight: 500;
        }
        
        .timeline-header-row {
            font-weight: 600;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .timeline-today-header {
            pointer-events: none;
        }
        
        .bar-resize-left,
        .bar-resize-right {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            cursor: ew-resize;
            background: rgba(255,255,255,0.1);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .bar-resize-left {
            left: 0;
            border-radius: 4px 0 0 4px;
        }
        
        .bar-resize-right {
            right: 0;
            border-radius: 0 4px 4px 0;
        }
        
        .timeline-node-bar:hover .bar-resize-left,
        .timeline-node-bar:hover .bar-resize-right {
            opacity: 1;
        }
        
        .timeline-resize-handle {
            display: none; /* Hidden - fixed height timeline */
            height: 0;
            background: #1e1e2e;
            border-top: none;
            cursor: default;
            align-items: center;
            justify-content: center;
            color: #444;
            font-size: 8px;
            flex-shrink: 0;
            user-select: none;
        }
        
        .timeline-resize-handle:hover {
            background: #2a2a40;
            color: #8b5cf6;
        }
        
        .timeline-lane-track {
            flex: 1;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            background: #1a1a2e;
            min-width: 0;
        }
        
        .timeline-node-bar {
            position: absolute;
            height: 20px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 10px;
            color: #fff;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            top: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 5;
        }
        
        .timeline-node-bar:hover {
            transform: scaleY(1.15) scaleX(1.02);
            box-shadow: 0 6px 16px rgba(0,0,0,0.6), 0 0 20px rgba(139, 92, 246, 0.4);
            z-index: 10;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .timeline-node-bar:active {
            transform: scaleY(1.1) scaleX(1.01);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .timeline-node-bar.draggable-bar {
            cursor: grab;
        }
        
        .timeline-node-bar.draggable-bar:active {
            cursor: grabbing;
            opacity: 0.8;
            transform: scaleY(1.15);
        }
        
        /* Timeline dependency lines */
        .timeline-dependencies-svg {
            pointer-events: none;
        }
        
        .timeline-dependencies-svg path {
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
        }
        
        .timeline-bar-ruler {
            display: flex;
            height: 22px;
            background: #1a1a2a;
            border-top: 1px solid #333;
            margin-left: 452px;
            overflow-x: auto;
            overflow-y: hidden;
            flex-shrink: 0;
            z-index: 0;
            position: relative;
        }
        
        .timeline-bar-ruler::-webkit-scrollbar {
            display: none;
        }
        
        .timeline-ruler-cell {
            min-width: 100px;
            padding: 4px 6px;
            font-size: 10px;
            color: #666;
            text-align: center;
            border-right: 1px solid #2a2a3e;
            flex-shrink: 0;
        }
        
        .timeline-ruler-cell.today {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }
        
        .timeline-now-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #8b5cf6;
            z-index: 1;
            pointer-events: none;
        }
        
        /* Timeline doesn't affect layout - it floats */
        
        /* ======== GANTT CHART STYLES ======== */
        .gantt-container {
            display: flex;
            flex-direction: column;
            min-height: 100%;
            background: #1a1a2e;
        }
        
        .gantt-header {
            display: flex;
            background: #252538;
            border-bottom: 2px solid #8b5cf6;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .gantt-header-label {
            width: 150px;
            min-width: 150px;
            padding: 10px 12px;
            font-size: 11px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            background: #1e1e2e;
            border-right: 1px solid #333;
        }
        
        .gantt-header-timeline {
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        .gantt-header-cell {
            padding: 10px 8px;
            font-size: 11px;
            color: #888;
            text-align: center;
            border-right: 1px solid #333;
            flex-shrink: 0;
            background: #252538;
        }
        
        .gantt-header-cell.today {
            background: rgba(139, 92, 246, 0.3);
            color: #8b5cf6;
            font-weight: 600;
        }
        
        .gantt-body {
            flex: 1;
            overflow-y: auto;
            position: relative;
        }
        
        .gantt-row {
            display: flex;
            border-bottom: 1px solid #2a2a3e;
            min-height: 40px;
        }
        
        .gantt-row.section-row {
            background: #1e1e2e;
        }
        
        .gantt-row.task-row {
            background: #1a1a2e;
        }
        
        .gantt-row-label {
            width: 150px;
            min-width: 150px;
            padding: 8px 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: #252538;
            border-right: 1px solid #333;
            overflow: hidden;
        }
        
        .gantt-row-label.task-label {
            padding-left: 20px;
            background: #1e1e2e;
        }
        
        .gantt-row-icon {
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .gantt-row-title {
            flex: 1;
            font-size: 12px;
            color: #e0e0e0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .gantt-row-title:hover {
            color: #8b5cf6;
        }
        
        .gantt-row-count {
            font-size: 10px;
            color: #666;
            background: #3a3a4a;
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .gantt-row-timeline {
            flex: 1;
            position: relative;
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            align-items: center;
        }
        
        .gantt-bar {
            position: absolute;
            height: 26px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 11px;
            color: #fff;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .gantt-bar:hover {
            transform: scaleY(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            z-index: 5;
        }
        
        .gantt-bar.section-bar {
            height: 22px;
            opacity: 0.8;
        }
        
        .gantt-bar.task-bar {
            height: 24px;
        }
        
        .gantt-bar-progress {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            background: rgba(255,255,255,0.25);
            border-radius: 4px 0 0 4px;
        }
        
        .gantt-bar-text {
            position: relative;
            z-index: 2;
        }
        
        .gantt-today-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ef4444;
            z-index: 8;
            pointer-events: none;
        }
        
        /* ======== BEAT BOARD STYLES ======== */
        .beatboard-container {
            display: flex;
            flex-direction: column;
            min-height: 100%;
            position: relative;
            background: #1a1a2e;
        }
        
        .beatboard-tracks {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
        }
        
        .beatboard-track {
            display: flex;
            min-height: 50px;
            border-bottom: 1px solid #333;
        }
        
        .beatboard-track-label {
            width: 80px;
            min-width: 80px;
            padding: 8px 10px;
            font-size: 11px;
            font-weight: 600;
            color: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            background: #252538;
            border-right: 1px solid #333;
            flex-shrink: 0;
        }
        
        .beatboard-track-content {
            flex: 1;
            position: relative;
            min-width: 800px;
            padding: 8px 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            overflow-x: visible;
        }
        
        .beatboard-block {
            height: 34px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            flex-shrink: 0;
            position: relative;
        }
        
        .beatboard-block:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            z-index: 10;
        }
        
        .beatboard-block-text {
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .beatboard-ruler {
            display: flex;
            background: #0f0f1a;
            border-top: 2px solid #333;
            height: 28px;
            flex-shrink: 0;
        }
        
        .beatboard-ruler-label {
            width: 80px;
            min-width: 80px;
            background: #1a1a2e;
            border-right: 1px solid #333;
        }
        
        .beatboard-ruler-content {
            display: flex;
            overflow-x: auto;
        }
        
        .beatboard-ruler-mark {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            border-right: 1px solid #333;
            flex-shrink: 0;
        }
        
        .beatboard-playhead {
            position: absolute;
            top: 0;
            bottom: 28px;
            width: 3px;
            background: linear-gradient(180deg, #6366f1 0%, #8b5cf6 100%);
            left: 80px;
            cursor: ew-resize;
            z-index: 20;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }
        
        .beatboard-playhead::before {
            content: '';
            position: absolute;
            top: 0;
            left: -4px;
            width: 11px;
            height: 11px;
            background: #6366f1;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(99, 102, 241, 0.8);
        }
        
        .beatboard-playhead::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: -4px;
            width: 11px;
            height: 11px;
            background: #8b5cf6;
            border-radius: 50%;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.8);
        }

        /* New Task Dropdown */
        #newTaskDropdown > div:hover {
            background: #3a3a5a !important;
        }

        /* Task List Items */
        .task-item {
            background: #252538;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border-left: 4px solid #8b5cf6;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .task-item:hover {
            background: #2d2d42;
            transform: translateX(4px);
        }

        .task-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .task-item-title {
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            flex: 1;
        }

        .task-item-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .task-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .task-badge.status {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
        }

        .task-badge.importance-low { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .task-badge.importance-medium { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .task-badge.importance-high { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .task-badge.importance-critical { background: rgba(220, 38, 38, 0.3); color: #fca5a5; }

        .task-item-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            font-size: 12px;
            color: #888;
        }

        .task-meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .task-progress-bar {
            width: 100px;
            height: 6px;
            background: #3a3a4a;
            border-radius: 3px;
            overflow: hidden;
        }

        .task-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .task-item-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #333;
        }

        .task-action-btn {
            background: #3a3a4a;
            color: #aaa;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .task-action-btn:hover {
            background: #4a4a5a;
            color: #fff;
        }

        .task-action-btn.delete:hover {
            background: #ef4444;
            color: #fff;
        }

        .task-empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .task-empty-state .icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        /* Outline Tree - Modern & Readable */
        .outline-item {
            padding: 10px 12px;
            margin-bottom: 4px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-primary);
            transition: all 0.2s ease;
            line-height: 1.4;
        }

        .outline-item:hover {
            background: var(--bg-hover);
        }

        .outline-item.active {
            background: var(--accent-primary);
            color: white;
        }

        .outline-item .toggle-btn {
            font-size: 12px;
            color: var(--text-tertiary);
            min-width: 50px;
        }

        .outline-item .outline-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .outline-item .word-count {
            margin-left: auto;
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
        }

        .outline-item .word-count .current {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .outline-item .word-count .target {
            color: var(--text-tertiary);
        }

        .outline-item.active .word-count {
            color: rgba(255,255,255,0.85);
        }

        .outline-item.active .word-count .current {
            color: #fff;
        }

        .outline-item.active .toggle-btn {
            color: rgba(255,255,255,0.85);
        }

        /* Outline Task Badge */
        .outline-task-badge {
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            margin-left: 6px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .outline-task-badge:hover {
            transform: scale(1.1);
        }

        /* Status Circle for all nodes */
        .outline-status-circle {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-left: auto;
            flex-shrink: 0;
            box-shadow: 0 0 4px currentColor;
            animation: statusPulse 2s ease-in-out infinite;
        }
        
        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Task Node in Outline */
        .outline-item.task-outline-item {
            border-left: 3px solid #8b5cf6 !important;
            background: rgba(139, 92, 246, 0.1);
        }

        .outline-item.task-outline-item:hover {
            background: rgba(139, 92, 246, 0.2);
        }

        .outline-item.task-outline-item.active {
            background: #8b5cf6;
        }

        /* Node type colors for outline items - left border */
        .outline-item[data-type="section"] { border-left: 3px solid #ff9800; }
        .outline-item[data-type="group"] { border-left: 3px solid #ff9800; }
        .outline-item[data-type="research"] { border-left: 3px solid #4CAF50; }
        .outline-item[data-type="note"] { border-left: 3px solid #9C27B0; }
        .outline-item[data-type="reference"] { border-left: 3px solid #00BCD4; }
        .outline-item[data-type="draft"] { border-left: 3px solid #ff9800; }
        .outline-item[data-type="conclusion"] { border-left: 3px solid #f44336; }
        .outline-item[data-type="appendix"] { border-left: 3px solid #607D8B; }
        .outline-item[data-type="abstract"] { border-left: 3px solid #673AB7; }
        .outline-item[data-type="introduction"] { border-left: 3px solid #2196F3; }

        /* Hover colors matching node types */
        .outline-item[data-type="section"]:hover { background: #ff9800; color: #fff; }
        .outline-item[data-type="group"]:hover { background: #ff9800; color: #fff; }
        .outline-item[data-type="research"]:hover { background: #4CAF50; color: #fff; }
        .outline-item[data-type="note"]:hover { background: #9C27B0; color: #fff; }
        .outline-item[data-type="reference"]:hover { background: #00BCD4; color: #fff; }
        .outline-item[data-type="draft"]:hover { background: #ff9800; color: #fff; }
        .outline-item[data-type="conclusion"]:hover { background: #f44336; color: #fff; }
        .outline-item[data-type="appendix"]:hover { background: #607D8B; color: #fff; }
        .outline-item[data-type="abstract"]:hover { background: #673AB7; color: #fff; }
        .outline-item[data-type="introduction"]:hover { background: #2196F3; color: #fff; }

        .outline-item:hover .word-count,
        .outline-item:hover .word-count .current,
        .outline-item:hover .word-count .target {
            color: rgba(255,255,255,0.9) !important;
        }

        .outline-act {
            font-weight: bold;
            color: #ffc107;
            margin-top: 10px;
        }

        .progress-bar {
            width: 60px;
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar .progress-fill {
            height: 100%;
            background: var(--success);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .progress-bar .progress-fill.warning {
            background: var(--warning);
        }

        .progress-bar .progress-fill.danger {
            background: var(--danger);
        }

        .progress-bar .progress-fill.complete {
            background: var(--success);
        }

        .percent-text {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: 600;
        }

        .target-text {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        /* Outline Drag & Drop */
        .outline-item {
            cursor: grab;
        }

        .outline-item.dragging {
            opacity: 0.5;
            background: #444;
        }

        .outline-item.drag-over {
            border-top: 2px solid #e94560;
        }

        .outline-item.drag-over-bottom {
            border-bottom: 2px solid #e94560;
        }

        .outline-item.drag-over-child {
            background: rgba(233, 69, 96, 0.3) !important;
            border: 2px dashed #e94560;
            border-radius: 6px;
        }

        .outline-item.dragging {
            opacity: 0.5;
            background: #555;
        }

        /* Canvas Container */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            background: #2d2d2d;
        }

        /* Properties Panel (Right Side) */
        .properties-panel {
            width: 320px;
            min-width: 280px;
            max-width: 400px;
            background: #1e1e2e;
            border-left: 1px solid #333;
            display: none;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .properties-panel.active {
            display: flex;
        }

        .properties-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(135deg, #2a2a40 0%, #1e1e2e 100%);
            border-bottom: 1px solid #333;
        }

        .properties-title {
            font-weight: 600;
            color: #fff;
            font-size: 14px;
        }

        .properties-close {
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            color: #aaa;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .properties-close:hover {
            background: #e94560;
            color: #fff;
        }

        .properties-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .properties-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #666;
            text-align: center;
        }

        .properties-empty p {
            margin-top: 10px;
            font-size: 13px;
        }

        .prop-group {
            margin-bottom: 20px;
        }

        .prop-group-title {
            font-size: 11px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            padding-bottom: 6px;
            border-bottom: 1px solid #333;
        }

        .prop-row {
            margin-bottom: 12px;
        }

        .prop-label {
            display: block;
            font-size: 12px;
            color: #999;
            margin-bottom: 4px;
        }

        .prop-input {
            width: 100%;
            padding: 10px 12px;
            background: #2a2a40;
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            transition: all 0.2s;
        }

        .prop-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99,102,241,0.2);
        }

        .prop-textarea {
            width: 100%;
            padding: 12px;
            background: #2a2a40;
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            min-height: 150px;
            resize: vertical;
            font-family: inherit;
            line-height: 1.6;
        }

        .prop-textarea:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99,102,241,0.2);
        }

        .prop-select {
            width: 100%;
            padding: 10px 12px;
            background: #2a2a40;
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }

        .prop-select:focus {
            outline: none;
            border-color: #6366f1;
        }

        .prop-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
            margin-bottom: 8px;
        }

        .prop-tag {
            padding: 6px 12px;
            background: #6366f1;
            color: #fff;
            border-radius: 14px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .prop-tag-remove {
            cursor: pointer;
            opacity: 0.7;
        }

        .prop-tag-remove:hover {
            opacity: 1;
        }

        .prop-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }

        .prop-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99,102,241,0.4);
        }

        .prop-btn-danger {
            background: linear-gradient(135deg, #e94560 0%, #ff6b8a 100%);
        }

        .prop-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .prop-stat {
            background: #2a2a40;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .prop-stat-value {
            font-size: 20px;
            font-weight: 600;
            color: #6366f1;
        }

        .prop-stat-label {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }

        /* Light mode support */
        body.light-mode .properties-panel {
            background: #f8f9fa;
            border-left-color: #ddd;
        }

        body.light-mode .properties-header {
            background: linear-gradient(135deg, #fff 0%, #f0f0f0 100%);
            border-bottom-color: #ddd;
        }

        body.light-mode .properties-title {
            color: #333;
        }

        body.light-mode .prop-input,
        body.light-mode .prop-textarea,
        body.light-mode .prop-select {
            background: #fff;
            border-color: #ddd;
            color: #333;
        }

        body.light-mode .prop-stat {
            background: #fff;
        }

        body.light-mode .prop-group-title {
            color: #666;
            border-bottom-color: #ddd;
        }

        body.light-mode .prop-label {
            color: #666;
        }

        #canvas {
            position: relative;
            width: 5000px;
            height: 3000px;
            background-color: #2d2d2d;
            background-image: radial-gradient(circle, #3a3a3a 1px, transparent 1px);
            background-size: 25px 25px;
            background-position: 0 0;
        }

        /* SVG Connections - must be BEHIND nodes */
        #connections {
            position: absolute;
            top: 0;
            left: 0;
            width: 5000px;
            height: 3000px;
            z-index: 1;
            overflow: visible;
            pointer-events: none;
        }

        .connection-path {
            fill: none;
            stroke: #4fc3f7;
            stroke-width: 5px;
            opacity: 0.9;
            transition: stroke 0.15s, opacity 0.15s, stroke-width 0.15s;
            pointer-events: all !important;
            cursor: grab;
        }

        .connection-path:hover {
            stroke-width: 8px;
            opacity: 1;
            filter: drop-shadow(0 0 10px rgba(79, 195, 247, 0.9));
            cursor: grabbing;
        }

        .connection-path.hierarchy-connection {
            stroke: #4fc3f7;
            stroke-width: 4px;
            opacity: 0.85;
        }

        .connection-path.hierarchy-connection:hover {
            stroke-width: 7px;
            opacity: 1;
        }

        .connection-path.task-dependency-path {
            stroke: #e94560;
            stroke-width: 3;
            opacity: 1;
        }

        .connection-path.task-dependency-path:hover {
            stroke-width: 4;
            filter: drop-shadow(0 0 8px rgba(233, 69, 96, 0.7));
        }

        .dependency-label {
            pointer-events: none;
            user-select: none;
        }

        .dependency-label-bg {
            pointer-events: none;
        }

        .connection-arrow {
            fill: #4fc3f7;
        }

        /* Connection menu styles */
        .conn-menu-item:hover {
            background: #333 !important;
        }
        .conn-color-btn:hover {
            transform: scale(1.2);
            border-color: #fff !important;
        }
        .connection-path.selected {
            stroke: #e94560 !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 0 8px rgba(233, 69, 96, 0.8));
        }

        /* Nodes */
        .node {
            position: absolute;
            width: 240px;
            border-radius: 12px;
            cursor: move;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: box-shadow 0.2s, width 0.2s;
            overflow: visible;
            background: #fff;
            font-size: 1em;
        }

        /* Card Size Variants */
        .card-small .node {
            width: 180px;
            font-size: 0.85em;
        }
        .card-small .node-header {
            padding: 10px 12px;
        }
        .card-small .node-body {
            padding: 8px 12px;
        }

        .card-medium .node {
            width: 240px;
        }

        .card-large .node {
            width: 320px;
            font-size: 1.05em;
        }
        .card-large .node-header {
            padding: 16px 20px;
        }
        .card-large .node-body {
            padding: 14px 20px;
        }

        .node-toolbar {
            background: #3a3a4a;
            padding: 8px 12px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 40px;
        }

        .node:hover {
            box-shadow: 0 6px 25px rgba(0,0,0,0.5);
        }

        .node.selected {
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.9), 0 0 0 6px rgba(139, 92, 246, 0.5), 0 6px 25px rgba(0,0,0,0.5);
            border: 3px solid rgba(139, 92, 246, 1);
            position: relative;
        }
        
        .node.node-focused {
            animation: nodePulse 1.5s ease-in-out;
        }
        
        @keyframes nodePulse {
            0%, 100% {
                box-shadow: 0 0 50px rgba(139, 92, 246, 1), 0 0 100px rgba(139, 92, 246, 0.7), 0 0 150px rgba(139, 92, 246, 0.4);
            }
            50% {
                box-shadow: 0 0 70px rgba(139, 92, 246, 1), 0 0 140px rgba(139, 92, 246, 0.8), 0 0 200px rgba(139, 92, 246, 0.6);
            }
        }
        
        .node.selected::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            border: 4px solid rgba(139, 92, 246, 0.7);
            border-radius: 14px;
            pointer-events: none;
            z-index: -1;
            animation: selectedGlow 2s ease-in-out infinite;
        }
        
        .node.selected::after {
            content: '‚úì';
            position: absolute;
            top: -12px;
            right: -12px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.6);
            z-index: 1000;
            animation: checkmarkPulse 2s ease-in-out infinite;
        }
        
        @keyframes selectedGlow {
            0%, 100% {
                opacity: 0.7;
                box-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 50px rgba(139, 92, 246, 0.9);
            }
        }
        
        @keyframes checkmarkPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 12px rgba(139, 92, 246, 0.6);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 6px 20px rgba(139, 92, 246, 0.9);
            }
        }

        .node-header {
            padding: 12px 14px;
            font-weight: bold;
            font-size: 0.8em;
            display: flex;
            flex-direction: column;
            gap: 2px;
            position: relative;
            border-radius: 10px 10px 0 0;
        }

        .node-type-label {
            font-size: 0.7em;
            opacity: 0.8;
            font-weight: normal;
        }

        .node-title {
            font-size: 1em;
            flex: 1;
        }
        
        .node-title-row {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }
        
        /* Node status circle indicator */
        .node-status-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            animation: nodeStatusPulse 2s ease-in-out infinite;
        }
        
        @keyframes nodeStatusPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }

        /* Folder indicator - SOL tarafta child sayƒ±sƒ± */
        .folder-indicator {
            background: linear-gradient(135deg, #e94560, #ff6b6b);
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 16px;
            cursor: pointer;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid #fff;
            transition: all 0.2s;
        }

        .folder-indicator:hover {
            transform: scale(1.1);
            background: linear-gradient(135deg, #ff6b6b, #e94560);
        }

        .folder-indicator.collapsed {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
        }

        /* Attachment indicator - SAƒû tarafta */
        .attachment-indicator {
            background: linear-gradient(135deg, #00b894, #55efc4);
            color: #fff;
            font-size: 13px;
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid #fff;
        }

        /* Editor Sidebar Styles */
        .editor-sidebar {
            width: 270px;
            min-width: 270px;
            background: #1a1a2e;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .sidebar-section {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }
        .sidebar-header {
            padding: 16px 20px;
            background: #252540;
            color: #fff;
            font-size: 1em;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .add-attachment-btn {
            background: #e94560;
            color: #fff;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
        }
        .add-attachment-btn:hover {
            background: #ff6b6b;
        }
        .sidebar-tree {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        .sidebar-tree-item {
            padding: 8px 12px;
            margin: 3px 0;
            background: #252540;
            border-radius: 6px;
            color: #ccc;
            font-size: 0.7em;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .sidebar-tree-item:hover {
            background: #3a3a5c;
            color: #fff;
        }
        .sidebar-tree-item.active {
            background: #e94560;
            color: #fff;
        }
        /* Editor Attachments Section */
        .editor-attachments-section {
            background: var(--bg-tertiary);
            border-radius: 12px;
            margin: 8px;
            overflow: hidden;
        }

        .editor-attachments-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-elevated);
            border-bottom: 1px solid var(--border-subtle);
        }

        .editor-attachments-header h4 {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .editor-attachments-header .att-count {
            background: var(--accent-primary);
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
        }

        .add-attachment-btn {
            background: var(--accent-gradient);
            color: white;
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            line-height: 1;
        }

        .add-attachment-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(108, 123, 255, 0.4);
        }

        .sidebar-attachments {
            max-height: 200px;
            overflow-y: auto;
            padding: 8px;
        }

        .attachment-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            margin: 4px 0;
            background: var(--bg-hover);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid transparent;
        }

        .attachment-item:hover {
            background: var(--bg-elevated);
            border-color: var(--border-subtle);
        }

        .attachment-icon {
            font-size: 24px;
            margin-right: 12px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .attachment-thumb {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            object-fit: cover;
            margin-right: 12px;
        }

        .attachment-info {
            flex: 1;
            overflow: hidden;
        }

        .attachment-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: 500;
            margin-bottom: 2px;
        }

        .attachment-size {
            color: var(--text-tertiary);
            font-size: 11px;
        }

        .attachment-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .attachment-item:hover .attachment-actions {
            opacity: 1;
        }

        .attachment-actions button {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
            transition: all 0.15s;
        }

        .attachment-actions button:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .attachment-actions button.delete-btn:hover {
            background: rgba(248, 113, 113, 0.2);
            color: var(--danger);
            border-color: var(--danger);
        }

        .no-attachments {
            text-align: center;
            padding: 24px;
            color: var(--text-tertiary);
            font-size: 13px;
        }

        .no-attachments .empty-icon {
            font-size: 32px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        /* File Preview Modal */
        .file-preview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        .file-preview-content {
            max-width: 90%;
            max-height: 90%;
            background: var(--bg-secondary);
            border-radius: var(--radius-xl);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-default);
        }
        .file-preview-header {
            padding: 16px 20px;
            background: var(--bg-tertiary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-subtle);
        }
        .file-preview-header h3 {
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .file-preview-body {
            flex: 1;
            padding: 24px;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            background: var(--bg-primary);
        }
        .file-preview-body img {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
        }
        .file-preview-body video,
        .file-preview-body audio {
            max-width: 100%;
            border-radius: var(--radius-md);
        }
        .file-preview-body iframe {
            width: 80vw;
            height: 70vh;
            border: none;
            background: #fff;
            border-radius: var(--radius-md);
        }
        .file-preview-actions {
            padding: 16px 20px;
            background: var(--bg-tertiary);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            border-top: 1px solid var(--border-subtle);
        }
        .file-preview-actions button {
            padding: 10px 20px;
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: 13px;
            cursor: pointer;
            transition: all var(--transition-fast);
        }
        .preview-download-btn {
            background: var(--accent-gradient);
            border: none;
            color: white;
        }
        .preview-download-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }
        .preview-close-btn {
            background: var(--bg-hover);
            border: 1px solid var(--border-default);
            color: var(--text-secondary);
        }
        .preview-close-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        .file-preview-actions button.old-style {
            padding: 8px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }
        .preview-download-btn {
            background: #4CAF50;
            color: #fff;
        }
        .preview-close-btn {
            background: #e94560;
            color: #fff;
        }

        .node-body {
            background: #fff;
            padding: 12px 14px;
            font-size: 0.75em;
            color: #444;
            line-height: 1.5;
        }

        .node-summary {
            display: block;
            overflow: visible;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .node-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 14px;
            background: #f5f5f5;
            font-size: 0.7em;
            border-top: 1px solid #eee;
        }

        .node-pov {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: 500;
            color: #111 !important;
            opacity: 1 !important;
        }

        .pov-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .node-words {
            color: #333 !important;
            font-weight: 500;
            opacity: 1 !important;
        }

        .node-words strong {
            color: #e94560;
        }

        .node-descs {
            padding: 6px 14px;
            background: #fafafa;
            border-top: 1px solid #eee;
            font-size: 0.68em;
            color: #666;
        }

        .node-desc-tag {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            margin-right: 8px;
            margin-bottom: 3px;
        }

        /* Connection Points */
        .conn-point {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #e94560;
            border: 3px solid #fff;
            border-radius: 50%;
            cursor: crosshair;
            z-index: 20;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform 0.15s;
        }

        .conn-point:hover {
            transform: scale(1.3);
        }

        .conn-point.top { top: -8px; left: 50%; margin-left: -8px; }
        .conn-point.bottom { bottom: -8px; left: 50%; margin-left: -8px; }
        .conn-point.left { left: -8px; top: 50%; margin-top: -8px; }
        .conn-point.right { right: -8px; top: 50%; margin-top: -8px; }

        /* Connection drag highlight states */
        .conn-point.conn-target-highlight {
            background: #4CAF50;
            animation: connPulse 0.8s ease-in-out infinite;
            transform: scale(1.2);
        }

        .conn-point.conn-hover {
            background: #2196F3 !important;
            transform: scale(1.5) !important;
            box-shadow: 0 0 15px rgba(33, 150, 243, 0.8), 0 0 30px rgba(33, 150, 243, 0.4);
        }

        /* Node highlight when dragging connection */
        .node.connection-source {
            box-shadow: 0 0 0 3px #e94560, 0 0 20px rgba(233, 69, 96, 0.5) !important;
        }

        .node.drop-target-highlight {
            box-shadow: 0 0 0 4px #4CAF50, 0 0 25px rgba(76, 175, 80, 0.6) !important;
            transform: scale(1.02);
        }

        @keyframes connPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.5); }
            50% { box-shadow: 0 0 15px rgba(76, 175, 80, 0.8), 0 0 25px rgba(76, 175, 80, 0.4); }
        }

        /* Node Types */
        .node-prologue .node-header { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
        .node-chapter .node-header { background: #4fc3f7; color: #1a1a1a; }
        .node-act .node-header { background: linear-gradient(135deg, #f7971e, #ffd200); color: #1a1a1a; }
        .node-plotpoint .node-header { background: linear-gradient(135deg, #ee0979, #ff6a00); color: white; }
        .node-midpoint .node-header { background: #00c853; color: white; }
        .node-climax .node-header { background: linear-gradient(135deg, #00d2ff, #3a7bd5); color: white; }
        .node-resolution .node-header { background: linear-gradient(135deg, #8e2de2, #4a00e0); color: white; }
        .node-ending .node-header { background: #d50000; color: white; }

        /* Task Node Types - Dark text like other section nodes */
        .node-todo .node-header { background: linear-gradient(135deg, #3b82f6, #1d4ed8); color: #1a1a1a; }
        .node-research-task .node-header { background: linear-gradient(135deg, #8b5cf6, #6d28d9); color: #1a1a1a; }
        .node-review-task .node-header { background: linear-gradient(135deg, #06b6d4, #0891b2); color: #1a1a1a; }
        .node-edit-task .node-header { background: linear-gradient(135deg, #f59e0b, #d97706); color: #1a1a1a; }
        .node-deadline .node-header { background: linear-gradient(135deg, #ef4444, #dc2626); color: #1a1a1a; }
        .node-milestone .node-header { background: linear-gradient(135deg, #22c55e, #16a34a); color: #1a1a1a; }
        .node-reminder .node-header { background: linear-gradient(135deg, #ec4899, #db2777); color: #1a1a1a; }

        /* ========================================
           TASK NODE - SAME STYLE AS REGULAR NODES
           ======================================== */

        /* Task Node Card - Same structure as .node */
        .task-node-card {
            position: absolute;
            width: 300px;
            min-width: 280px;
            border-radius: 12px;
            cursor: move;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: box-shadow 0.2s, width 0.2s, transform 0.2s;
            overflow: visible;
            background: #fff;
            font-size: 1em;
        }

        .task-node-card:hover {
            box-shadow: 0 6px 25px rgba(0,0,0,0.5);
        }

        .task-node-card.selected {
            border: 3px solid rgba(139, 92, 246, 1);
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.9), 0 0 0 6px rgba(139, 92, 246, 0.5), 0 6px 25px rgba(0,0,0,0.5);
            position: relative;
        }
        
        .task-node-card.node-focused {
            animation: nodePulse 1.5s ease-in-out;
        }
        
        .task-node-card.selected::before {
            content: '';
            position: absolute;
            top: -6px;
            left: -6px;
            right: -6px;
            bottom: -6px;
            border: 4px solid rgba(139, 92, 246, 0.7);
            border-radius: 14px;
            pointer-events: none;
            z-index: -1;
            animation: selectedGlow 2s ease-in-out infinite;
        }
        
        .task-node-card.selected::after {
            content: '‚úì';
            position: absolute;
            top: -12px;
            right: -12px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.6);
            z-index: 1000;
            animation: checkmarkPulse 2s ease-in-out infinite;
        }

        /* Connection drag highlight states for task nodes */
        .task-node-card.connection-source {
            box-shadow: 0 0 0 3px #e94560, 0 0 20px rgba(233, 69, 96, 0.5) !important;
        }

        .task-node-card.drop-target-highlight {
            box-shadow: 0 0 0 4px #4CAF50, 0 0 25px rgba(76, 175, 80, 0.6) !important;
            transform: scale(1.02);
        }

        /* Task Node Header - Like regular node headers with colors */
        .task-node-header {
            padding: 12px 14px;
            font-weight: bold;
            font-size: 0.8em;
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            border-radius: 12px 12px 0 0;
            color: white;
        }

        /* Task Type Colors - Header backgrounds like regular nodes */
        .task-node-card.type-todo .task-node-header { background: #60a5fa; color: #1a1a1a; }
        .task-node-card.type-task .task-node-header { background: #4ade80; color: #1a1a1a; }  /* Legacy task type */
        .task-node-card.type-research-task .task-node-header { background: linear-gradient(135deg, #a78bfa, #8b5cf6); color: #1a1a1a; }
        .task-node-card.type-review-task .task-node-header { background: #22d3ee; color: #1a1a1a; }
        .task-node-card.type-edit-task .task-node-header { background: #fbbf24; color: #1a1a1a; }
        .task-node-card.type-deadline .task-node-header { background: linear-gradient(135deg, #f87171, #ef4444); color: #1a1a1a; }
        .task-node-card.type-milestone .task-node-header { background: #4ade80; color: #1a1a1a; }
        .task-node-card.type-reminder .task-node-header { background: linear-gradient(135deg, #f472b6, #ec4899); color: #1a1a1a; }

        .task-node-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .task-node-title-wrap {
            flex: 1;
            min-width: 0;
        }

        .task-node-type {
            font-size: 9px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: normal;
        }

        .task-node-title {
            font-size: 0.95em;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Task Node Body - Like regular node body */
        .task-node-body {
            padding: 12px 14px;
            background: var(--bg-elevated);
            border-radius: 0 0 12px 12px;
        }

        .task-node-meta {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .task-node-progress-bar {
            height: 4px;
            background: rgba(255,255,255,0.15);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 8px;
        }

        .task-node-progress-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
            background: linear-gradient(90deg, #22c55e, #4ade80);
        }
        .task-node-progress-fill.low { background: linear-gradient(90deg, #f59e0b, #fbbf24); }
        .task-node-progress-fill.medium { background: linear-gradient(90deg, #3b82f6, #60a5fa); }
        .task-node-progress-fill.high { background: linear-gradient(90deg, #22c55e, #4ade80); }
        .task-node-progress-fill.complete { background: linear-gradient(90deg, #10b981, #34d399); }

        .task-badge {
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 500;
            background: rgba(255,255,255,0.1);
            color: var(--text-secondary);
        }

        .task-badge.status-todo { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
        .task-badge.status-working { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .task-badge.status-ongoing { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .task-badge.status-complete { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .task-badge.status-done { background: rgba(34, 197, 94, 0.2); color: #4ade80; }
        .task-badge.status-urgent { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .task-badge.status-review { background: rgba(6, 182, 212, 0.2); color: #22d3ee; }
        .task-badge.overdue { background: rgba(239, 68, 68, 0.3); color: #f87171; animation: pulse-overdue 1s infinite; }
        .task-badge.critical { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .task-badge.approaching { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .task-badge.soon { background: rgba(245, 158, 11, 0.2); color: #fbbf24; }
        .task-badge.dependency-badge { background: rgba(139, 92, 246, 0.2); color: #a78bfa; }

        @keyframes pulse-overdue {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Priority Corner Indicator */
        .priority-corner {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 15;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid #1a1a2e;
        }
        .priority-corner.priority-low { background: #22c55e; }
        .priority-corner.priority-medium { background: #f59e0b; }
        .priority-corner.priority-high { background: #f97316; }
        .priority-corner.priority-critical { background: #ef4444; animation: pulse-critical 0.8s infinite; }

        @keyframes pulse-critical {
            0%, 100% { transform: scale(1); box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3); }
            50% { transform: scale(1.1); box-shadow: 0 4px 15px rgba(239, 68, 68, 0.5); }
        }

        /* Deadline Indicator Banner */
        .deadline-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-radius: 12px 12px 0 0;
            z-index: 5;
        }
        .deadline-indicator.overdue {
            background: linear-gradient(90deg, #ef4444, #dc2626);
            color: white;
            animation: flash-overdue 1.5s infinite;
        }
        .deadline-indicator.critical {
            background: linear-gradient(90deg, #f97316, #ea580c);
            color: white;
        }
        .deadline-indicator.approaching {
            background: linear-gradient(90deg, #f59e0b, #d97706);
            color: #1a1a1a;
        }
        .deadline-indicator.soon {
            background: linear-gradient(90deg, #22c55e, #16a34a);
            color: white;
        }

        @keyframes flash-overdue {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Task Node Deadline Row */
        .task-node-deadline {
            margin-top: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-align: center;
            background: rgba(255,255,255,0.05);
        }
        .task-node-deadline.overdue {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .task-node-deadline.critical {
            background: rgba(249, 115, 22, 0.15);
            color: #fb923c;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }
        .task-node-deadline.approaching {
            background: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }
        .task-node-deadline.soon {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        /* Task Node Dates Row */
        .task-node-dates {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .task-date-badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 500;
        }

        .task-date-badge.start {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .task-date-badge.due {
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .task-date-badge.due.overdue {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
            animation: pulse-overdue 1s infinite;
        }

        .task-date-badge.due.critical {
            background: rgba(249, 115, 22, 0.2);
            color: #fb923c;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .task-date-badge.due.approaching {
            background: rgba(245, 158, 11, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .task-date-badge.due.soon {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
            border: 1px solid rgba(34, 197, 94, 0.2);
        }

        .task-node-desc {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 14px;
            display: block;
            overflow: visible;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Progress Section */
        .task-node-progress-section {
            margin-bottom: 14px;
        }

        .task-node-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .task-node-progress-label {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .task-node-progress-value {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .task-node-progress-bar {
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .task-node-progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .task-node-progress-fill.low { background: linear-gradient(90deg, #ef4444, #f87171); }
        .task-node-progress-fill.medium { background: linear-gradient(90deg, #f59e0b, #fbbf24); }
        .task-node-progress-fill.high { background: linear-gradient(90deg, #22c55e, #4ade80); }
        .task-node-progress-fill.complete { background: linear-gradient(90deg, #22c55e, #10b981); }

        /* Info Grid */
        .task-node-info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 14px;
        }

        .task-node-info-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .task-node-info-label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .task-node-info-value {
            font-size: 12px;
            color: var(--text-primary);
            font-weight: 500;
        }

        .task-node-info-value.overdue {
            color: #ef4444;
        }

        .task-node-info-value.soon {
            color: #f59e0b;
        }

        /* Badge Row */
        .task-node-badges {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .task-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .task-badge.status {
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
        }

        .task-badge.status-todo { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .task-badge.status-ongoing { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .task-badge.status-working { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .task-badge.status-complete { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .task-badge.status-done { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .task-badge.status-urgent { background: rgba(239, 68, 68, 0.2); color: #f87171; }
        .task-badge.status-review { background: rgba(6, 182, 212, 0.15); color: #22d3ee; }

        .task-badge.priority-low { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .task-badge.priority-medium { background: rgba(245, 158, 11, 0.15); color: #fbbf24; }
        .task-badge.priority-high { background: rgba(239, 68, 68, 0.15); color: #f87171; }
        .task-badge.priority-critical {
            background: rgba(220, 38, 38, 0.2);
            color: #fca5a5;
            animation: criticalBadgePulse 1.5s ease-in-out infinite;
        }

        @keyframes criticalBadgePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Linked Node Indicator */
        .task-node-links {
            padding: 10px 16px;
            border-top: 1px solid rgba(255,255,255,0.08);
            background: rgba(0,0,0,0.15);
        }

        .task-node-link-label {
            font-size: 10px;
            color: var(--text-tertiary);
            margin-bottom: 4px;
        }

        .task-node-link-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: var(--accent-primary);
        }

        /* Connection Points for Task Node - Same as regular nodes */
        .task-node-card .conn-point {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #e94560;
            border: 3px solid #fff;
            border-radius: 50%;
            cursor: crosshair;
            z-index: 20;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform 0.15s;
        }

        .task-node-card .conn-point:hover {
            transform: scale(1.3);
        }

        .task-node-card .conn-point.top { top: -8px; left: 50%; margin-left: -8px; }
        .task-node-card .conn-point.bottom { bottom: -8px; left: 50%; margin-left: -8px; }
        .task-node-card .conn-point.left { left: -8px; top: 50%; margin-top: -8px; }
        .task-node-card .conn-point.right { right: -8px; top: 50%; margin-top: -8px; }

        /* OLD Task Node Styles - Keep for compatibility */
        .node.task-node {
            border: 2px solid transparent;
            border-radius: 16px;
        }
        .node.task-node.status-complete { border-color: #22c55e; }
        .node.task-node.status-urgent { border-color: #ef4444; animation: urgentPulse 2s ease-in-out infinite; }
        .node.task-node.status-working { border-color: #f59e0b; }

        @keyframes urgentPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(239, 68, 68, 0.5); }
            50% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.8); }
        }

        /* Task Progress Bar in Node */
        .task-node-progress {
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        .task-node-progress-fill-old {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Task Node Meta Info */
        .task-node-meta {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 8px;
            font-size: 10px;
        }
        .task-node-badge-old {
            padding: 2px 6px;
            border-radius: 8px;
            background: rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.9);
        }
        .task-node-badge-old.urgent { background: #ef4444; }
        .task-node-badge-old.complete { background: #22c55e; }
        .task-node-badge-old.working { background: #f59e0b; }

        /* ============ FOLDER NODE STYLES ============ */
        .folder-node {
            width: 180px;
            background: linear-gradient(145deg, #1e293b 0%, #0f172a 100%);
            border-radius: 12px;
            border: 2px solid #334155;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .folder-node:hover {
            border-color: #60a5fa;
            box-shadow: 0 8px 24px rgba(96, 165, 250, 0.2);
        }

        .folder-node.selected {
            box-shadow: 0 0 0 3px #60a5fa, 0 0 20px rgba(96, 165, 250, 0.4);
        }

        .folder-node-header {
            padding: 10px 12px;
            background: var(--folder-color, linear-gradient(135deg, #3b82f6, #1d4ed8));
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
        }

        .folder-node-icon {
            font-size: 20px;
        }

        .folder-node-title {
            font-weight: 600;
            font-size: 12px;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .folder-node-count {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: 600;
        }

        .folder-node-body {
            padding: 8px 10px;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .folder-info-icon {
            font-size: 12px;
            opacity: 0.7;
        }

        .folder-info-text {
            font-weight: 500;
        }

        .folder-node-files {
            display: none;
        }

        .folder-file-item {
            display: none;
        }

        .folder-file-icon {
            display: none;
        }

        .folder-file-name {
            font-size: 10px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .folder-file-preview {
            width: 100%;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .folder-node-meta {
            padding: 10px 12px;
            background: rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--text-tertiary);
            border-top: 1px solid rgba(255,255,255,0.05);
        }

        .folder-node-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-tertiary);
            font-size: 12px;
        }

        .folder-node-empty-icon {
            font-size: 32px;
            opacity: 0.5;
            margin-bottom: 8px;
        }

        /* ============ STICKY NOTE NODE STYLES ============ */
        .sticky-node {
            width: 200px;
            min-height: 120px;
            border-radius: 4px;
            box-shadow: 4px 4px 12px rgba(0,0,0,0.3), 0 0 0 1px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: all 0.2s ease;
            transform: rotate(-1deg);
        }

        .sticky-node:nth-child(even) {
            transform: rotate(1deg);
        }

        .sticky-node:hover {
            transform: rotate(0deg) scale(1.02);
            box-shadow: 6px 6px 20px rgba(0,0,0,0.4);
        }

        .sticky-node.selected {
            box-shadow: 0 0 0 3px #e94560, 6px 6px 20px rgba(0,0,0,0.4);
            transform: rotate(0deg) scale(1.02);
        }

        /* Sticky Note Colors */
        .sticky-node.color-yellow {
            background: linear-gradient(145deg, #fef08a 0%, #fde047 100%);
        }
        .sticky-node.color-red {
            background: linear-gradient(145deg, #fca5a5 0%, #f87171 100%);
        }
        .sticky-node.color-green {
            background: linear-gradient(145deg, #86efac 0%, #4ade80 100%);
        }
        .sticky-node.color-blue {
            background: linear-gradient(145deg, #93c5fd 0%, #60a5fa 100%);
        }
        .sticky-node.color-purple {
            background: linear-gradient(145deg, #c4b5fd 0%, #a78bfa 100%);
        }
        .sticky-node.color-orange {
            background: linear-gradient(145deg, #fed7aa 0%, #fb923c 100%);
        }
        .sticky-node.color-pink {
            background: linear-gradient(145deg, #fbcfe8 0%, #f472b6 100%);
        }

        .sticky-node-header {
            padding: 10px 12px 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px dashed rgba(0,0,0,0.1);
        }

        .sticky-node-title {
            font-weight: 700;
            font-size: 13px;
            color: #1f2937;
            flex: 1;
        }

        .sticky-node-pin {
            font-size: 16px;
            opacity: 0.6;
        }

        .sticky-node-body {
            padding: 10px 12px;
        }

        .sticky-node-content {
            font-size: 12px;
            line-height: 1.5;
            color: #374151;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .sticky-node-footer {
            padding: 6px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: rgba(0,0,0,0.4);
        }

        .sticky-node-tag {
            background: rgba(0,0,0,0.1);
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sticky-node-tag.important { background: #dc2626; color: white; }
        .sticky-node-tag.idea { background: #7c3aed; color: white; }
        .sticky-node-tag.todo { background: #2563eb; color: white; }
        .sticky-node-tag.done { background: #16a34a; color: white; }
        .sticky-node-tag.dont-forget { background: #ea580c; color: white; }

        /* ============ IMAGE NODE STYLES ============ */
        .image-node {
            width: 160px;
            background: linear-gradient(145deg, #1e1e2e 0%, #151521 100%);
            border-radius: 10px;
            border: 2px solid #2d2d3d;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            overflow: hidden;
            transition: all 0.2s ease;
        }

        /* Image Node Size Variants */
        .image-node.size-small { width: 120px; }
        .image-node.size-medium { width: 160px; }
        .image-node.size-large { width: 200px; }

        .image-node:hover {
            border-color: #8b5cf6;
            box-shadow: 0 8px 24px rgba(139, 92, 246, 0.2);
        }

        .image-node.selected {
            box-shadow: 0 0 0 3px #8b5cf6, 0 0 20px rgba(139, 92, 246, 0.4);
        }

        .image-node-preview {
            position: relative;
            background: #0a0a0f;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* Size-specific preview heights */
        .image-node.size-small .image-node-preview { height: 80px; }
        .image-node.size-medium .image-node-preview { height: 100px; }
        .image-node.size-large .image-node-preview { height: 130px; }

        .image-node-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .image-node-placeholder {
            text-align: center;
            padding: 20px 10px;
            color: var(--text-tertiary);
            font-size: 11px;
        }

        .image-node-placeholder-icon {
            font-size: 28px;
            opacity: 0.3;
            margin-bottom: 4px;
        }

        .image-node-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 20px 12px 10px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .image-node:hover .image-node-overlay {
            opacity: 1;
        }

        .image-node-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .image-node-action-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .image-node-action-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .image-node-body {
            padding: 8px 10px;
            background: var(--bg-elevated);
        }

        .image-node-title {
            font-weight: 600;
            font-size: 11px;
            color: var(--text-primary);
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .image-node-caption {
            font-size: 10px;
            color: var(--text-tertiary);
            line-height: 1.3;
            max-height: 26px;
            overflow: hidden;
        }

        .image-node-meta {
            padding: 8px 12px;
            background: rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: var(--text-tertiary);
            border-top: 1px solid rgba(255,255,255,0.05);
        }

        /* ============ SPECIAL NODE EDITOR MODAL ============ */
        #specialNodeEditorModal .modal-content {
            max-width: 1100px;
            width: 96%;
            max-height: 90vh;
            background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            box-shadow: 0 30px 100px rgba(0,0,0,0.6);
        }

        #specialNodeEditorModal .modal-header {
            padding: 20px 28px;
            background: linear-gradient(135deg, rgba(99,102,241,0.15), rgba(139,92,246,0.1));
            border-bottom: 1px solid rgba(255,255,255,0.08);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #specialNodeEditorModal .modal-header h3 {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 0;
        }

        #specialNodeEditorModal .modal-close {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            border: none;
            background: rgba(255,255,255,0.1);
            color: var(--text-secondary);
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        #specialNodeEditorModal .modal-close:hover {
            background: #ef4444;
            color: white;
        }

        #specialNodeEditorModal .modal-body {
            padding: 28px;
            overflow-y: auto;
            max-height: calc(90vh - 180px);
        }

        #specialNodeEditorModal .modal-footer {
            padding: 20px 28px;
            background: rgba(0,0,0,0.25);
            border-top: 1px solid rgba(255,255,255,0.08);
            display: flex;
            justify-content: flex-end;
            gap: 14px;
        }

        #specialNodeEditorModal .modal-footer .btn {
            padding: 14px 32px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #specialNodeEditorModal .modal-footer .btn-secondary {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.15);
            color: var(--text-secondary);
        }

        #specialNodeEditorModal .modal-footer .btn-secondary:hover {
            background: rgba(255,255,255,0.15);
            color: #fff;
        }

        #specialNodeEditorModal .modal-footer .btn-primary {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border: none;
            color: white;
            box-shadow: 0 4px 15px rgba(99,102,241,0.4);
        }

        #specialNodeEditorModal .modal-footer .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(99,102,241,0.5);
        }

        #specialNodeEditorModal .form-group {
            margin-bottom: 24px;
        }

        #specialNodeEditorModal .form-group:last-child {
            margin-bottom: 0;
        }

        #specialNodeEditorModal .form-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-tertiary);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #specialNodeEditorModal .form-control {
            width: 100%;
            padding: 14px 16px;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            color: #fff;
            font-size: 15px;
            transition: all 0.2s;
        }

        #specialNodeEditorModal .form-control:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 4px rgba(99,102,241,0.15);
            background: rgba(0,0,0,0.4);
        }

        #specialNodeEditorModal textarea.form-control {
            min-height: 180px;
            resize: vertical;
            font-family: inherit;
            line-height: 1.7;
        }

        /* Editor Grid Layout - Sticky Note (wider) */
        .sticky-editor-layout {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 24px;
            align-items: start;
        }

        .sticky-editor-layout .form-group {
            margin-bottom: 0;
        }

        .sticky-content-section {
            margin-top: 24px;
        }

        .sticky-content-section textarea {
            min-height: 280px;
            font-size: 15px;
            line-height: 1.7;
            resize: vertical;
            padding: 16px;
        }

        /* Sticky Color Picker - Horizontal */
        .sticky-color-grid {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .sticky-color-option {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sticky-color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .sticky-color-option.selected {
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
            transform: scale(1.05);
        }

        .sticky-color-option.selected::after {
            content: '‚úì';
            font-size: 18px;
            color: rgba(0,0,0,0.6);
            font-weight: bold;
        }

        /* Folder Editor Styles - Wide Layout */
        .folder-editor-wide {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .folder-editor-top {
            display: grid;
            grid-template-columns: minmax(250px, 1fr) 180px auto auto;
            gap: 20px;
            align-items: end;
        }

        .folder-editor-top .form-group input,
        .folder-editor-top .form-group select {
            min-width: 100%;
        }

        .folder-color-grid {
            display: flex;
            gap: 8px;
        }

        .folder-color-option {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .folder-color-option:hover {
            transform: scale(1.1);
        }

        .folder-color-option.selected {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.4);
        }

        .folder-editor-stats-inline {
            display: flex;
            gap: 16px;
            padding: 10px 16px;
            background: rgba(59,130,246,0.1);
            border-radius: 10px;
            border: 1px solid rgba(59,130,246,0.2);
        }

        .folder-stat-inline {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .folder-stat-inline .stat-label {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .folder-stat-inline .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: #fff;
        }

        .folder-files-list-wide {
            background: rgba(0,0,0,0.25);
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.06);
            max-height: 300px;
            overflow-y: auto;
        }

        .folder-files-list-wide .folder-list-header {
            display: grid;
            grid-template-columns: 40px 1fr 70px 80px 50px 40px;
            padding: 12px 16px;
            gap: 16px;
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            background: rgba(0,0,0,0.2);
            position: sticky;
            top: 0;
        }

        .folder-files-list-wide .folder-file-row {
            display: grid;
            grid-template-columns: 40px 1fr 70px 80px 50px 40px;
            align-items: center;
            padding: 12px 16px;
            gap: 16px;
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }

        .folder-files-list-wide .folder-file-row:hover {
            background: rgba(255,255,255,0.03);
        }

        .folder-files-list-wide .folder-file-icon {
            font-size: 22px;
        }

        .folder-files-list-wide .folder-file-info {
            min-width: 0;
            overflow: hidden;
        }

        .folder-files-list-wide .folder-file-name {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-primary);
        }

        .folder-files-list-wide .folder-file-type,
        .folder-files-list-wide .folder-file-size {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Folder Files Container */
        .folder-files-container {
            background: rgba(0,0,0,0.25);
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.06);
            max-height: 320px;
            overflow-y: auto;
        }

        /* New Folder Files Table */
        .folder-files-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }

        .folder-files-table thead {
            background: rgba(0,0,0,0.3);
            position: sticky;
            top: 0;
        }

        .folder-files-table th {
            text-align: left;
            padding: 12px 10px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }

        .folder-files-table td {
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            vertical-align: middle;
        }

        .folder-files-table tr:hover td {
            background: rgba(255,255,255,0.03);
        }

        .folder-files-table .file-icon {
            font-size: 20px;
            text-align: center;
        }

        .folder-files-table .file-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 0;
        }

        .folder-files-table .file-type {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .folder-files-table .file-size {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .folder-files-table .file-actions {
            display: flex;
            gap: 6px;
            justify-content: center;
        }

        .file-action-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .file-action-btn.preview-btn {
            background: rgba(99,102,241,0.2);
            color: #a5b4fc;
        }

        .file-action-btn.preview-btn:hover {
            background: #6366f1;
            color: white;
        }

        .file-action-btn.delete-btn {
            background: rgba(239,68,68,0.15);
            color: #f87171;
        }

        .file-action-btn.delete-btn:hover {
            background: #ef4444;
            color: white;
        }

        /* Sticky Note Editor New Layout */
        .sticky-editor-new {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .sticky-editor-top-row {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .sticky-editor-top-row .form-group input {
            width: 100% !important;
            min-width: 250px;
        }

        .sticky-content-full {
            width: 100%;
        }

        .sticky-textarea-large {
            min-height: 250px !important;
            width: 100% !important;
            font-size: 15px !important;
            line-height: 1.7 !important;
            padding: 16px !important;
            resize: vertical;
        }

        /* Image Editor New Layout */
        .image-editor-new {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .image-editor-top {
            display: flex;
            gap: 24px;
            align-items: flex-start;
        }

        .image-editor-new .image-editor-preview {
            width: 220px;
            min-width: 220px;
            background: rgba(0,0,0,0.4);
            border-radius: 16px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 180px;
            border: 2px dashed rgba(255,255,255,0.1);
        }

        .image-editor-new .image-editor-preview.has-image {
            border-style: solid;
            border-color: rgba(139,92,246,0.3);
        }

        .image-editor-new .image-editor-preview img {
            width: 100%;
            max-height: 140px;
            border-radius: 10px;
            object-fit: contain;
            background: rgba(0,0,0,0.3);
        }

        .image-editor-info {
            flex: 1;
            min-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .image-editor-info .form-group input {
            width: 100% !important;
        }

        .image-caption-full {
            width: 100%;
        }

        .image-textarea-large {
            min-height: 180px !important;
            width: 100% !important;
            font-size: 14px !important;
            line-height: 1.6 !important;
            padding: 14px !important;
            resize: vertical;
        }

        .folder-file-preview {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: none;
            background: rgba(99,102,241,0.2);
            color: #a5b4fc;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .folder-file-preview:hover {
            background: #6366f1;
            color: white;
        }

        /* Legacy folder styles */
        .folder-files-list {
            background: rgba(0,0,0,0.25);
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.06);
            max-height: 350px;
            overflow-y: auto;
        }

        .folder-file-row {
            display: grid;
            grid-template-columns: 40px 1fr 70px 80px 36px;
            align-items: center;
            padding: 12px 16px;
            gap: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            transition: background 0.15s;
        }

        .folder-file-row:last-child {
            border-bottom: none;
        }

        .folder-file-row:hover {
            background: rgba(255,255,255,0.04);
        }

        .folder-file-icon {
            font-size: 26px;
            text-align: center;
        }

        .folder-file-info {
            min-width: 0;
        }

        .folder-file-name {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .folder-file-type {
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .folder-file-date {
            font-size: 11px;
            color: var(--text-tertiary);
            text-align: center;
        }

        .folder-file-size {
            font-size: 12px;
            color: var(--text-secondary);
            text-align: right;
            font-weight: 500;
        }

        .folder-file-delete {
            width: 30px;
            height: 30px;
            border-radius: 8px;
            border: none;
            background: rgba(239,68,68,0.15);
            color: #f87171;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.15s;
            opacity: 0;
        }

        .folder-file-row:hover .folder-file-delete {
            opacity: 1;
        }

        .folder-file-delete:hover {
            background: #ef4444;
            color: white;
            transform: scale(1.1);
        }

        /* Folder list header */
        .folder-list-header {
            display: grid;
            grid-template-columns: 40px 1fr 70px 80px 36px;
            padding: 10px 16px;
            gap: 12px;
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            background: rgba(0,0,0,0.2);
        }

        .folder-empty {
            text-align: center;
            padding: 50px 20px;
            color: var(--text-tertiary);
        }

        .folder-empty-icon {
            font-size: 56px;
            opacity: 0.2;
            margin-bottom: 12px;
        }

        .folder-add-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 16px;
            box-shadow: 0 4px 15px rgba(59,130,246,0.3);
        }

        .folder-add-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59,130,246,0.4);
        }

        /* Image Editor Styles - Wider Layout */
        .image-editor-layout {
            display: grid;
            grid-template-columns: 240px 1fr;
            gap: 28px;
            align-items: start;
        }

        .image-editor-fields textarea {
            min-height: 180px;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
        }

        .image-editor-preview {
            background: rgba(0,0,0,0.4);
            border-radius: 16px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            border: 2px dashed rgba(255,255,255,0.1);
        }

        .image-editor-preview.has-image {
            border-style: solid;
            border-color: rgba(139,92,246,0.3);
        }

        .image-editor-preview img {
            width: 100%;
            max-height: 160px;
            border-radius: 10px;
            object-fit: contain;
            background: rgba(0,0,0,0.3);
        }

        .image-editor-placeholder {
            text-align: center;
            color: var(--text-tertiary);
        }

        .image-editor-placeholder-icon {
            font-size: 48px;
            opacity: 0.2;
            margin-bottom: 10px;
        }

        .image-change-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 14px;
            box-shadow: 0 4px 15px rgba(139,92,246,0.3);
        }

        .image-change-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139,92,246,0.4);
        }

        .image-editor-fields {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .image-editor-fields .form-group {
            margin-bottom: 0;
        }

        .image-editor-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .image-size-selector {
            display: flex;
            gap: 8px;
        }

        .image-size-btn {
            flex: 1;
            padding: 12px 8px;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.08);
            border-radius: 10px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .image-size-btn:hover {
            border-color: rgba(139,92,246,0.4);
            color: #fff;
        }

        .image-size-btn.selected {
            background: rgba(139,92,246,0.2);
            border-color: #8b5cf6;
            color: #fff;
        }

        .image-size-btn small {
            display: block;
            font-size: 10px;
            color: var(--text-tertiary);
            margin-top: 2px;
        }

        /* Connection Points for New Node Types */
        .folder-node .conn-point,
        .sticky-node .conn-point,
        .image-node .conn-point {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #e94560;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: crosshair;
            z-index: 20;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: transform 0.15s;
            opacity: 0;
        }

        .folder-node:hover .conn-point,
        .sticky-node:hover .conn-point,
        .image-node:hover .conn-point,
        .folder-node.selected .conn-point,
        .sticky-node.selected .conn-point,
        .image-node.selected .conn-point {
            opacity: 1;
        }

        .folder-node .conn-point:hover,
        .sticky-node .conn-point:hover,
        .image-node .conn-point:hover {
            transform: scale(1.3);
        }

        .folder-node .conn-point.top,
        .sticky-node .conn-point.top,
        .image-node .conn-point.top { top: -7px; left: 50%; margin-left: -7px; }

        .folder-node .conn-point.bottom,
        .sticky-node .conn-point.bottom,
        .image-node .conn-point.bottom { bottom: -7px; left: 50%; margin-left: -7px; }

        .folder-node .conn-point.left,
        .sticky-node .conn-point.left,
        .image-node .conn-point.left { left: -7px; top: 50%; margin-top: -7px; }

        .folder-node .conn-point.right,
        .sticky-node .conn-point.right,
        .image-node .conn-point.right { right: -7px; top: 50%; margin-top: -7px; }

        /* Auth Modal Styles - Modern Design */
        .auth-modal-content {
            background: linear-gradient(145deg, #0f0f1a 0%, #1a1a2e 100%);
            border-radius: 24px;
            width: 420px;
            max-width: 95%;
            padding: 48px 40px;
            position: relative;
            box-shadow: 0 25px 100px rgba(0,0,0,0.6), 0 0 0 1px rgba(99, 102, 241, 0.1);
        }

        .auth-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 12px;
            background: rgba(255,255,255,0.05);
            color: #6b7280;
            cursor: pointer;
            font-size: 22px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .auth-close:hover {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            transform: scale(1.1);
        }

        .auth-header {
            text-align: center;
            margin-bottom: 36px;
        }

        .auth-logo {
            width: 72px;
            height: 72px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin: 0 auto 20px;
            box-shadow: 0 10px 40px rgba(99, 102, 241, 0.3);
        }

        .auth-header h2 {
            color: #f3f4f6;
            font-size: 1.75em;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .auth-subtitle {
            color: #6b7280;
            font-size: 0.95em;
        }

        .auth-error {
            display: none;
            padding: 14px 18px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            color: #fca5a5;
            border-radius: 12px;
            margin-bottom: 24px;
            font-size: 0.9em;
            text-align: center;
        }

        .auth-error.show {
            display: block;
            animation: shake 0.5s ease;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .auth-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .auth-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .auth-input-group label {
            color: #9ca3af;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .auth-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .auth-input-icon {
            position: absolute;
            left: 16px;
            font-size: 18px;
            opacity: 0.5;
        }

        .auth-input-wrapper input {
            width: 100%;
            padding: 16px 16px 16px 50px;
            background: rgba(255,255,255,0.03);
            border: 2px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            color: #f3f4f6;
            font-size: 1em;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .auth-input-wrapper input:focus {
            outline: none;
            border-color: #6366f1;
            background: rgba(99, 102, 241, 0.05);
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.15);
        }

        .auth-input-wrapper input::placeholder {
            color: #4b5563;
        }

        .auth-btn-primary {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 18px 32px;
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border: none;
            border-radius: 14px;
            color: white;
            font-size: 1.05em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-top: 12px;
        }

        .auth-btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(99, 102, 241, 0.4);
        }

        .auth-btn-arrow {
            transition: transform 0.3s;
        }

        .auth-btn-primary:hover .auth-btn-arrow {
            transform: translateX(5px);
        }

        .auth-divider {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .auth-divider::before,
        .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.08);
        }

        .auth-divider span {
            padding: 0 16px;
            color: #666;
            font-size: 0.85em;
        }

        .auth-switch {
            text-align: center;
            color: #6b7280;
            font-size: 0.9em;
        }

        .auth-switch a {
            color: #818cf8;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s;
        }

        .auth-switch a:hover {
            color: #a5b4fc;
            text-decoration: underline;
        }

        /* Projects Modal Styles - Hidden since using side panel */
        .projects-modal-content {
            display: none;
        }

        .projects-header {
            padding: 25px 30px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .projects-header h2 {
            color: #fff;
            font-size: 1.4em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .projects-toolbar {
            padding: 20px 30px;
            display: flex;
            gap: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .projects-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
        }

        .projects-btn-new {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
        }

        .projects-btn-new:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(76,175,80,0.4);
        }

        .projects-btn-refresh {
            background: rgba(255,255,255,0.1);
            color: #aaa;
        }

        .projects-btn-refresh:hover {
            background: rgba(255,255,255,0.15);
            color: #fff;
        }

        .projects-list {
            flex: 1;
            overflow-y: auto;
            padding: 20px 30px;
        }

        .projects-empty {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .projects-empty-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        /* ============ PROJECT CARDS - PROFESSIONAL DESIGN ============ */
        .project-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.04) 0%, rgba(255,255,255,0.02) 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 20px 24px;
            margin-bottom: 14px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .project-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #e94560 0%, #ff6b8a 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .project-card:hover {
            background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.04) 100%);
            border-color: rgba(233,69,96,0.4);
            transform: translateX(6px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .project-card:hover::before {
            opacity: 1;
        }

        .project-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .project-info {
            flex: 1;
        }

        .project-info h3 {
            color: #fff;
            font-size: 1.15em;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .project-info h3 .project-icon {
            font-size: 1.2em;
        }

        .project-description {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 12px;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .project-meta {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px 20px;
            font-size: 0.8em;
            color: #999;
            padding: 12px 0;
            border-top: 1px solid rgba(255,255,255,0.08);
            border-bottom: 1px solid rgba(255,255,255,0.08);
        }

        .project-meta-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .project-meta-item .meta-icon {
            width: 28px;
            height: 28px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9em;
        }

        .project-meta-item .meta-content {
            display: flex;
            flex-direction: column;
        }

        .project-meta-item .meta-label {
            font-size: 0.75em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .project-meta-item .meta-value {
            color: #bbb;
            font-weight: 500;
        }

        .project-actions {
            display: flex;
            gap: 10px;
            margin-top: 4px;
        }

        .project-btn-open {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(135deg, #e94560 0%, #ff6b8a 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .project-btn-open:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(233,69,96,0.4);
        }

        .project-btn-secondary {
            padding: 12px 16px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .project-btn-secondary:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
            color: #fff;
        }

        .project-btn-delete {
            padding: 12px 16px;
            background: rgba(244,67,54,0.1);
            border: 1px solid rgba(244,67,54,0.2);
            border-radius: 10px;
            color: #f44336;
            cursor: pointer;
            transition: all 0.3s;
        }

        .project-btn-delete:hover {
            background: #f44336;
            border-color: #f44336;
            color: white;
        }

        .project-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .project-tag {
            padding: 4px 10px;
            background: rgba(233,69,96,0.15);
            border-radius: 12px;
            font-size: 0.7em;
            color: #e94560;
            font-weight: 500;
        }

        /* Full Text Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        /* ============ MODERN EDITOR MODAL ============ */
        .modal-content {
            background: var(--bg-primary);
            border-radius: 16px;
            width: 98%;
            max-width: 1920px;
            max-height: 96vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            color: var(--text-primary);
            box-shadow: 0 25px 80px rgba(0,0,0,0.5);
            border: 1px solid var(--border-subtle);
        }

        .modal-header {
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
        }

        .modal-header h2 {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-header .close-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 10px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .modal-header .close-btn:hover {
            background: var(--danger);
            color: white;
        }

        .modal-body {
            flex: 1;
            display: flex;
            overflow: hidden;
            background: var(--bg-primary);
            min-width: 0;
        }

        /* ============ SETTINGS MODAL - PRO DESIGN ============ */
        .settings-modal-content {
            max-width: 560px !important;
            width: 95%;
            padding: 0;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .settings-modal-content .modal-header {
            padding: 14px 20px;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border-bottom: 1px solid var(--border-subtle);
        }

        .settings-body {
            padding: 16px 20px;
            background: var(--bg-primary);
        }

        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .settings-column {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .settings-section-title {
            margin: 0 0 2px 0;
            padding: 0;
            font-size: 11px;
            font-weight: 700;
            color: var(--accent-primary);
            text-transform: uppercase;
            letter-spacing: 1px;
            border: none;
        }

        .settings-group {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 12px;
            border: 1px solid var(--border-subtle);
        }

        .settings-group label {
            display: block;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .settings-group select {
            width: 100%;
            padding: 12px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-group select:hover {
            border-color: var(--accent-primary);
        }

        .settings-group select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(124, 138, 255, 0.2);
        }

        .settings-checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-subtle);
            transition: all 0.2s;
        }

        .settings-checkbox-label:hover {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
        }

        .settings-checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--accent-primary);
            cursor: pointer;
        }

        .settings-checkbox-label span {
            font-size: 12px;
            font-weight: 500;
        }

        .settings-btn {
            padding: 10px 16px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            width: 100%;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .settings-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(124, 138, 255, 0.3);
        }

        .settings-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            padding: 14px 20px;
            margin-top: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-subtle);
        }

        .settings-footer .btn-secondary {
            padding: 12px 24px;
            border: 1px solid var(--border-default);
            border-radius: 10px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-footer .btn-secondary:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .settings-footer .btn-primary {
            padding: 12px 28px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .settings-footer .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(124, 138, 255, 0.3);
        }

        .editor-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-subtle);
            background: var(--bg-primary);
            min-width: 0;
            overflow: hidden;
        }

        /* Modern Editor Toolbar */
        .editor-toolbar {
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .editor-toolbar label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .editor-toolbar select,
        .editor-toolbar input {
            padding: 8px 12px;
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            font-size: 13px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transition: all 0.15s ease;
        }

        .editor-toolbar select:focus,
        .editor-toolbar input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }

        /* Modern Format Toolbar */
        .format-toolbar {
            display: flex;
            gap: 4px;
            padding: 10px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-subtle);
            flex-wrap: wrap;
            align-items: center;
        }

        .format-btn {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-subtle) !important;
            border-radius: 8px;
            background: var(--bg-tertiary) !important;
            color: var(--text-secondary) !important;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .format-btn:hover {
            background: var(--bg-hover) !important;
            color: var(--text-primary) !important;
            border-color: var(--accent-primary) !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .format-btn.active,
        .format-btn.format-active {
            background: var(--accent-primary) !important;
            color: white !important;
            border-color: var(--accent-primary) !important;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4), 0 2px 8px rgba(99, 102, 241, 0.3);
            transform: scale(1.05);
        }

        /* Highlight marker buttons - normal state */
        .format-btn.highlight-btn {
            border: 2px solid rgba(0,0,0,0.2) !important;
        }

        .format-btn.highlight-yellow {
            background: #ffeb3b !important;
            color: #333 !important;
        }
        .format-btn.highlight-green {
            background: #a5d6a7 !important;
            color: #333 !important;
        }
        .format-btn.highlight-blue {
            background: #90caf9 !important;
            color: #333 !important;
        }

        /* Marker buttons hover */
        .format-btn.highlight-yellow:hover {
            background: #fdd835 !important;
            box-shadow: 0 2px 8px rgba(255,235,59,0.5);
        }
        .format-btn.highlight-green:hover {
            background: #81c784 !important;
            box-shadow: 0 2px 8px rgba(165,214,167,0.5);
        }
        .format-btn.highlight-blue:hover {
            background: #64b5f6 !important;
            box-shadow: 0 2px 8px rgba(144,202,249,0.5);
        }

        /* Marker buttons active state */
        .format-btn.highlight-yellow.format-active {
            background: #ffeb3b !important;
            box-shadow: 0 0 0 3px #333, 0 0 0 5px #ffeb3b !important;
            transform: scale(1.1);
        }
        .format-btn.highlight-green.format-active {
            background: #a5d6a7 !important;
            box-shadow: 0 0 0 3px #333, 0 0 0 5px #a5d6a7 !important;
            transform: scale(1.1);
        }
        .format-btn.highlight-blue.format-active {
            background: #90caf9 !important;
            box-shadow: 0 0 0 3px #333, 0 0 0 5px #90caf9 !important;
            transform: scale(1.1);
        }

        /* Comment button */
        .format-btn.comment-btn {
            background: #fff3cd !important;
            color: #856404 !important;
            border-color: #ffc107 !important;
        }
        .format-btn.comment-btn:hover {
            background: #ffe69c !important;
            box-shadow: 0 2px 8px rgba(255,193,7,0.4);
        }

        /* Image Editor Styles */
        .editor-image-wrapper {
            position: relative;
            margin: 15px 0;
            padding: 5px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .editor-image-wrapper:hover {
            background: rgba(99, 102, 241, 0.1);
        }
        .editor-image-wrapper.selected {
            background: rgba(99, 102, 241, 0.15);
            outline: 2px solid var(--accent-primary);
        }
        .editor-image {
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            display: block;
        }
        .editor-image:hover {
            opacity: 0.9;
        }
        .image-toolbar {
            position: absolute;
            top: -55px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: 10px;
            padding: 8px 12px;
            display: flex;
            gap: 6px;
            align-items: center;
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            flex-wrap: nowrap;
        }
        .image-toolbar .img-size-group,
        .image-toolbar .img-align-group {
            display: flex;
            gap: 3px;
        }
        .image-toolbar .img-custom-size {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .image-toolbar .img-custom-size input {
            width: 55px;
            height: 28px;
            border: 1px solid var(--border-subtle);
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 11px;
            padding: 0 6px;
            text-align: center;
        }
        .image-toolbar .img-custom-size input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }
        .image-toolbar .img-custom-size span {
            color: var(--text-tertiary);
            font-size: 12px;
        }
        .image-toolbar button {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-subtle);
            border-radius: 5px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .image-toolbar button:hover {
            background: var(--accent-primary);
            color: white;
            border-color: var(--accent-primary);
        }
        .image-toolbar button.danger:hover {
            background: var(--danger);
            border-color: var(--danger);
        }
        .image-toolbar .toolbar-sep {
            width: 1px;
            height: 20px;
            background: var(--border-subtle);
            margin: 0 2px;
        }

        .format-btn-italic {
            font-style: italic;
        }

        .format-btn-underline {
            text-decoration: underline;
        }

        .format-separator {
            width: 1px;
            height: 24px;
            background: var(--border-subtle);
            margin: 0 8px;
        }

        .find-replace-bar {
            display: none;
            padding: 8px 15px;
            background: #4a4a2e;
            border-bottom: 1px solid #666;
            gap: 8px;
            align-items: center;
        }

        .find-replace-bar.active {
            display: flex;
        }

        .find-replace-bar input {
            padding: 6px 10px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 0.85em;
            width: 150px;
            background: #404040;
            color: #e0e0e0;
        }

        .find-replace-bar button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .find-replace-bar .find-btn {
            background: #2196F3;
            color: white;
        }

        .find-replace-bar .replace-btn {
            background: #4CAF50;
            color: white;
        }

        .find-replace-bar .replace-all-btn {
            background: #FF9800;
            color: white;
        }

        .find-replace-bar .close-find {
            background: #555;
            color: #ccc;
        }

        .find-replace-bar .nav-btn {
            background: #666;
            color: white;
            padding: 6px 10px;
        }

        .find-replace-bar .nav-btn:hover {
            background: #777;
        }

        .find-replace-bar .nav-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
        }

        /* Find Options */
        .find-options {
            display: flex;
            gap: 4px;
            margin-left: 8px;
            padding-left: 8px;
            border-left: 1px solid #555;
        }

        .find-option {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 4px 8px;
            background: #404040;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: bold;
            color: #888;
            transition: all 0.2s;
        }

        .find-option:hover {
            background: #505050;
            color: #aaa;
        }

        .find-option input {
            display: none;
        }

        .find-option input:checked + span {
            color: #e94560;
        }

        .find-option:has(input:checked) {
            background: #4a3040;
            border-color: #e94560;
        }

        /* Find Results Panel */
        .find-results-panel {
            display: none;
            background: #353535;
            border-bottom: 1px solid #444;
            max-height: 150px;
            overflow-y: auto;
            padding: 8px 15px;
        }

        .find-results-panel.active {
            display: block;
        }

        .find-results-header {
            font-size: 0.8em;
            color: #aaa;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .find-result-item {
            padding: 6px 10px;
            background: #404040;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            font-size: 0.85em;
            color: #e0e0e0;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .find-result-item:hover {
            background: #505050;
        }

        .find-result-item.current {
            background: #e94560;
            color: white;
        }

        .find-result-item .result-num {
            background: #555;
            color: #aaa;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.75em;
            min-width: 24px;
            text-align: center;
        }

        .find-result-item.current .result-num {
            background: rgba(255,255,255,0.2);
            color: white;
        }

        .find-result-item .result-context {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .find-result-item .result-context mark {
            background: #ffeb3b;
            color: #333;
            padding: 0 2px;
            border-radius: 2px;
        }

        .find-result-item.current .result-context mark {
            background: #fff;
            color: #e94560;
        }

        /* Font & Paragraph Toolbar */
        .font-para-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 15px;
            background: #353535;
            border-bottom: 1px solid #444;
            align-items: center;
            flex-wrap: wrap;
        }

        .font-para-toolbar select {
            padding: 4px 8px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 0.8em;
            background: #404040;
            color: #e0e0e0;
        }

        .font-para-toolbar label {
            font-size: 0.7em;
            color: #aaa;
            margin-right: 2px;
        }

        .para-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #404040;
            color: #e0e0e0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .para-btn:hover {
            background: #505050;
        }

        .para-btn.active {
            background: #e94560;
            color: white;
            border-color: #e94560;
        }

        .font-size-btn {
            width: 26px;
            height: 26px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #404040;
            color: #e0e0e0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.15s;
        }

        .font-size-btn:hover {
            background: #505050;
            border-color: #666;
        }

        .font-size-btn:active {
            transform: scale(0.95);
            background: #e94560;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 8px;
            border-right: 1px solid #555;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        /* Comments Panel */
        .comments-panel {
            display: none;
            padding: 8px 15px;
            background: #4a4a2e;
            border-bottom: 1px solid #666;
            max-height: 150px;
            overflow-y: auto;
        }

        .comments-panel.active {
            display: block;
        }

        .comments-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.8em;
            font-weight: bold;
            color: #666;
        }

        .comment-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 6px 8px;
            background: white;
            border-radius: 4px;
            margin-bottom: 4px;
            font-size: 0.8em;
        }

        .comment-item-text {
            flex: 1;
            color: #333;
        }

        .comment-item-text strong {
            color: #e94560;
        }

        .comment-item-actions {
            display: flex;
            gap: 4px;
        }

        .comment-item-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.9em;
            opacity: 0.6;
        }

        .comment-item-actions button:hover {
            opacity: 1;
        }

        /* Current Revision Mode Indicator */
        .revision-mode-indicator {
            display: none;
            padding: 4px 12px;
            background: #333;
            color: white;
            font-size: 0.75em;
            text-align: center;
            border-bottom: 2px solid;
        }

        .revision-mode-indicator.active {
            display: block;
        }

        /* Snapshot Modal */
        .snapshot-modal .modal-content {
            max-width: 600px;
        }

        .snapshot-list {
            max-height: 350px;
            overflow-y: auto;
            margin: 10px 0;
        }

        .snapshot-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #404040;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .snapshot-item:hover {
            background: #4a4a4a;
        }

        .snapshot-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
        }

        .snapshot-info {
            flex: 1;
        }

        .snapshot-name {
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 2px;
        }

        .snapshot-meta {
            font-size: 0.75em;
            color: #aaa;
        }

        .snapshot-actions {
            display: flex;
            gap: 4px;
        }

        .snapshot-actions button {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            background: #555;
            transition: all 0.2s;
        }

        .snapshot-restore {
            background: #4CAF50;
            color: white;
        }

        .snapshot-delete {
            background: #f44336;
            color: white;
        }

        .snapshot-actions button:hover {
            transform: scale(1.1);
        }

        .take-snapshot-form {
            display: flex;
            gap: 8px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .take-snapshot-form input {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .take-snapshot-form button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }

        .take-snapshot-form button:hover {
            transform: translateY(-1px);
        }

        .no-snapshots {
            text-align: center;
            color: #888;
            padding: 40px 20px;
        }

        .no-snapshots span {
            font-size: 3em;
            display: block;
            margin-bottom: 10px;
        }

        /* Editor Snapshot Panel (Scrivener style) */
        .editor-snapshot-panel {
            display: none;
            background: #353535;
            border-bottom: 1px solid #444;
            max-height: 200px;
            overflow-y: auto;
        }

        .editor-snapshot-panel.active {
            display: block;
        }

        .editor-snapshot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: #2d2d2d;
            border-bottom: 1px solid #444;
        }

        .editor-snapshot-header h4 {
            margin: 0;
            font-size: 0.85em;
            color: #e0e0e0;
        }

        .editor-snapshot-header button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1em;
            color: #aaa;
        }

        .editor-snapshot-actions {
            display: flex;
            gap: 8px;
            padding: 8px 15px;
            background: #404040;
        }

        .editor-snapshot-actions input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 0.8em;
            background: #353535;
            color: #e0e0e0;
        }

        .editor-snapshot-actions button {
            padding: 6px 12px;
            background: #009688;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
        }

        .editor-snapshot-list {
            padding: 8px 15px;
        }

        .editor-snapshot-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: #404040;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 0.8em;
            border: 1px solid #555;
        }

        .editor-snapshot-item:hover {
            background: #4a4a4a;
            border-color: #666;
        }

        .editor-snapshot-item .snap-info {
            flex: 1;
        }

        .editor-snapshot-item .snap-name {
            font-weight: 500;
            color: #e0e0e0;
        }

        .editor-snapshot-item .snap-date {
            font-size: 0.85em;
            color: #aaa;
        }

        .editor-snapshot-item .snap-actions button {
            width: 26px;
            height: 26px;
            border: none;
            background: #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75em;
        }

        .editor-snapshot-item .snap-restore {
            background: #4CAF50;
            color: white;
        }

        .editor-snapshot-item .snap-delete {
            background: #f44336;
            color: white;
        }

        /* Auto-save indicator */
        .autosave-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8em;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 1500;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s;
        }

        .autosave-indicator.show {
            opacity: 1;
            transform: translateY(0);
        }

        .autosave-indicator.saving {
            background: #FF9800;
        }

        .autosave-indicator.saved {
            background: #4CAF50;
        }

        .autosave-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .find-count {
            font-size: 0.8em;
            color: #666;
            min-width: 60px;
        }

        .text-editor-wrapper {
            flex: 1;
            overflow: auto;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        /* Editor Container */
        #quillEditorContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        /* Main Text Editor */
        #fullTextEditor {
            flex: 1;
            min-height: 400px;
            padding: 30px 40px;
            font-family: 'Georgia', serif;
            font-size: 18px;
            line-height: 1.8;
            color: #e0e0e0;
            background: #1a1a2e;
            border: none;
            outline: none;
            cursor: text;
            overflow-y: auto;
        }

        #fullTextEditor:empty:before {
            content: attr(data-placeholder);
            color: #666;
            font-style: italic;
        }

        #fullTextEditor:focus {
            background: #1a1a2e;
            min-height: 100%;
        }

        .ql-editor.ql-blank::before {
            color: #666;
            font-style: normal;
        }

        .ql-editor:focus {
            outline: none;
        }

        /* Quill toolbar hidden - we use our own */
        .ql-toolbar {
            display: none !important;
        }

        /* Quill selection and cursor colors */
        .ql-editor ::selection {
            background: rgba(99, 102, 241, 0.3);
        }

        /* Light mode overrides */
        .editor-light-theme .ql-container,
        .editor-light-theme .ql-editor {
            background: #ffffff;
            color: #1f2328;
        }

        .editor-light-theme .ql-editor.ql-blank::before {
            color: #999;
        }

        /* Editor Ruler - MS Word Style */
        .editor-ruler {
            height: 26px;
            background: #2d2d3d;
            border-bottom: 1px solid #444;
            position: relative;
            user-select: none;
            display: flex;
            align-items: flex-end;
            margin-top: 8px;
            z-index: 10;
        }

        .ruler-track {
            position: absolute;
            left: 20px;
            right: 20px;
            top: 0;
            bottom: 0;
            background: #3a3a4a;
            border-left: 1px solid #555;
            border-right: 1px solid #555;
        }

        .ruler-numbers {
            position: absolute;
            left: 20px;
            right: 20px;
            top: 0;
            bottom: 0;
            display: flex;
            font-size: 9px;
            color: #888;
            font-family: Arial, sans-serif;
        }

        .ruler-cm {
            width: 96px;
            height: 100%;
            position: relative;
            border-right: 1px solid #555;
            box-sizing: border-box;
        }

        .ruler-cm::before {
            content: attr(data-num);
            position: absolute;
            bottom: 1px;
            left: 3px;
            font-size: 9px;
        }

        .ruler-cm .tick-half {
            position: absolute;
            left: 50%;
            top: 0;
            width: 1px;
            height: 8px;
            background: #888;
        }

        .ruler-cm .tick-quarter {
            position: absolute;
            top: 0;
            width: 1px;
            height: 5px;
            background: #aaa;
        }

        .ruler-markers {
            position: absolute;
            top: 0;
            left: 20px;
            right: 20px;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }

        .ruler-indent-left,
        .ruler-indent-hanging,
        .ruler-indent-right {
            pointer-events: auto;
        }

        .ruler-indent-left {
            position: absolute;
            top: 1px;
            left: 0;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 7px solid #4a90d9;
            cursor: ew-resize;
            z-index: 6;
        }

        .ruler-indent-hanging {
            position: absolute;
            top: 8px;
            left: 0;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 7px solid #4a90d9;
            cursor: ew-resize;
            z-index: 6;
        }

        .ruler-indent-right {
            position: absolute;
            top: 8px;
            right: 0;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 7px solid #4a90d9;
            cursor: ew-resize;
            z-index: 6;
        }

        /* Dark mode ruler */
        body:not(.light-mode) .editor-ruler {
            background: #2d2d3d;
            border-bottom-color: #444;
        }

        body:not(.light-mode) .ruler-track {
            background: #3a3a4a;
            border-color: #555;
        }

        body:not(.light-mode) .ruler-numbers {
            color: #888;
        }

        body:not(.light-mode) .ruler-cm {
            border-color: #555;
        }

        body:not(.light-mode) .ruler-cm .tick-half,
        body:not(.light-mode) .ruler-cm .tick-quarter {
            background: #666;
        }

        body:not(.light-mode) .ruler-indent-left,
        body:not(.light-mode) .ruler-indent-hanging,
        body:not(.light-mode) .ruler-indent-right {
            border-top-color: #5ca0e9;
            border-bottom-color: #5ca0e9;
        }

        /* Resizable Image */
        .text-editor img {
            max-width: 100%;
            height: auto;
            margin: 10px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: outline 0.2s;
        }

        .text-editor img.selected {
            outline: 2px solid #2196F3;
        }

        .text-editor img:hover {
            outline: 2px dashed #888;
        }

        .image-resize-wrapper {
            display: inline-block;
            position: relative;
            margin: 10px 0;
        }

        .image-resize-wrapper img {
            display: block;
            margin: 0;
        }

        .image-resize-wrapper.selected {
            outline: 2px solid #2196F3;
        }

        .image-resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #2196F3;
            border: 1px solid #fff;
            border-radius: 2px;
        }

        .image-resize-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
        .image-resize-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
        .image-resize-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
        .image-resize-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }
        .image-resize-handle.n { top: -5px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .image-resize-handle.s { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .image-resize-handle.e { top: 50%; right: -5px; transform: translateY(-50%); cursor: e-resize; }
        .image-resize-handle.w { top: 50%; left: -5px; transform: translateY(-50%); cursor: w-resize; }

        .image-size-tooltip {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
        }

        /* Editable Table */
        .text-editor table {
            border-collapse: collapse;
            margin: 15px 0;
            min-width: 200px;
        }

        .text-editor table td,
        .text-editor table th {
            border: 1px solid #555;
            padding: 8px 12px;
            text-align: left;
            min-width: 50px;
            position: relative;
        }

        .text-editor table th {
            background: #333;
            font-weight: bold;
        }

        .text-editor table td:hover,
        .text-editor table th:hover {
            background: rgba(33, 150, 243, 0.1);
        }

        .text-editor table td:focus,
        .text-editor table th:focus {
            outline: 2px solid #2196F3;
            outline-offset: -2px;
        }

        /* Table resize handles */
        .table-col-resize {
            position: absolute;
            top: 0;
            right: -3px;
            width: 6px;
            height: 100%;
            cursor: col-resize;
            z-index: 10;
        }

        .table-col-resize:hover {
            background: rgba(33, 150, 243, 0.3);
        }

        .table-row-resize {
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 100%;
            height: 6px;
            cursor: row-resize;
            z-index: 10;
        }

        .table-row-resize:hover {
            background: rgba(33, 150, 243, 0.3);
        }

        /* ============ EDITOR LIGHT THEME ============ */
        /* Only affects the text editor area, not the whole app */

        .editor-light-theme .text-editor,
        .editor-light-theme #fullTextEditor {
            background: #ffffff !important;
            color: #1f2328 !important;
        }

        .editor-light-theme .text-editor[contenteditable] {
            background: #ffffff !important;
        }

        /* Editor light theme - table */
        .editor-light-theme .text-editor table td,
        .editor-light-theme .text-editor table th {
            border-color: #d0d7de !important;
            color: #1f2328 !important;
        }

        .editor-light-theme .text-editor table th {
            background: #f6f8fa !important;
        }

        /* Editor light theme - toolbar */
        .editor-light-theme .font-para-toolbar {
            background: #f6f8fa !important;
            border-bottom-color: #d0d7de !important;
        }

        .editor-light-theme .font-para-toolbar button,
        .editor-light-theme .font-para-toolbar select {
            background: #ffffff !important;
            color: #1f2328 !important;
            border-color: #d0d7de !important;
        }

        .editor-light-theme .font-para-toolbar button:hover {
            background: #f0f1f3 !important;
        }

        .editor-light-theme .font-para-toolbar label {
            color: #57606a !important;
        }

        /* Editor light theme - ruler */
        .editor-light-theme .editor-ruler {
            background: #f6f8fa !important;
            border-bottom-color: #d0d7de !important;
        }

        .editor-light-theme .ruler-numbers {
            color: #57606a !important;
        }

        /* Editor light theme - format toolbar */
        .editor-light-theme .format-toolbar {
            background: #f6f8fa !important;
            border-bottom-color: #d0d7de !important;
        }

        .editor-light-theme .format-btn {
            background: #ffffff !important;
            color: #1f2328 !important;
            border-color: #d0d7de !important;
        }

        .editor-light-theme .format-btn:hover {
            background: #f0f1f3 !important;
        }

        /* Editor light theme - revision toolbar */
        .editor-light-theme .revision-toolbar {
            background: #f6f8fa !important;
        }

        .editor-light-theme .revision-tag {
            background: #e1e4e8 !important;
            color: #1f2328 !important;
        }

        /* Editor light theme - footer */
        .editor-light-theme .editor-footer {
            background: #f6f8fa !important;
            border-top-color: #d0d7de !important;
            color: #57606a !important;
        }

        .editor-light-theme .word-stats {
            color: #57606a !important;
        }

        /* Keep body.light-mode for backwards compatibility */
        body.light-mode .text-editor {
            background: #ffffff !important;
            color: #1f2328 !important;
        }

        body.light-mode .text-editor[contenteditable] {
            background: #ffffff !important;
        }

        /* Light mode table */
        body.light-mode .text-editor table td,
        body.light-mode .text-editor table th {
            border-color: #ccc;
        }

        body.light-mode .text-editor table th {
            background: #f0f0f0;
        }

        /* Light mode editor toolbar */
        body.light-mode .font-para-toolbar {
            background: #f8f9fa !important;
            border-bottom-color: #e1e4e8 !important;
        }

        body.light-mode .font-para-toolbar button,
        body.light-mode .font-para-toolbar select {
            background: #fff !important;
            color: #1f2328 !important;
            border-color: #d0d7de !important;
        }

        body.light-mode .font-para-toolbar button:hover {
            background: #f0f1f3 !important;
        }

        /* Light mode editor ruler */
        body.light-mode .editor-ruler {
            background: #f0f1f3 !important;
            border-bottom-color: #d0d7de !important;
        }

        body.light-mode .ruler-numbers {
            color: #57606a !important;
        }

        /* Light mode format toolbar */
        body.light-mode .format-toolbar {
            background: #f8f9fa !important;
            border-bottom-color: #e1e4e8 !important;
        }

        body.light-mode .format-btn {
            background: #fff !important;
            color: #1f2328 !important;
            border-color: #d0d7de !important;
        }

        body.light-mode .format-btn:hover {
            background: #f0f1f3 !important;
        }

        /* Light mode revision toolbar */
        body.light-mode .revision-toolbar {
            background: #f8f9fa !important;
        }

        body.light-mode .revision-tag {
            background: #e1e4e8 !important;
            color: #1f2328 !important;
        }

        /* Light mode editor footer */
        body.light-mode .editor-footer {
            background: #f8f9fa !important;
            color: #57606a !important;
            border-top-color: #e1e4e8 !important;
        }

        /* Table context menu */
        .table-context-menu {
            position: fixed;
            background: #2a2a3a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 5px 0;
            z-index: 10000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            min-width: 180px;
        }

        .table-context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            color: #ddd;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .table-context-menu-item:hover {
            background: #3a3a4a;
        }

        .table-context-menu-divider {
            border-top: 1px solid #444;
            margin: 5px 0;
        }

        body.light-mode .table-context-menu {
            background: #fff;
            border-color: #ddd;
        }

        body.light-mode .table-context-menu-item {
            color: #333;
        }

        body.light-mode .table-context-menu-item:hover {
            background: #f0f0f0;
        }

        body.light-mode .table-context-menu-divider {
            border-color: #ddd;
        }

        /* Editor content styles for lists */
        .text-editor ul, .text-editor ol {
            margin: 10px 0;
            padding-left: 30px;
        }

        .text-editor ul li {
            list-style-type: disc;
            margin: 5px 0;
        }

        .text-editor ol li {
            list-style-type: decimal;
            margin: 5px 0;
        }

        .text-editor table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }

        .text-editor table td, .text-editor table th {
            border: 1px solid #555;
            padding: 8px 12px;
            text-align: left;
        }

        .text-editor table th {
            background: #333;
            font-weight: bold;
        }

        body.light-mode .text-editor table td,
        body.light-mode .text-editor table th {
            border-color: #ccc;
        }

        body.light-mode .text-editor table th {
            background: #f0f0f0;
        }

        .text-editor img {
            max-width: 100%;
            height: auto;
            margin: 10px 0;
            border-radius: 4px;
        }

        .text-editor img.selected {
            outline: 3px solid #e94560;
        }

        /* Revision Labels */
        .revision-toolbar {
            display: flex;
            gap: 6px;
            padding: 8px 15px;
            background: #353535;
            border-bottom: 1px solid #444;
            align-items: center;
            flex-wrap: wrap;
        }

        .revision-label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 500;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .revision-label:hover {
            transform: scale(1.05);
        }

        .revision-label.active {
            border-color: #333;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .revision-label .remove-label {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(0,0,0,0.2);
            border: none;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .revision-label .remove-label:hover {
            background: rgba(0,0,0,0.4);
        }

        .add-revision-btn {
            padding: 4px 10px;
            border: 2px dashed #666;
            border-radius: 12px;
            background: transparent;
            cursor: pointer;
            font-size: 0.75em;
            color: #aaa;
        }

        .add-revision-btn:hover {
            border-color: #888;
            color: #ccc;
        }

        /* Revision Modal */
        .revision-form {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 10px;
            background: #404040;
            border-radius: 8px;
            margin-top: 10px;
        }

        .revision-form input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #353535;
            color: #e0e0e0;
        }

        .revision-form input[type="color"] {
            width: 40px;
            height: 30px;
            padding: 2px;
            cursor: pointer;
        }

        /* Text Colors for Revisions */
        .text-first-draft { color: #2196F3; }
        .text-second-draft { color: #FF9800; }
        .text-final-draft { color: #4CAF50; }
        .text-needs-review { color: #f44336; }
        .text-approved { color: #9C27B0; }

        .editor-footer {
            padding: 10px 15px;
            background: #2d2d2d;
            border-top: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8em;
            color: #aaa;
        }

        .word-stats {
            display: flex;
            gap: 20px;
            color: #aaa;
        }

        .word-stats strong {
            color: #e94560;
        }

        /* Modern Meta Section (Right Panel) */
        .meta-section {
            width: 340px;
            min-width: 320px;
            padding: 20px;
            overflow-y: auto;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-subtle);
        }

        .meta-group {
            margin-bottom: 20px;
        }

        .meta-group label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-tertiary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .meta-group input,
        .meta-group select,
        .meta-group textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            font-size: 13px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            transition: all 0.15s ease;
        }

        .meta-group input:focus,
        .meta-group select:focus,
        .meta-group textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }

        .meta-group textarea {
            min-height: 80px;
            resize: vertical;
            line-height: 1.5;
        }

        .desc-list {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .desc-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-primary);
            color: #e0e0e0;
        }

        .desc-item button {
            margin-left: auto;
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            background: #555;
            color: #ccc;
            cursor: pointer;
            font-size: 10px;
        }

        .desc-item button:hover {
            background: #e94560;
            color: white;
        }

        .add-desc-form {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }

        .add-desc-form select {
            width: 100px;
        }

        .add-desc-form input {
            flex: 1;
        }

        .add-desc-form button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }

        .modal-actions {
            padding: 15px 20px;
            background: #252525;
            border-top: 1px solid #444;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-actions button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .btn-cancel { background: #555; color: #e0e0e0; }
        .btn-cancel:hover { background: #666; }
        .btn-save { background: #e94560; color: white; }
        .btn-save:hover { background: #d13652; }

        /* ============ PRO MODAL STYLES ============ */

        /* Manager Modal - Professional Design */
        .manager-modal .modal-content {
            max-width: 420px;
            padding: 0;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .manager-modal .modal-header {
            padding: 20px 24px;
            margin-bottom: 0;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border-bottom: 1px solid var(--border-subtle);
        }

        .manager-modal .modal-header h2,
        .manager-modal .modal-header h3 {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .manager-modal .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
        }

        .manager-modal .modal-close:hover {
            background: var(--danger);
            color: white;
            transform: scale(1.05);
        }

        .manager-modal .modal-body {
            padding: 20px 24px;
            background: var(--bg-primary);
        }

        .manager-list {
            max-height: 280px;
            overflow-y: auto;
            margin: 0 0 16px 0;
            padding-right: 4px;
        }

        .manager-list::-webkit-scrollbar {
            width: 6px;
        }

        .manager-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.15);
            border-radius: 3px;
        }

        .manager-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            background: var(--bg-secondary);
            border-radius: 10px;
            margin-bottom: 8px;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        .manager-item:hover {
            border-color: var(--border-default);
            transform: translateX(4px);
        }

        .manager-item .color-preview {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .manager-item .item-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .manager-item .item-info {
            flex: 1;
            min-width: 0;
        }

        .manager-item .item-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .manager-item .item-desc {
            font-size: 12px;
            color: var(--text-tertiary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .manager-item .item-actions {
            display: flex;
            gap: 6px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .manager-item:hover .item-actions {
            opacity: 1;
        }

        .manager-item .item-actions button {
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.08);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .manager-item .item-actions button:hover {
            background: var(--accent-primary);
            color: white;
            transform: scale(1.1);
        }

        .manager-item .item-actions button.delete-btn:hover {
            background: var(--danger);
        }

        .manager-item .item-actions button.restore-btn:hover {
            background: var(--success);
        }

        /* Empty State - Professional */
        .trash-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 48px 24px;
            text-align: center;
        }

        .trash-empty-state .empty-icon {
            font-size: 56px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .trash-empty-state .empty-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .trash-empty-state .empty-desc {
            font-size: 13px;
            color: var(--text-tertiary);
        }

        /* Pro Modal Footer */
        .modal-footer-pro {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            padding: 16px 24px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-subtle);
        }

        .btn-primary-pro {
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary-pro:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(124, 138, 255, 0.3);
        }

        .btn-danger-outline {
            padding: 10px 20px;
            border: 1px solid var(--danger);
            border-radius: 8px;
            background: transparent;
            color: var(--danger);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-danger-outline:hover {
            background: var(--danger);
            color: white;
        }

        /* Manager Form - Professional */
        .manager-form {
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-subtle);
        }

        .manager-form h3,
        .manager-form-title {
            font-size: 13px;
            margin-bottom: 14px;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-row {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .form-row .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            font-size: 0.8em;
            color: #aaa;
            margin-bottom: 4px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #555;
            border-radius: 4px;
            background: #404040;
            color: #e0e0e0;
        }

        .form-group input[type="color"] {
            width: 50px;
            height: 36px;
            padding: 2px;
            cursor: pointer;
        }

        /* Zoom Controls - fixed position but aware of properties panel */
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 100;
            background: rgba(0,0,0,0.85);
            padding: 8px;
            border-radius: 8px;
            transition: right 0.3s ease;
        }

        /* Move zoom controls left when properties panel is open */
        .properties-panel.active ~ .zoom-controls,
        body:has(.properties-panel.active) .zoom-controls {
            right: 340px;
        }

        .zoom-controls button {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 4px;
            background: #444;
            color: white;
            cursor: pointer;
            font-size: 1.1em;
        }

        .zoom-controls button:hover {
            background: #e94560;
        }

        .zoom-controls span {
            padding: 8px 12px;
            color: white;
            font-size: 0.85em;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .toast.show { opacity: 1; }

        /* Context Menu */
        /* Modern Context Menu - Notion/Linear Style */
        .context-menu {
            display: none;
            position: fixed;
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 6px;
            z-index: 3000;
            min-width: 220px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.4), 0 0 0 1px var(--border-default);
            animation: menuSlideIn 0.15s ease;
        }

        @keyframes menuSlideIn {
            from { opacity: 0; transform: translateY(-8px) scale(0.96); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .context-menu.active { display: block; }

        .context-menu-header {
            padding: 10px 12px 8px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .context-menu-item {
            padding: 10px 12px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-primary);
            transition: all 0.12s;
            border-radius: 8px;
            margin: 2px 0;
        }

        .context-menu-item:hover {
            background: var(--bg-hover);
        }

        .context-menu-item .item-icon {
            font-size: 15px;
            width: 20px;
            text-align: center;
        }

        .context-menu-item .item-shortcut {
            margin-left: auto;
            font-size: 11px;
            color: var(--text-tertiary);
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .context-menu-item.danger {
            color: var(--danger);
        }

        .context-menu-item.danger:hover {
            background: rgba(248, 113, 113, 0.15);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-subtle);
            margin: 6px 0;
        }

        /* Add Menu Specific Styling */
        #addMenu {
            min-width: 240px;
        }

        #addMenu .context-menu-item {
            position: relative;
        }

        #addMenu .context-menu-item::after {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 0;
            background: var(--accent-primary);
            border-radius: 2px;
            transition: height 0.15s;
        }

        #addMenu .context-menu-item:hover::after {
            height: 60%;
        }

        /* Layout Modal - Compact Dropdown Style */
        .layout-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 5000;
            justify-content: center;
            align-items: flex-start;
            padding-top: 100px;
        }

        .layout-modal.active {
            display: flex;
        }

        .layout-modal-content {
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 12px;
            max-width: 420px;
            width: 90%;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-default);
        }

        .layout-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-subtle);
        }

        .layout-modal-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
        }

        .layout-close-btn {
            background: none;
            border: none;
            color: var(--text-tertiary);
            font-size: 16px;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            border-radius: 4px;
        }

        .layout-close-btn:hover {
            color: var(--danger);
            background: var(--bg-hover);
        }

        .layout-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .layout-option {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: center;
            border: 2px solid transparent;
            pointer-events: auto;
        }

        .layout-option:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
            transform: scale(1.02);
        }
        
        .layout-option:active {
            transform: scale(0.98);
            background: var(--accent-primary);
        }

        .layout-option span {
            display: block;
            margin-top: 6px;
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 500;
            pointer-events: none;
        }

        .layout-preview {
            width: 100%;
            height: 50px;
            background: var(--bg-primary);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            pointer-events: none;
        }

        .lp-node {
            position: absolute;
            width: 18%;
            height: 20%;
            pointer-events: none;
            background: #4fc3f7;
            border-radius: 4px;
        }

        .lp-node.lp-root {
            top: 10%;
            left: 41%;
            background: #ff9800;
        }

        .lp-node.lp-center {
            top: 35%;
            left: 38%;
            width: 24%;
            height: 30%;
            background: #ff9800;
        }

        .lp-node.lp-c1 { top: 60%; left: 10%; }
        .lp-node.lp-c2 { top: 60%; left: 41%; }
        .lp-node.lp-c3 { top: 60%; left: 72%; }

        .lp-line {
            position: absolute;
            background: #4fc3f7;
        }

        .lp-line.lp-v1 {
            width: 2px;
            height: 25%;
            top: 30%;
            left: 50%;
        }

        .lp-line.lp-h1 {
            width: 62%;
            height: 2px;
            top: 55%;
            left: 19%;
        }

        .lp-hline {
            position: absolute;
            width: 85%;
            height: 2px;
            background: #4fc3f7;
            top: 50%;
            left: 7.5%;
        }

        .lp-vline {
            position: absolute;
            width: 2px;
            height: 85%;
            background: #4fc3f7;
            top: 7.5%;
            left: 50%;
        }

        .lp-circle {
            position: absolute;
            width: 60%;
            height: 70%;
            border: 2px solid #4fc3f7;
            border-radius: 50%;
            top: 15%;
            left: 20%;
        }

        .lp-timeline {
            position: absolute;
            width: 85%;
            height: 2px;
            background: #e94560;
            top: 50%;
            left: 7.5%;
        }

        .lp-mline1, .lp-mline2 {
            position: absolute;
            width: 30%;
            height: 2px;
            background: #4fc3f7;
            top: 50%;
        }

        .lp-mline1 { left: 55%; }
        .lp-mline2 { left: 15%; }

        /* Light mode layout modal */
        body.light-mode .layout-modal-content {
            background: #fff;
            border-color: #ddd;
        }

        body.light-mode .layout-modal-header {
            border-color: #eee;
        }

        body.light-mode .layout-modal-header h3 {
            color: #333;
        }

        body.light-mode .layout-option {
            background: #f5f5f5;
        }

        body.light-mode .layout-option:hover {
            background: #e8e8e8;
        }

        body.light-mode .layout-option span {
            color: #555;
        }

        body.light-mode .layout-preview {
            background: #e0e0e0;
        }

        @media (max-width: 600px) {
            .layout-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* ============ COMPILE MODAL - DARK THEME ============ */
        #compileModal .modal-content {
            background: #1a1a2e !important;
            color: #e0e0e0 !important;
            border: 1px solid #2d2d4a;
        }

        #compileModal .modal-header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%) !important;
            border-bottom: 2px solid #e94560 !important;
        }

        #compileModal .modal-header h2 {
            color: #fff !important;
        }

        #compileModal .meta-group label {
            color: #b0b0b0 !important;
        }

        #compileModal select,
        #compileModal input[type="text"] {
            background: #2d2d3d !important;
            border: 1px solid #444 !important;
            color: #fff !important;
            border-radius: 8px;
        }

        #compileModal select:focus,
        #compileModal input[type="text"]:focus {
            border-color: #e94560 !important;
            outline: none;
        }

        /* Compile Format Buttons - Dark */
        .compile-format-btn {
            padding: 8px 12px;
            border: 2px solid #444;
            border-radius: 8px;
            background: #2d2d3d;
            color: #ccc;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s;
        }

        .compile-format-btn:hover {
            border-color: #e94560;
            background: #3a3a4a;
            color: #fff;
        }

        .compile-format-btn.active {
            border-color: #e94560;
            background: linear-gradient(135deg, #e94560 0%, #ff6b8a 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        /* Compile Node List - Dark */
        #compileNodeList {
            background: #2d2d3d !important;
            border-color: #444 !important;
        }

        .compile-node-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: #3a3a4a;
            border-radius: 8px;
            margin-bottom: 6px;
            font-size: 0.9em;
            cursor: pointer;
            border: 1px solid #555;
            color: #e0e0e0;
            transition: all 0.15s;
        }

        .compile-node-item:hover {
            background: #454560;
            border-color: #e94560;
        }

        .compile-node-item input[type="checkbox"] {
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: #e94560;
        }

        /* Compile Layout Options - Dark */
        #compileModal label[style*="background:#f9f9f9"],
        #compileModal label[style*="background: #f9f9f9"] {
            background: #3a3a4a !important;
            color: #e0e0e0 !important;
            border: 1px solid #555;
            border-radius: 8px;
        }

        #compileModal label[style*="background:#f9f9f9"]:hover,
        #compileModal label[style*="background: #f9f9f9"]:hover {
            background: #454560 !important;
            border-color: #e94560 !important;
        }

        /* Compile Preview - Dark */
        #compilePreview {
            background: #2d2d3d !important;
            border-color: #444 !important;
            color: #ccc !important;
        }

        #compilePreview p {
            color: #888 !important;
        }

        /* Compile PDF Note - Dark */
        #compilePdfNote {
            background: rgba(233, 69, 96, 0.15) !important;
            color: #ff8fa3 !important;
            border: 1px solid rgba(233, 69, 96, 0.3);
        }
            flex-shrink: 0;
        }

        .compile-node-item .node-type-badge {
            font-size: 0.7em;
            padding: 3px 8px;
            border-radius: 4px;
            background: #e94560;
            color: white;
            flex-shrink: 0;
        }

        .compile-node-item span:nth-child(2) {
            flex-shrink: 0;
        }

        .compile-node-item span:nth-child(3) {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
            color: #333;
        }

        /* ============ EDITOR TEXT AREA DARK/LIGHT MODE ============ */
        /* ONLY affects the text writing area, nothing else */
        /* These styles MUST override all other theme styles */

        /* Editor dark mode - works in both system themes */
        .editor-dark-mode #fullTextEditor,
        body.light-mode .editor-dark-mode #fullTextEditor,
        body:not(.light-mode) .editor-dark-mode #fullTextEditor {
            background: #1a1a2e !important;
            color: #e0e0e0 !important;
        }

        /* Editor light mode - works in both system themes */
        .editor-light-mode #fullTextEditor,
        body.light-mode .editor-light-mode #fullTextEditor,
        body:not(.light-mode) .editor-light-mode #fullTextEditor {
            background: #ffffff !important;
            color: #1f2328 !important;
        }

        /* Editor dark/light mode ONLY affects text area - other elements stay as they are */

        /* ============ FOCUS MODE - TAM EKRAN ============ */
        .focus-mode-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            background: #1a1a2e !important;
            margin: 0 !important;
            padding: 0 !important;
            border-radius: 0 !important;
        }

        .focus-mode-active .modal-content {
            max-width: 100vw !important;
            width: 100vw !important;
            height: 100vh !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            background: #1a1a2e !important;
            margin: 0 !important;
            padding: 0 !important;
        }

        .focus-mode-active .modal-header {
            display: none !important;
        }

        .focus-mode-active .modal-body {
            display: block !important;
            height: 100vh !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow: hidden !important;
        }

        .focus-mode-active .editor-section {
            max-width: 100vw !important;
            width: 100vw !important;
            height: 100vh !important;
            margin: 0 !important;
            padding: 0 !important;
            background: #1a1a2e !important;
            box-shadow: none !important;
            border-radius: 0 !important;
        }

        .focus-mode-active .editor-toolbar,
        .focus-mode-active .format-toolbar,
        .focus-mode-active .find-replace-bar,
        .focus-mode-active .revision-toolbar,
        .focus-mode-active .revision-mode-indicator,
        .focus-mode-active .font-para-toolbar,
        .focus-mode-active .comments-panel,
        .focus-mode-active .editor-snapshot-panel,
        .focus-mode-active .meta-section,
        .focus-mode-active .editor-sidebar,
        .focus-mode-active .modal-actions {
            display: none !important;
        }

        /* Ruler visible in focus mode - full width, positioned below toolbar */
        .focus-mode-active .editor-ruler {
            display: flex !important;
            position: fixed !important;
            top: 100px !important;
            left: 0 !important;
            right: 0 !important;
            transform: none !important;
            width: 100% !important;
            max-width: 100vw !important;
            z-index: 10000 !important;
            background: rgba(45,45,60,0.95) !important;
            border-radius: 0 !important;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3) !important;
            padding: 0 var(--focus-padding, 10%) !important;
            box-sizing: border-box !important;
        }

        .focus-mode-active.focus-light .editor-ruler {
            background: rgba(255,255,255,0.95) !important;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1) !important;
        }

        .focus-mode-active #fullTextEditor {
            width: 100vw !important;
            height: calc(100vh - 60px) !important;
            max-width: 100vw !important;
            /* Padding controlled by JS focusWidthPercent variable */
            padding: 140px var(--focus-padding, 10%) 80px !important;
            /* font-size controlled by JS zoom - don't override */
            line-height: 2.2 !important;
            min-height: auto !important;
            background: #1a1a2e !important;
            color: #d4d4d4 !important;
            overflow-y: auto !important;
            box-sizing: border-box !important;
        }

        .focus-mode-active .editor-footer {
            position: fixed !important;
            bottom: 20px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            width: auto !important;
            background: rgba(40,40,50,0.95) !important;
            color: #fff !important;
            border-radius: 30px !important;
            padding: 14px 40px !important;
            font-size: 1.1em !important;
            font-weight: 500 !important;
            z-index: 10001 !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4) !important;
            backdrop-filter: blur(10px) !important;
        }

        .focus-mode-active .editor-footer strong {
            color: #e94560 !important;
            font-size: 1.15em !important;
            font-weight: 700 !important;
        }

        /* Focus mode light theme - info bar */
        .focus-mode-active.focus-light .editor-footer {
            background: rgba(255,255,255,0.95) !important;
            color: #333 !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15) !important;
        }

        .focus-mode-active.focus-light .editor-footer strong {
            color: #e94560 !important;
        }

        /* Focus Mode Light Theme */
        .focus-mode-active.focus-light #fullTextEditor {
            background: #fafafa !important;
            color: #333 !important;
        }

        .focus-mode-active.focus-light .modal-content,
        .focus-mode-active.focus-light .editor-section {
            background: #fafafa !important;
        }

        .focus-mode-active.focus-light .editor-footer {
            background: rgba(0,0,0,0.7) !important;
        }

        /* Focus Toolbar Light version */
        .focus-mode-active.focus-light .focus-toolbar {
            background: rgba(0,0,0,0.85) !important;
        }

        /* Focus Mode Dark Theme - works even in body.light-mode */
        .focus-mode-active.focus-dark #fullTextEditor,
        body.light-mode .focus-mode-active.focus-dark #fullTextEditor {
            background: #1a1a2e !important;
            color: #d4d4d4 !important;
        }

        .focus-mode-active.focus-dark .modal-content,
        .focus-mode-active.focus-dark .editor-section,
        body.light-mode .focus-mode-active.focus-dark .modal-content,
        body.light-mode .focus-mode-active.focus-dark .editor-section {
            background: #1a1a2e !important;
        }

        .focus-mode-active.focus-dark,
        body.light-mode .focus-mode-active.focus-dark {
            background: #1a1a2e !important;
        }

        .focus-mode-active.focus-dark .editor-footer,
        body.light-mode .focus-mode-active.focus-dark .editor-footer {
            background: rgba(0,0,0,0.6) !important;
            color: #fff !important;
        }

        /* Focus Mode Light - Find Panel */
        .focus-mode-active.focus-light .focus-find-panel,
        body.light-mode .focus-mode-active.focus-light .focus-find-panel {
            background: #fff !important;
            border-color: #ddd !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15) !important;
        }

        .focus-mode-active.focus-light .focus-find-header,
        body.light-mode .focus-mode-active.focus-light .focus-find-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            border-bottom-color: #ddd !important;
            color: #fff !important;
        }

        .focus-mode-active.focus-light .focus-find-body,
        body.light-mode .focus-mode-active.focus-light .focus-find-body {
            background: #fff !important;
        }

        .focus-mode-active.focus-light .focus-find-row label,
        body.light-mode .focus-mode-active.focus-light .focus-find-row label {
            color: #666 !important;
        }

        .focus-mode-active.focus-light .focus-find-row input[type="text"],
        body.light-mode .focus-mode-active.focus-light .focus-find-row input[type="text"] {
            background: #f5f5f5 !important;
            border-color: #ddd !important;
            color: #333 !important;
        }

        .focus-mode-active.focus-light .focus-find-close,
        body.light-mode .focus-mode-active.focus-light .focus-find-close {
            color: #fff !important;
        }

        .focus-mode-active.focus-light .focus-find-checkbox,
        body.light-mode .focus-mode-active.focus-light .focus-find-checkbox {
            color: #666 !important;
        }

        .focus-mode-active.focus-light .focus-find-count,
        body.light-mode .focus-mode-active.focus-light .focus-find-count {
            color: #e94560 !important;
        }

        .focus-mode-active.focus-light .focus-find-nav button,
        body.light-mode .focus-mode-active.focus-light .focus-find-nav button {
            background: #e0e0e0 !important;
            color: #333 !important;
        }

        .focus-mode-active.focus-light .focus-find-results,
        body.light-mode .focus-mode-active.focus-light .focus-find-results {
            background: #f8f9fa !important;
            border-top-color: #ddd !important;
        }

        .focus-mode-active.focus-light .focus-find-result-item,
        body.light-mode .focus-mode-active.focus-light .focus-find-result-item {
            background: #fff !important;
            color: #333 !important;
            border-bottom-color: #eee !important;
        }

        .focus-mode-active.focus-light .focus-find-result-item:hover,
        body.light-mode .focus-mode-active.focus-light .focus-find-result-item:hover {
            background: #f0f0f0 !important;
        }

        /* Focus Mode Toolbar */
        .focus-toolbar {
            position: fixed;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            background: rgba(0,0,0,0.85);
            padding: 10px 20px;
            border-radius: 30px;
            display: none;
            gap: 12px;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        .focus-mode-active .focus-toolbar {
            display: flex !important;
        }

        .focus-toolbar button {
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .focus-toolbar button:hover {
            background: rgba(255,255,255,0.25);
        }

        .focus-toolbar span {
            color: #e94560;
            font-weight: bold;
            min-width: 45px;
            text-align: center;
        }

        /* Focus Mode Find Panel */
        .focus-find-panel {
            position: fixed;
            top: 80px;
            right: 30px;
            z-index: 10001;
            background: #2a2a3a;
            border-radius: 12px;
            display: none;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            width: 420px;
            overflow: hidden;
        }

        .focus-find-panel.active {
            display: flex !important;
        }

        .focus-find-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #1a1a2e;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #e94560;
            font-weight: bold;
        }

        .focus-find-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.2em;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .focus-find-close:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }

        .focus-find-body {
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .focus-find-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .focus-find-row label {
            width: 60px;
            color: #aaa;
            font-size: 0.9em;
        }

        .focus-find-row input[type="text"] {
            flex: 1;
            background: #1a1a2e;
            border: 1px solid #444;
            color: white;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 0.95em;
        }

        .focus-find-row input[type="text"]:focus {
            outline: none;
            border-color: #e94560;
        }

        .focus-find-btn {
            background: #e94560;
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.2s;
        }

        .focus-find-btn:hover {
            background: #d63850;
        }

        .focus-replace-btn {
            background: #4CAF50 !important;
            flex-shrink: 0;
        }

        .focus-replace-btn:hover {
            background: #43A047 !important;
        }

        .focus-find-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px 0;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }

        .focus-find-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            color: #bbb;
            font-size: 0.9em;
        }

        .focus-find-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #e94560;
        }

        .focus-find-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .focus-nav-btn {
            background: #444;
            border: none;
            color: white;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .focus-nav-btn:hover {
            background: #555;
        }

        .focus-find-count {
            color: #e94560;
            font-weight: bold;
            font-size: 0.95em;
            min-width: 80px;
            text-align: center;
        }

        .focus-find-actions {
            padding-top: 8px;
        }

        .focus-replace-all-btn {
            width: 100%;
            background: #2196F3;
            border: none;
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.2s;
        }

        .focus-replace-all-btn:hover {
            background: #1976D2;
        }

        /* Focus Find Results */
        .focus-find-results {
            display: none;
            margin-top: 12px;
            border-top: 1px solid #444;
            padding-top: 12px;
        }

        .focus-find-results.active {
            display: block;
        }

        .focus-results-header {
            color: #e94560;
            font-weight: bold;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .focus-results-list {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .focus-result-item {
            padding: 8px 12px;
            background: #1a1a2e;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85em;
            color: #ccc;
        }

        .focus-result-item:hover {
            background: #2a2a4a;
        }

        .focus-result-item.current {
            background: #e94560;
            color: white;
        }

        .focus-result-item .result-num {
            background: rgba(255,255,255,0.15);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8em;
            min-width: 24px;
            text-align: center;
        }

        .focus-result-item.current .result-num {
            background: rgba(255,255,255,0.3);
        }

        .focus-result-item .result-context {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .focus-result-item .result-context mark {
            background: #ffeb3b;
            color: #333;
            padding: 0 2px;
            border-radius: 2px;
        }

        .focus-result-item.current .result-context mark {
            background: #fff;
            color: #e94560;
        }

        /* ============ SYSTEM LIGHT MODE ============ */
        body.light-mode {
            background: #f0f2f5 !important;
        }

        body.light-mode .header {
            background: #ffffff !important;
            border-bottom: 1px solid #e1e4e8 !important;
        }

        body.light-mode .header h1 {
            color: #1f2328 !important;
        }

        body.light-mode .stats-bar {
            background: #fafbfc !important;
            border-bottom: 1px solid #e1e4e8 !important;
            color: #57606a !important;
        }

        body.light-mode .stats-bar .stat-value {
            color: #0969da !important;
        }

        body.light-mode .side-panel {
            background: #ffffff !important;
            border-right: 1px solid #e1e4e8 !important;
        }

        body.light-mode .panel-tabs {
            background: #fafbfc !important;
            border-bottom: 1px solid #e1e4e8 !important;
        }

        body.light-mode .panel-tab {
            color: #57606a !important;
        }

        body.light-mode .panel-tab:hover {
            color: #1f2328 !important;
            background: #f0f1f3 !important;
        }

        body.light-mode .panel-tab.active {
            background: #0969da !important;
            color: #fff !important;
        }

        body.light-mode .outline-toolbar {
            background: #fafbfc !important;
            border-bottom: 1px solid #e1e4e8 !important;
        }

        body.light-mode .outline-toolbar button {
            background: #f0f1f3 !important;
            color: #57606a !important;
            border: 1px solid #d0d7de !important;
        }

        body.light-mode .outline-toolbar button:hover {
            background: #e1e4e8 !important;
            color: #1f2328 !important;
        }

        body.light-mode .section-header {
            background: #f8f9fa !important;
            color: #333 !important;
            border-bottom-color: #e0e0e0 !important;
        }

        body.light-mode .node-item {
            background: #f8f9fa !important;
            border-color: #e0e0e0 !important;
            color: #333 !important;
        }

        body.light-mode .node-item:hover {
            background: #e9ecef !important;
        }

        body.light-mode .canvas-area {
            background: #e9ecef !important;
        }

        body.light-mode #canvas {
            background-color: #f5f7fa !important;
            background-image: radial-gradient(circle, #c0c4cc 1px, transparent 1px) !important;
            background-size: 25px 25px !important;
            background-position: 0 0 !important;
        }

        body.light-mode .canvas-container {
            background: #e8eaed !important;
        }

        body.light-mode .modal-content {
            background: #fff !important;
            color: #333 !important;
        }

        body.light-mode .modal-body {
            background: #fff !important;
        }

        body.light-mode .modal-header {
            background: #fafbfc !important;
            border-bottom: 1px solid #e1e4e8 !important;
        }

        body.light-mode .modal-header h2 {
            color: #1f2328 !important;
        }

        body.light-mode .modal-header .close-btn {
            background: #f0f1f3 !important;
            color: #57606a !important;
            border: 1px solid #d0d7de !important;
        }

        body.light-mode .modal-header .close-btn:hover {
            background: #e1e4e8 !important;
            color: #1f2328 !important;
        }

        body.light-mode .editor-section {
            background: #fff !important;
            border-right-color: #ddd !important;
        }

        body.light-mode .editor-toolbar {
            background: #fafafa !important;
            border-bottom-color: #eee !important;
        }

        body.light-mode .editor-toolbar label {
            color: #666 !important;
        }

        body.light-mode .editor-toolbar select,
        body.light-mode .editor-toolbar input {
            background: #fff !important;
            color: #333 !important;
            border-color: #ddd !important;
        }

        body.light-mode .format-toolbar {
            background: #f0f0f0 !important;
            border-bottom-color: #ddd !important;
        }

        body.light-mode .format-btn {
            background: #fff !important;
            color: #333 !important;
            border-color: #ccc !important;
        }

        body.light-mode .format-btn:hover {
            background: #e0e0e0 !important;
        }

        body.light-mode .revision-toolbar {
            background: #f5f5f5 !important;
            border-bottom-color: #ddd !important;
        }

        body.light-mode .font-para-toolbar {
            background: #f8f8f8 !important;
            border-bottom-color: #ddd !important;
        }

        body.light-mode .font-para-toolbar select {
            background: #fff !important;
            color: #333 !important;
            border-color: #ccc !important;
        }

        body.light-mode .font-para-toolbar label {
            color: #666 !important;
        }

        body.light-mode .para-btn {
            background: #fff !important;
            color: #333 !important;
            border-color: #ccc !important;
        }

        body.light-mode .para-btn:hover {
            background: #e0e0e0 !important;
        }

        body.light-mode .toolbar-group {
            border-right-color: #ddd !important;
        }

        body.light-mode .text-editor {
            background: #fff !important;
            color: #333 !important;
        }

        body.light-mode .text-editor[contenteditable] {
            background: #fff !important;
        }

        body.light-mode .editor-footer {
            background: #f5f5f5 !important;
            border-top-color: #ddd !important;
            color: #666 !important;
        }

        body.light-mode .word-stats {
            color: #666 !important;
        }

        body.light-mode .meta-section {
            background: #fafafa !important;
        }

        body.light-mode .desc-item {
            background: #fff !important;
            border-color: #eee !important;
            color: #333 !important;
        }

        body.light-mode .desc-item button {
            background: #eee !important;
            color: #666 !important;
        }

        body.light-mode input,
        body.light-mode select,
        body.light-mode textarea {
            background: #fff !important;
            color: #333 !important;
            border-color: #ddd !important;
        }

        body.light-mode .meta-group label {
            color: #666 !important;
        }

        body.light-mode .comments-panel {
            background: #fffde7 !important;
            border-bottom-color: #ffc107 !important;
        }

        body.light-mode .find-replace-bar {
            background: #fff3cd !important;
            border-bottom-color: #ffc107 !important;
        }

        body.light-mode .global-search-modal {
            background: rgba(0,0,0,0.5) !important;
        }

        body.light-mode .global-search-box {
            background: #fff !important;
        }

        body.light-mode .global-search-input-wrap {
            background: #f8f9fa !important;
            border-bottom-color: #e0e0e0 !important;
        }

        body.light-mode .global-search-input-wrap input {
            color: #333 !important;
        }

        body.light-mode .global-search-filters {
            background: #f0f2f5 !important;
        }

        body.light-mode .search-results {
            background: #fff !important;
        }

        body.light-mode .search-result-item {
            border-bottom-color: #e0e0e0 !important;
        }

        body.light-mode .search-result-item:hover {
            background: #f8f9fa !important;
        }

        body.light-mode .toast {
            background: #333 !important;
            color: #fff !important;
        }

        /* Light mode additional styles */
        body.light-mode .snapshot-item {
            background: #f5f5f5 !important;
        }

        body.light-mode .snapshot-item:hover {
            background: #e8e8e8 !important;
        }

        body.light-mode .snapshot-name {
            color: #333 !important;
        }

        body.light-mode .snapshot-meta {
            color: #888 !important;
        }

        body.light-mode .manager-item {
            background: #f5f5f5 !important;
        }

        body.light-mode .manager-item .item-name {
            color: #333 !important;
        }

        body.light-mode .manager-item .item-actions button {
            background: #ddd !important;
            color: #333 !important;
        }

        body.light-mode .manager-form {
            background: #f9f9f9 !important;
        }

        body.light-mode .manager-form h3 {
            color: #666 !important;
        }

        body.light-mode .form-group input,
        body.light-mode .form-group select,
        body.light-mode .form-group textarea {
            background: #fff !important;
            border-color: #ddd !important;
            color: #333 !important;
        }

        body.light-mode .btn-cancel {
            background: #e0e0e0 !important;
            color: #333 !important;
        }

        body.light-mode .modal-actions {
            background: #f5f5f5 !important;
            border-top-color: #ddd !important;
        }

        body.light-mode .add-revision-btn {
            border-color: #ccc !important;
            color: #888 !important;
        }

        body.light-mode .revision-form {
            background: #f9f9f9 !important;
        }

        body.light-mode .revision-form input {
            background: #fff !important;
            border-color: #ddd !important;
            color: #333 !important;
        }

        body.light-mode .editor-snapshot-panel {
            background: #f5f5f5 !important;
        }

        body.light-mode .editor-snapshot-header {
            background: #e8e8e8 !important;
        }

        body.light-mode .editor-snapshot-header h4 {
            color: #555 !important;
        }

        body.light-mode .editor-snapshot-actions {
            background: #f0f0f0 !important;
        }

        body.light-mode .editor-snapshot-actions input {
            background: #fff !important;
            border-color: #ccc !important;
            color: #333 !important;
        }

        body.light-mode .editor-snapshot-item {
            background: #fff !important;
            border-color: #e0e0e0 !important;
        }

        body.light-mode .editor-snapshot-item .snap-name {
            color: #333 !important;
        }

        body.light-mode .find-results-panel {
            background: #f5f5f5 !important;
            border-bottom-color: #ddd !important;
        }

        body.light-mode .find-result-item {
            background: #fff !important;
            color: #333 !important;
        }

        body.light-mode .find-result-item:hover {
            background: #e9ecef !important;
        }

        body.light-mode .find-result-item .result-num {
            background: #e0e0e0 !important;
            color: #666 !important;
        }

        body.light-mode .nav-btn {
            background: #ddd !important;
            color: #333 !important;
        }

        body.light-mode .nav-btn:hover {
            background: #ccc !important;
        }

        body.light-mode .find-options {
            border-left-color: #ccc !important;
        }

        body.light-mode .find-option {
            background: #e9ecef !important;
            border-color: #ccc !important;
            color: #666 !important;
        }

        body.light-mode .find-option:hover {
            background: #ddd !important;
        }

        body.light-mode .find-option:has(input:checked) {
            background: #ffe0e6 !important;
            border-color: #e94560 !important;
        }

        /* Light mode focus mode */
        body.light-mode .focus-mode-active {
            background: #f5f5f5 !important;
        }

        body.light-mode .focus-mode-active .modal-content {
            background: #f5f5f5 !important;
        }

        body.light-mode .focus-mode-active .editor-section {
            background: #f5f5f5 !important;
        }

        body.light-mode .focus-mode-active #fullTextEditor {
            background: #fff !important;
            color: #333 !important;
        }

        body.light-mode .focus-mode-active .editor-footer {
            background: rgba(0,0,0,0.7) !important;
            color: #fff !important;
        }

        /* Light mode find & replace bar */
        body.light-mode .find-replace-bar {
            background: #fff !important;
            border-color: #ddd !important;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15) !important;
        }

        body.light-mode .find-replace-bar input {
            background: #f5f5f5 !important;
            border-color: #ddd !important;
            color: #333 !important;
        }

        body.light-mode .find-replace-bar label {
            color: #666 !important;
        }

        body.light-mode .find-replace-bar .find-options label {
            background: #f0f0f0 !important;
            color: #666 !important;
            border-color: #ddd !important;
        }

        body.light-mode .find-replace-bar .nav-btn {
            background: #e0e0e0 !important;
            color: #333 !important;
        }

        body.light-mode .find-replace-bar .result-count {
            color: #e94560 !important;
        }

        /* Light mode file preview modal */
        body.light-mode .file-preview-modal {
            background: rgba(0,0,0,0.7) !important;
        }

        body.light-mode .file-preview-content {
            background: #fff !important;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2) !important;
        }

        body.light-mode .file-preview-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: #fff !important;
        }

        body.light-mode .file-preview-header button {
            color: #fff !important;
        }

        body.light-mode .file-preview-body {
            background: #f5f5f5 !important;
        }

        body.light-mode .file-preview-actions {
            background: #f0f0f0 !important;
            border-top: 1px solid #ddd !important;
        }

        body.light-mode .preview-close-btn {
            background: #e0e0e0 !important;
            color: #333 !important;
        }

        body.light-mode .preview-close-btn:hover {
            background: #d0d0d0 !important;
        }

        /* Light mode editor sidebar (Structure & Attachments in text editor) */
        body.light-mode .editor-sidebar {
            background: #f0f2f5 !important;
            border-right: 1px solid #ddd !important;
        }

        body.light-mode .sidebar-section {
            background: #f8f9fa !important;
        }

        body.light-mode .sidebar-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: #fff !important;
        }

        body.light-mode .sidebar-tree {
            background: #f8f9fa !important;
        }

        body.light-mode .sidebar-tree-item {
            background: #fff !important;
            color: #333 !important;
            border: 1px solid #e0e0e0 !important;
        }

        body.light-mode .sidebar-tree-item:hover {
            background: #e9ecef !important;
            color: #333 !important;
        }

        body.light-mode .sidebar-tree-item.active {
            background: #e94560 !important;
            color: #fff !important;
        }

        body.light-mode .sidebar-attachments {
            background: #f8f9fa !important;
        }

        body.light-mode .attachment-item {
            background: #fff !important;
            border: 1px solid #e0e0e0 !important;
            color: #333 !important;
        }

        body.light-mode .attachment-item:hover {
            background: #f0f0f0 !important;
        }

        body.light-mode .attachment-item .att-name {
            color: #333 !important;
        }

        body.light-mode .attachment-item .att-size {
            color: #888 !important;
        }

        body.light-mode .add-attachment-btn {
            background: #4CAF50 !important;
            color: #fff !important;
        }

        body.light-mode .attachment-item button {
            color: #666 !important;
        }

        body.light-mode .attachment-item button:hover {
            color: #e94560 !important;
        }

        body.light-mode .attachment-item .att-name {
            color: #333 !important;
        }

        body.light-mode .attachment-item .att-size {
            color: #888 !important;
        }

        /* Light mode outline panel */
        body.light-mode .panel-tabs {
            background: #f5f5f5 !important;
            border-bottom-color: #ddd !important;
        }

        body.light-mode .panel-tab {
            color: #666 !important;
        }

        body.light-mode .panel-tab.active {
            background: #fff !important;
            color: #333 !important;
        }

        body.light-mode .outline-toolbar {
            background: #f5f5f5 !important;
            border-bottom-color: #ddd !important;
        }

        body.light-mode .outline-toolbar button {
            background: #e0e0e0 !important;
            color: #333 !important;
        }

        body.light-mode .outline-toolbar button:hover {
            background: #d0d0d0 !important;
        }

        body.light-mode #outlineTree {
            background: #fff !important;
        }

        body.light-mode .outline-item {
            color: #1f2328 !important;
            background: transparent !important;
            font-size: 14px !important;
        }

        /* Light mode - Type-based hover colors (matching dark mode) */
        body.light-mode .outline-item[data-type="section"]:hover,
        body.light-mode .outline-item[data-type="group"]:hover,
        body.light-mode .outline-item[data-type="draft"]:hover {
            background: #ff9800 !important;
            color: #fff !important;
        }
        body.light-mode .outline-item[data-type="research"]:hover {
            background: #4CAF50 !important;
            color: #fff !important;
        }
        body.light-mode .outline-item[data-type="note"]:hover {
            background: #9C27B0 !important;
            color: #fff !important;
        }
        body.light-mode .outline-item[data-type="reference"]:hover {
            background: #00BCD4 !important;
            color: #fff !important;
        }
        body.light-mode .outline-item[data-type="conclusion"]:hover {
            background: #f44336 !important;
            color: #fff !important;
        }
        body.light-mode .outline-item[data-type="appendix"]:hover {
            background: #607D8B !important;
            color: #fff !important;
        }
        body.light-mode .outline-item[data-type="abstract"]:hover {
            background: #673AB7 !important;
            color: #fff !important;
        }
        body.light-mode .outline-item[data-type="introduction"]:hover {
            background: #2196F3 !important;
            color: #fff !important;
        }

        /* Light mode - Generic hover fallback */
        body.light-mode .outline-item:hover {
            background: #0969da !important;
            color: #fff !important;
        }

        body.light-mode .outline-item:hover .word-count,
        body.light-mode .outline-item:hover .word-count .current,
        body.light-mode .outline-item:hover .word-count .target,
        body.light-mode .outline-item:hover .toggle-btn {
            color: rgba(255,255,255,0.9) !important;
        }

        body.light-mode .outline-item.active {
            background: #0969da !important;
            color: #fff !important;
        }

        body.light-mode .outline-item.active .word-count,
        body.light-mode .outline-item.active .toggle-btn {
            color: rgba(255,255,255,0.9) !important;
        }

        body.light-mode .outline-item .outline-title {
            color: inherit !important;
        }

        body.light-mode .outline-item .word-count {
            color: #57606a !important;
        }

        body.light-mode .outline-item .word-count .current {
            color: #0969da !important;
            font-weight: 600;
        }

        body.light-mode .outline-item .toggle-btn {
            color: #57606a !important;
        }

        body.light-mode .progress-bar {
            background: #e1e4e8 !important;
        }

        /* Light mode add menu / context menu */
        body.light-mode .context-menu {
            background: #fff !important;
            border-color: #ddd !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
        }

        body.light-mode .context-menu-item {
            color: #333 !important;
        }

        body.light-mode .context-menu-item:hover {
            background: #f0f0f0 !important;
        }

        body.light-mode .context-menu-divider {
            border-color: #ddd !important;
        }

        /* Light mode search modal */
        body.light-mode .global-search-mode {
            background: #f5f5f5 !important;
            border-bottom-color: #ddd !important;
        }

        body.light-mode .search-mode-btn {
            border-color: #ccc !important;
            color: #666 !important;
        }

        body.light-mode .search-mode-btn.active {
            background: #e94560 !important;
            border-color: #e94560 !important;
            color: #fff !important;
        }

        body.light-mode .global-search-filters {
            background: #f8f9fa !important;
        }

        body.light-mode .search-filter-btn {
            background: #fff !important;
            border-color: #ddd !important;
            color: #666 !important;
        }

        body.light-mode .search-filter-btn.active {
            background: #e94560 !important;
            border-color: #e94560 !important;
            color: #fff !important;
        }

        body.light-mode .global-search-results {
            background: #fff !important;
        }

        body.light-mode .search-result-item {
            border-bottom-color: #eee !important;
        }

        body.light-mode .search-result-title {
            color: #333 !important;
        }

        body.light-mode .search-result-context {
            color: #666 !important;
        }

        body.light-mode .search-result-meta {
            color: #999 !important;
        }

        /* Light mode focus toolbar */
        body.light-mode .focus-toolbar {
            background: #333 !important;
        }

        /* Light mode text editor in modal */
        body.light-mode .text-editor {
            background: #fff !important;
            color: #333 !important;
        }

        body.light-mode #fullTextEditor {
            background: #fff !important;
            color: #333 !important;
        }

        body.light-mode .attachment-item {
            background: #f8f9fa !important;
            color: #333 !important;
        }

        /* Light mode stats panel */
        body.light-mode #statsPanel {
            background: #fff !important;
            color: #333 !important;
        }

        body.light-mode #statsContent {
            color: #333 !important;
        }

        body.light-mode .stats-section {
            background: #f8f9fa !important;
            border-color: #ddd !important;
        }

        body.light-mode .stats-section h4 {
            color: #333 !important;
        }

        /* Light mode backup modal */
        body.light-mode .backup-content-item {
            background: #f0f0f0 !important;
            color: #333 !important;
        }

        body.light-mode .backup-content-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: #fff !important;
        }

        /* Light mode node cards */
        body.light-mode .node {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
        }

        body.light-mode .node-body {
            background: #fff !important;
        }

        body.light-mode .node-summary {
            color: #666 !important;
        }

        body.light-mode .node-toolbar {
            background: #f5f5f5 !important;
            border-top-color: #e0e0e0 !important;
        }

        body.light-mode .node-toolbar span {
            color: #666 !important;
        }

        body.light-mode .node-descs {
            background: #f8f8f8 !important;
            border-top-color: #e0e0e0 !important;
        }

        body.light-mode .node-pov {
            color: #333 !important;
            font-weight: 600 !important;
        }

        body.light-mode .node-desc-tag {
            color: #444 !important;
            font-weight: 500 !important;
        }

        /* ============ FULL LIGHT MODE STYLES ============ */

        /* Sidebar */
        body.light-mode .sidebar {
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%) !important;
            border-right-color: #e1e4e8 !important;
        }

        body.light-mode .sidebar-tabs {
            background: #f0f1f3 !important;
            border-bottom-color: #e1e4e8 !important;
        }

        body.light-mode .sidebar-tab {
            color: #57606a !important;
        }

        body.light-mode .sidebar-tab.active {
            background: #ffffff !important;
            color: #0969da !important;
        }

        body.light-mode .panel-content {
            background: #ffffff !important;
        }

        /* Projects Panel Light Mode */
        body.light-mode #projectsPanel {
            background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%) !important;
        }

        body.light-mode .projects-side-header {
            background: linear-gradient(135deg, rgba(9, 105, 218, 0.08) 0%, rgba(5, 80, 174, 0.04) 100%) !important;
            border-bottom-color: #e1e4e8 !important;
        }

        body.light-mode .user-name {
            color: #1f2328 !important;
        }

        body.light-mode .user-status {
            color: #57606a !important;
        }

        body.light-mode .projects-side-toolbar {
            border-bottom-color: #e1e4e8 !important;
        }

        body.light-mode .projects-side-btn {
            border-color: rgba(9, 105, 218, 0.3) !important;
            color: #0969da !important;
        }

        body.light-mode .projects-side-btn:hover {
            background: rgba(9, 105, 218, 0.08) !important;
            border-color: #0969da !important;
        }

        /* Project Items Light Mode - CLEAN WHITE CARDS */
        body.light-mode .proj-item {
            background: #ffffff !important;
            border: 1px solid #e1e4e8 !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06) !important;
        }

        body.light-mode .proj-item:hover {
            background: #fafbfc !important;
            border-color: #0969da !important;
            box-shadow: 0 4px 12px rgba(9, 105, 218, 0.15) !important;
            transform: translateX(4px) !important;
        }

        body.light-mode .proj-item.active {
            background: rgba(9, 105, 218, 0.05) !important;
            border-color: #0969da !important;
            box-shadow: 0 0 0 2px rgba(9, 105, 218, 0.15) !important;
        }

        body.light-mode .proj-item::before {
            background: linear-gradient(180deg, #0969da 0%, #0550ae 100%) !important;
        }

        body.light-mode .proj-name {
            color: #1f2328 !important;
        }

        body.light-mode .proj-updated {
            color: #57606a !important;
        }

        body.light-mode .proj-icon {
            background: linear-gradient(135deg, rgba(9, 105, 218, 0.1) 0%, rgba(9, 105, 218, 0.05) 100%) !important;
        }

        body.light-mode .proj-menu-btn {
            background: #f6f8fa !important;
            border-color: #d0d7de !important;
            color: #57606a !important;
        }

        body.light-mode .proj-menu-btn:hover {
            background: #0969da !important;
            border-color: #0969da !important;
            color: white !important;
        }

        body.light-mode .proj-info {
            border-color: #e1e4e8 !important;
        }

        body.light-mode .proj-stat {
            background: #f6f8fa !important;
        }

        body.light-mode .proj-num {
            background: linear-gradient(135deg, #0969da 0%, #0550ae 100%) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
        }

        body.light-mode .proj-label {
            color: #6e7781 !important;
        }

        body.light-mode .proj-bar {
            background: #e1e4e8 !important;
        }

        body.light-mode .proj-fill {
            background: linear-gradient(90deg, #0969da 0%, #0550ae 50%, #0969da 100%) !important;
        }

        body.light-mode .proj-pct {
            color: #0969da !important;
        }

        body.light-mode .proj-actions button {
            background: #f6f8fa !important;
            border-color: #d0d7de !important;
            color: #57606a !important;
        }

        body.light-mode .proj-actions button:hover {
            background: #0969da !important;
            border-color: #0969da !important;
            color: white !important;
        }

        /* Outline Panel Light Mode */
        body.light-mode #outlinePanel {
            background: #ffffff !important;
        }

        body.light-mode .outline-item {
            background: #f8f9fa !important;
            border-color: #e1e4e8 !important;
            color: #1f2328 !important;
        }

        body.light-mode .outline-item:hover {
            background: #f0f1f3 !important;
            border-color: #0969da !important;
        }

        body.light-mode .outline-item.active {
            background: rgba(9, 105, 218, 0.08) !important;
            border-color: #0969da !important;
        }

        /* Stats Panel Light Mode */
        body.light-mode .stats-card {
            background: #f8f9fa !important;
            border-color: #e1e4e8 !important;
        }

        body.light-mode .stats-card-value {
            color: #1f2328 !important;
        }

        body.light-mode .stats-card-label {
            color: #6e7781 !important;
        }

        body.light-mode .stats-card.primary {
            background: linear-gradient(135deg, #0969da 0%, #0550ae 100%) !important;
        }
        
        /* Stats Hero Light Mode */
        body.light-mode .stats-hero {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%) !important;
            border-color: #d0d7de !important;
        }
        
        body.light-mode .stats-hero-number {
            background: linear-gradient(135deg, #0969da, #8b5cf6) !important;
            -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
        }
        
        body.light-mode .stats-hero-label {
            color: #6e7781 !important;
        }
        
        body.light-mode .stats-hero-item {
            background: rgba(0,0,0,0.05) !important;
        }
        
        body.light-mode .stats-hero-item .hero-value {
            color: #1f2328 !important;
        }
        
        body.light-mode .stats-hero-item .hero-label {
            color: #6e7781 !important;
        }
        
        body.light-mode .stats-status-item {
            background: #f8f9fa !important;
        }
        
        body.light-mode .stats-status-item .status-count {
            background: rgba(0,0,0,0.08) !important;
        }
        
        body.light-mode .task-mini-item {
            background: #f8f9fa !important;
            color: #57606a !important;
        }
        
        body.light-mode .task-mini-item:hover {
            background: #e9ecef !important;
            color: #1f2328 !important;
        }
        
        body.light-mode .conn-stat {
            background: #f8f9fa !important;
        }

        /* Header Light Mode */
        body.light-mode .header {
            background: #ffffff !important;
            border-bottom-color: #e1e4e8 !important;
        }

        body.light-mode .menu-bar button {
            color: #57606a !important;
        }

        body.light-mode .menu-bar button:hover {
            background: #f0f1f3 !important;
            color: #1f2328 !important;
        }

        body.light-mode .logo-section {
            color: #1f2328 !important;
        }

        body.light-mode .project-title {
            color: #1f2328 !important;
            background: #f8f9fa !important;
            border-color: #e1e4e8 !important;
        }

        body.light-mode .save-btn {
            background: linear-gradient(135deg, #0969da 0%, #0550ae 100%) !important;
        }

        /* Canvas Light Mode */
        body.light-mode .canvas-area {
            background: #f0f1f3 !important;
        }

        body.light-mode #canvas {
            background: linear-gradient(135deg, #f8f9fa 0%, #f0f1f3 100%) !important;
        }

        /* Dropdown Menus Light Mode */
        body.light-mode .menu-dropdown {
            background: #ffffff !important;
            border-color: #e1e4e8 !important;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12) !important;
        }

        body.light-mode .menu-dropdown-item {
            color: #1f2328 !important;
        }

        body.light-mode .menu-dropdown-item:hover {
            background: #f0f1f3 !important;
        }

        body.light-mode .menu-dropdown-divider {
            border-color: #e1e4e8 !important;
        }

        /* Context Menu Light Mode */
        body.light-mode .project-context-menu {
            background: #ffffff !important;
            border-color: #e1e4e8 !important;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12) !important;
        }

        body.light-mode .ctx-item {
            color: #1f2328 !important;
        }

        body.light-mode .ctx-item:hover {
            background: #f0f1f3 !important;
        }

        body.light-mode .ctx-header {
            background: #f8f9fa !important;
        }

        body.light-mode .ctx-name {
            color: #1f2328 !important;
        }

        body.light-mode .ctx-divider {
            border-color: #e1e4e8 !important;
        }

        /* Scrollbar Light Mode */
        body.light-mode ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.15) !important;
        }

        body.light-mode ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.25) !important;
        }

        /* System theme toggle button */
        .theme-toggle-btn {
            width: 32px !important;
            height: 32px !important;
            padding: 0 !important;
            border-radius: 8px !important;
            background: var(--bg-tertiary) !important;
            color: var(--text-secondary) !important;
            font-size: 16px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .theme-toggle-btn:hover {
            background: var(--bg-hover) !important;
            color: var(--text-primary) !important;
        }

        body.light-mode .theme-toggle-btn {
            background: #f0f1f3 !important;
            color: #57606a !important;
        }

        body.light-mode .theme-toggle-btn:hover {
            background: #e1e4e8 !important;
        }

        /* ============ MODERN MENU BAR ============ */
        .menu-bar {
            display: flex;
            align-items: center;
            gap: 2px;
            flex: 1;
            margin-left: 24px;
        }

        .menu-item {
            position: relative;
        }

        .menu-toolbar {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: 16px;
            padding-left: 16px;
            border-left: 1px solid var(--border-subtle);
        }

        .toolbar-icon-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s;
        }

        .toolbar-icon-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .toolbar-icon-btn:active {
            transform: scale(0.95);
        }

        .toolbar-icon-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .toolbar-icon-btn svg {
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: var(--border-subtle);
            margin: 0 6px;
        }

        .menu-trigger {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 8px 14px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s ease;
        }

        .menu-trigger:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .menu-item:hover .menu-trigger {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .menu-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            min-width: 220px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: 10px;
            padding: 6px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.2s ease;
            z-index: 9999;
            box-shadow: var(--shadow-lg);
        }

        .menu-item:hover .menu-dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateY(4px);
        }

        .menu-dropdown-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .menu-dropdown-item:hover {
            background: var(--bg-hover);
        }

        .menu-icon {
            font-size: 15px;
            width: 20px;
            text-align: center;
        }

        .menu-label {
            flex: 1;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .menu-shortcut {
            font-size: 11px;
            color: var(--text-tertiary);
            background: var(--bg-tertiary);
            padding: 3px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        .menu-divider {
            height: 1px;
            background: var(--border-subtle);
            margin: 6px 0;
        }

        /* Submenu Styles */
        .menu-dropdown-item.has-submenu {
            position: relative;
        }

        .menu-dropdown-item .menu-arrow {
            font-size: 10px;
            color: var(--text-tertiary);
            margin-left: auto;
        }

        .menu-submenu {
            position: absolute;
            left: 100%;
            top: 0;
            min-width: 180px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: 10px;
            padding: 6px;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            visibility: hidden;
            transform: translateX(-10px);
            transition: all 0.15s ease;
            z-index: 2000;
        }

        .menu-dropdown-item.has-submenu:hover .menu-submenu {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }

        .menu-submenu .menu-dropdown-item {
            padding: 8px 12px;
        }

        /* Header Actions */
        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 7px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .header-action-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--border-default);
        }

        .header-action-btn.primary {
            background: var(--accent-gradient);
            border: none;
            color: white;
        }

        .header-action-btn.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .action-icon {
            font-size: 14px;
        }

        /* Light mode menu */
        body.light-mode .menu-dropdown {
            background: #ffffff;
            border-color: #d0d7de;
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
        }

        body.light-mode .menu-dropdown-item:hover {
            background: #f3f4f6;
        }

        body.light-mode .menu-shortcut {
            background: #f3f4f6;
            color: #6e7781;
        }

        /* ============ USER MENU DROPDOWN ============ */
        .user-menu {
            position: relative;
        }

        .user-menu-trigger {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .user-menu-trigger:hover {
            background: var(--bg-hover);
            border-color: var(--border-default);
        }

        .user-avatar-small {
            font-size: 14px;
        }

        .user-name-small {
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .user-chevron {
            font-size: 10px;
            color: var(--text-tertiary);
            transition: transform 0.2s ease;
        }

        .user-menu.open .user-chevron {
            transform: rotate(180deg);
        }

        .user-dropdown {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            min-width: 220px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: 12px;
            padding: 8px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 9999;
            box-shadow: var(--shadow-lg);
        }

        .user-menu.open .user-dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .user-dropdown-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .dropdown-avatar {
            font-size: 28px;
        }

        .dropdown-user-info {
            display: flex;
            flex-direction: column;
        }

        .dropdown-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .dropdown-email {
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .user-dropdown-divider {
            height: 1px;
            background: var(--border-subtle);
            margin: 6px 0;
        }

        .user-dropdown-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .user-dropdown-item:hover {
            background: var(--bg-hover);
        }

        .user-dropdown-item.danger {
            color: var(--danger);
        }

        .user-dropdown-item.danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        /* Save Button */
        .save-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 16px;
            background: var(--accent-gradient);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            box-sizing: border-box;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .save-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        /* Minimal Theme Toggle */
        .theme-toggle {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .theme-toggle:hover {
            background: var(--bg-hover);
            border-color: var(--border-default);
        }

        .theme-icon {
            font-size: 16px;
            line-height: 1;
        }

        /* Light mode user menu */
        body.light-mode .user-dropdown {
            background: #ffffff;
            border-color: #d0d7de;
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
        }

        body.light-mode .user-dropdown-header {
            background: #f6f8fa;
        }

        body.light-mode .user-dropdown-item:hover {
            background: #f3f4f6;
        }

        /* ============ SYNC STATUS ============ */
        .sync-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.2);
            border-radius: 20px;
            font-size: 11px;
            color: #22c55e;
            margin-left: 16px;
        }

        .sync-status.syncing {
            background: rgba(234, 179, 8, 0.1);
            border-color: rgba(234, 179, 8, 0.2);
            color: #eab308;
        }

        .sync-status.syncing .sync-icon {
            animation: spin 1s linear infinite;
        }

        .sync-status.error {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .sync-status.offline {
            background: rgba(107, 114, 128, 0.1);
            border-color: rgba(107, 114, 128, 0.2);
            color: #6b7280;
        }

        .sync-icon {
            font-size: 12px;
        }

        .sync-text {
            font-weight: 500;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* ============ COMMAND PALETTE ============ */
        .command-palette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 99999;
            display: none;
            justify-content: center;
            padding-top: 15vh;
        }

        .command-palette-overlay.active {
            display: flex;
        }

        .command-palette {
            width: 560px;
            max-height: 400px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-default);
            border-radius: 12px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.4);
            overflow: hidden;
        }

        .command-input-wrap {
            display: flex;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--border-subtle);
            gap: 12px;
        }

        .command-input-wrap .search-icon {
            font-size: 18px;
            color: var(--text-tertiary);
        }

        .command-input {
            flex: 1;
            background: transparent;
            border: none;
            font-size: 16px;
            color: var(--text-primary);
            outline: none;
        }

        .command-input::placeholder {
            color: var(--text-tertiary);
        }

        .command-shortcut {
            font-size: 11px;
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            color: var(--text-tertiary);
            font-family: monospace;
        }

        .command-results {
            max-height: 320px;
            overflow-y: auto;
            padding: 8px;
        }

        .command-group {
            margin-bottom: 12px;
        }

        .command-group-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 8px 12px;
        }

        .command-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.1s ease;
        }

        .command-item:hover,
        .command-item.selected {
            background: var(--bg-hover);
        }

        .command-item-icon {
            font-size: 16px;
            width: 24px;
            text-align: center;
        }

        .command-item-text {
            flex: 1;
            font-size: 14px;
            color: var(--text-primary);
        }

        .command-item-shortcut {
            font-size: 11px;
            color: var(--text-tertiary);
            font-family: monospace;
        }

        /* Light mode command palette */
        body.light-mode .command-palette {
            background: #ffffff;
            border-color: #d0d7de;
        }

        body.light-mode .command-palette-overlay {
            background: rgba(0,0,0,0.3);
        }

        /* ============ QUICK EDIT PANEL ============ */
        .quick-edit-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-default);
            z-index: 9000;
            display: flex;
            flex-direction: column;
            transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-lg);
        }

        .quick-edit-panel.open {
            right: 0;
        }

        .quick-edit-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-subtle);
            background: var(--bg-tertiary);
        }

        .quick-edit-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .quick-edit-title h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .quick-edit-badge {
            font-size: 11px;
            padding: 3px 8px;
            background: var(--accent-gradient);
            color: white;
            border-radius: 4px;
            font-weight: 500;
        }

        .quick-edit-close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            border-radius: 6px;
            font-size: 18px;
            transition: all 0.15s ease;
        }

        .quick-edit-close:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .quick-edit-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .quick-edit-section {
            margin-bottom: 20px;
        }

        .quick-edit-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .quick-edit-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            transition: all 0.15s ease;
        }

        .quick-edit-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }

        .quick-edit-textarea {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            line-height: 1.6;
            resize: vertical;
            transition: all 0.15s ease;
        }

        .quick-edit-textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
        }

        .quick-edit-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .quick-edit-select {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
        }

        .quick-edit-select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .quick-edit-stats {
            display: flex;
            gap: 16px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .quick-stat {
            text-align: center;
        }

        .quick-stat-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .quick-stat-label {
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
        }

        .quick-edit-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border-subtle);
            display: flex;
            gap: 10px;
        }

        .quick-edit-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .quick-edit-btn.secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-subtle);
            color: var(--text-secondary);
        }

        .quick-edit-btn.secondary:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .quick-edit-btn.primary {
            background: var(--accent-gradient);
            border: none;
            color: white;
        }

        .quick-edit-btn.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .quick-edit-btn.open-full {
            background: transparent;
            border: 1px dashed var(--border-default);
            color: var(--text-secondary);
        }

        .quick-edit-btn.open-full:hover {
            background: var(--bg-hover);
            border-style: solid;
            color: var(--text-primary);
        }

        /* Light mode quick edit */
        body.light-mode .quick-edit-panel {
            background: #ffffff;
            border-color: #d0d7de;
        }

        body.light-mode .quick-edit-header {
            background: #f6f8fa;
        }

        body.light-mode .quick-edit-input,
        body.light-mode .quick-edit-textarea,
        body.light-mode .quick-edit-select {
            background: #f6f8fa;
            border-color: #d0d7de;
        }

        body.light-mode .quick-edit-stats {
            background: #f6f8fa;
        }

        /* ============ SIDE PANEL ATTACHMENTS ============ */
        .side-attachments-section {
            border-top: 1px solid var(--border-subtle);
            background: var(--bg-tertiary);
        }

        .side-attachments-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .side-attach-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--accent-gradient);
            color: white;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .side-attach-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .side-attachments-list {
            max-height: 200px;
            overflow-y: auto;
            padding: 0 12px 12px;
        }

        .no-attachments {
            color: var(--text-tertiary);
            font-size: 12px;
            text-align: center;
            padding: 16px;
        }

        .side-attachment-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.15s ease;
        }

        .side-attachment-item:hover {
            background: var(--bg-hover);
            border-color: var(--border-default);
        }

        .side-attach-icon {
            font-size: 20px;
        }

        .side-attach-info {
            flex: 1;
            min-width: 0;
        }

        .side-attach-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .side-attach-size {
            font-size: 11px;
            color: var(--text-tertiary);
        }

        .side-attach-actions {
            display: flex;
            gap: 4px;
        }

        .side-attach-actions button {
            width: 26px;
            height: 26px;
            border: none;
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .side-attach-actions button:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .side-attach-actions button.delete:hover {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
        }

        /* Light mode */
        body.light-mode .side-attachments-section {
            background: #f6f8fa;
        }

        body.light-mode .side-attachment-item {
            background: #ffffff;
            border-color: #d0d7de;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <div class="logo">
                <div class="logo-icon">‚ú¶</div>
                <span>Writer</span>
                <span style="font-size: 10px; color: #4ade80; margin-left: 5px; background: rgba(74,222,128,0.2); padding: 2px 6px; border-radius: 4px;">OFFLINE</span>
            </div>
            <!-- Sync Status - Offline modda "Local" g√∂ster -->
            <div class="sync-status" id="syncStatus" title="Offline mode - data saved locally">
                <span class="sync-icon" id="syncIcon">üíæ</span>
                <span class="sync-text" id="syncText">Local</span>
            </div>
        </div>
        <nav class="menu-bar">
            <!-- File Menu -->
            <div class="menu-item">
                <button class="menu-trigger">File</button>
                <div class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="newFile()">
                        <span class="menu-icon">‚ú®</span>
                        <span class="menu-label">New</span>
                        <span class="menu-shortcut">‚åòN</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openProject()">
                        <span class="menu-icon">üìÇ</span>
                        <span class="menu-label">Open</span>
                        <span class="menu-shortcut">‚åòO</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="cloudSave()">
                        <span class="menu-icon">üíæ</span>
                        <span class="menu-label">Save</span>
                        <span class="menu-shortcut">‚åòS</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="closeProject()">
                        <span class="menu-icon">üìï</span>
                        <span class="menu-label">Close</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="importToProject()">
                        <span class="menu-icon">üì•</span>
                        <span class="menu-label">Import</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="openBackupModal()">
                        <span class="menu-icon">üóÑÔ∏è</span>
                        <span class="menu-label">Backup</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openCompileModal()">
                        <span class="menu-icon">üìö</span>
                        <span class="menu-label">Compile</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="printProject()">
                        <span class="menu-icon">üñ®Ô∏è</span>
                        <span class="menu-label">Print</span>
                    </div>
                </div>
            </div>

            <!-- Edit Menu -->
            <div class="menu-item">
                <button class="menu-trigger">Edit</button>
                <div class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="undoAction()" id="undoMenuItem">
                        <span class="menu-icon">‚ü≤</span>
                        <span class="menu-label">Undo</span>
                        <span class="menu-shortcut">‚åòZ</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="redoAction()" id="redoMenuItem">
                        <span class="menu-icon">‚ü≥</span>
                        <span class="menu-label">Redo</span>
                        <span class="menu-shortcut">‚áß‚åòZ</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="showAddMenu(event)">
                        <span class="menu-icon">Ôºã</span>
                        <span class="menu-label">Add Node</span>
                        <span class="menu-shortcut">‚åòN</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="showAddTaskMenu(event)">
                        <span class="menu-icon">üìã</span>
                        <span class="menu-label">Add Task Node</span>
                        <span class="menu-shortcut">‚åòT</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="showAddSpecialMenu(event)">
                        <span class="menu-icon">‚ú®</span>
                        <span class="menu-label">Add Special Node</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="deleteSelected()">
                        <span class="menu-icon">‚úï</span>
                        <span class="menu-label">Delete Selected</span>
                        <span class="menu-shortcut">‚å´</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openTrashModal()">
                        <span class="menu-icon">‚Ü∫</span>
                        <span class="menu-label">Trash (Restore)</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="openGlobalSearch()">
                        <span class="menu-icon">‚åï</span>
                        <span class="menu-label">Search</span>
                        <span class="menu-shortcut">‚åòF</span>
                    </div>
                </div>
            </div>

            <!-- View Menu -->
            <div class="menu-item">
                <button class="menu-trigger">View</button>
                <div class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="showLayoutMenu(event)">
                        <span class="menu-icon">üìê</span>
                        <span class="menu-label">Layout Options</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="toggleTimelineBar()">
                        <span class="menu-icon">üìä</span>
                        <span class="menu-label" id="timelineBarMenuLabel">Show Timeline</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openTaskManager()">
                        <span class="menu-icon">‚úÖ</span>
                        <span class="menu-label">Task Manager</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="zoomIn()">
                        <span class="menu-icon">üîé</span>
                        <span class="menu-label">Zoom In</span>
                        <span class="menu-shortcut">‚åò+</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="zoomOut()">
                        <span class="menu-icon">üîç</span>
                        <span class="menu-label">Zoom Out</span>
                        <span class="menu-shortcut">‚åò-</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="fitToScreen()">
                        <span class="menu-icon">üñ•Ô∏è</span>
                        <span class="menu-label">Fit to Screen</span>
                        <span class="menu-shortcut">‚åò0</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="togglePropertiesPanel()">
                        <span class="menu-icon">üìã</span>
                        <span class="menu-label" id="propertiesPanelMenuLabel">Show Properties Panel</span>
                        <span class="menu-shortcut">‚åòI</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="toggleSystemTheme()">
                        <span class="menu-icon" id="themeMenuIcon">‚òÄÔ∏è</span>
                        <span class="menu-label" id="themeMenuLabel">Light Mode</span>
                    </div>
                </div>
            </div>

            <!-- Project Menu -->
            <div class="menu-item">
                <button class="menu-trigger">Project</button>
                <div class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="openPovManager()">
                        <span class="menu-icon">üë§</span>
                        <span class="menu-label">Authors/POV</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="openDescManager()">
                        <span class="menu-icon">üè∑Ô∏è</span>
                        <span class="menu-label">Tags/Types</span>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-dropdown-item" onclick="openSettingsModal()">
                        <span class="menu-icon">‚öôÔ∏è</span>
                        <span class="menu-label">Settings</span>
                    </div>
                </div>
            </div>

            <!-- Help Menu -->
            <div class="menu-item">
                <button class="menu-trigger">Help</button>
                <div class="menu-dropdown">
                    <div class="menu-dropdown-item" onclick="showKeyboardShortcuts()">
                        <span class="menu-icon">‚å®Ô∏è</span>
                        <span class="menu-label">Keyboard Shortcuts</span>
                    </div>
                    <div class="menu-dropdown-item" onclick="showAbout()">
                        <span class="menu-icon">‚ÑπÔ∏è</span>
                        <span class="menu-label">About Writer</span>
                    </div>
                </div>
            </div>

            <!-- Toolbar Icons -->
            <div class="menu-toolbar">
                <button class="toolbar-icon-btn" onclick="undoAction()" title="Geri Al (Ctrl+Z)" id="undoBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 7v6h6"></path>
                        <path d="M3 13c0-4.97 4.03-9 9-9s9 4.03 9 9-4.03 9-9 9c-2.12 0-4.07-.74-5.62-1.97"></path>
                    </svg>
                </button>
                <button class="toolbar-icon-btn" onclick="redoAction()" title="ƒ∞leri Al (Ctrl+Y)" id="redoBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 7v6h-6"></path>
                        <path d="M21 13c0-4.97-4.03-9-9-9s-9 4.03-9 9 4.03 9 9 9c2.12 0 4.07-.74 5.62-1.97"></path>
                    </svg>
                </button>
                <div class="toolbar-separator"></div>
                <button class="toolbar-icon-btn" onclick="openGlobalSearch()" title="Ara (Ctrl+K)">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="M21 21l-4.35-4.35"></path>
                    </svg>
                </button>
            </div>
        </nav>

        <div class="header-actions">
            <!-- Timeline Toggle Button -->
            <button class="timeline-toggle-btn" id="timelineToggleBtn" onclick="toggleTimelineBar()" title="Toggle Timeline Panel">
                <span class="arrow">‚ñº</span>
                <span id="timelineToggleBtnLabel">Timeline</span>
            </button>
            
            <!-- Settings Menu -->
            <div class="user-menu" id="userMenuContainer">
                <button class="user-menu-trigger" id="userMenuTrigger" onclick="toggleUserMenu()">
                    <span class="user-avatar-small">‚öôÔ∏è</span>
                    <span class="user-name-small">Menu</span>
                    <span class="user-chevron">‚ñæ</span>
                </button>
                <div class="user-dropdown" id="userDropdown">
                    <div class="user-dropdown-item" onclick="showKeyboardShortcuts()">
                        <span>‚å®Ô∏è</span> Keyboard Shortcuts
                    </div>
                    <div class="user-dropdown-item" onclick="showAbout()">
                        <span>‚ÑπÔ∏è</span> About Writer
                    </div>
                    <div class="user-dropdown-divider"></div>
                    <div class="user-dropdown-item" onclick="exportAllData()">
                        <span>üì§</span> Export Backup
                    </div>
                    <div class="user-dropdown-item" onclick="document.getElementById('importFileInput').click()">
                        <span>üì•</span> Import Backup
                    </div>
                    <input type="file" id="importFileInput" accept=".json" style="display:none" onchange="importData(event)">
                </div>
            </div>

            <!-- Save Button -->
            <button class="save-btn" onclick="cloudSave()">
                <span>üíæ</span> Save
            </button>

            <!-- Minimal Theme Toggle -->
            <button class="theme-toggle" onclick="toggleSystemTheme()" id="systemThemeBtn" title="Toggle Theme">
                <span class="theme-icon" id="themeIcon">‚òÄÔ∏è</span>
            </button>

            <input type="file" id="importFile" accept=".json" style="display:none" onchange="importData(event)">
        </div>
    </div>

    <div class="stats-bar">
        <div class="stat-item">Words: <span class="stat-value" id="totalWords">0</span></div>
        <div class="stat-item">Sections: <span class="stat-value" id="chapterCount">0</span></div>
        <div class="stat-item">Groups: <span class="stat-value" id="actCount">0</span></div>
        <div class="stat-item">Pages: <span class="stat-value" id="pageCount">0</span></div>
        <div style="flex:1;"></div>
        <div class="stat-item" style="cursor:pointer; opacity:0.7;" onclick="openCommandPalette()" title="Press ‚åòK">
            <span>‚åòK</span> Quick Actions
        </div>
    </div>

    <!-- Command Palette (Notion/Linear style) -->
    <div class="command-palette-overlay" id="commandPaletteOverlay" onclick="if(event.target===this)closeCommandPalette()">
        <div class="command-palette">
            <div class="command-input-wrap">
                <span class="search-icon">üîç</span>
                <input type="text" class="command-input" id="commandInput" placeholder="Type a command or search..." oninput="filterCommands()">
                <span class="command-shortcut">ESC</span>
            </div>
            <div class="command-results" id="commandResults">
                <div class="command-group">
                    <div class="command-group-title">Actions</div>
                    <div class="command-item" onclick="executeCommand('save')">
                        <span class="command-item-icon">üíæ</span>
                        <span class="command-item-text">Save Project</span>
                        <span class="command-item-shortcut">‚åòS</span>
                    </div>
                    <div class="command-item" onclick="executeCommand('search')">
                        <span class="command-item-icon">üîç</span>
                        <span class="command-item-text">Search in Project</span>
                        <span class="command-item-shortcut">‚åòF</span>
                    </div>
                    <div class="command-item" onclick="executeCommand('newNode')">
                        <span class="command-item-icon">‚ûï</span>
                        <span class="command-item-text">Add New Node</span>
                        <span class="command-item-shortcut">‚åòN</span>
                    </div>
                    <div class="command-item" onclick="executeCommand('compile')">
                        <span class="command-item-icon">üìö</span>
                        <span class="command-item-text">Compile Manuscript</span>
                    </div>
                </div>
                <div class="command-group">
                    <div class="command-group-title">View</div>
                    <div class="command-item" onclick="executeCommand('toggleTheme')">
                        <span class="command-item-icon">üåì</span>
                        <span class="command-item-text">Toggle Theme</span>
                    </div>
                    <div class="command-item" onclick="executeCommand('zoomIn')">
                        <span class="command-item-icon">üîé</span>
                        <span class="command-item-text">Zoom In</span>
                        <span class="command-item-shortcut">‚åò+</span>
                    </div>
                    <div class="command-item" onclick="executeCommand('zoomOut')">
                        <span class="command-item-icon">üîç</span>
                        <span class="command-item-text">Zoom Out</span>
                        <span class="command-item-shortcut">‚åò-</span>
                    </div>
                    <div class="command-item" onclick="executeCommand('fitScreen')">
                        <span class="command-item-icon">üñ•Ô∏è</span>
                        <span class="command-item-text">Fit to Screen</span>
                        <span class="command-item-shortcut">‚åò0</span>
                    </div>
                </div>
                <div class="command-group">
                    <div class="command-group-title">File</div>
                    <div class="command-item" onclick="newFile()">
                        <span class="command-item-icon">‚ú®</span>
                        <span class="command-item-text">New File</span>
                        <span class="command-item-shortcut">‚åòN</span>
                    </div>
                    <div class="command-item" onclick="openProject()">
                        <span class="command-item-icon">üìÇ</span>
                        <span class="command-item-text">Open File</span>
                        <span class="command-item-shortcut">‚åòO</span>
                    </div>
                    <div class="command-item" onclick="cloudSave()">
                        <span class="command-item-icon">üíæ</span>
                        <span class="command-item-text">Save File</span>
                        <span class="command-item-shortcut">‚åòS</span>
                    </div>
                    <div class="command-item" onclick="executeCommand('backup')">
                        <span class="command-item-icon">üóÑÔ∏è</span>
                        <span class="command-item-text">Create Backup</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Global Search Modal -->
    <!-- Modern Search Modal - Raycast/Linear Style -->
    <div class="global-search-modal" id="globalSearchModal" onclick="if(event.target===this) closeGlobalSearch()">
        <div class="global-search-box">
            <div class="global-search-input-wrap">
                <span class="search-icon">üîç</span>
                <input type="text" id="globalSearchInput" placeholder="Search sections, text, authors..." oninput="performGlobalSearch()" autocomplete="off">
                <button class="search-close-btn" onclick="closeGlobalSearch()">ESC</button>
            </div>
            <!-- Search Mode Toggle -->
            <div class="global-search-mode">
                <button class="search-mode-btn active" data-mode="contains" onclick="setSearchMode('contains')">
                    <span>üîé</span> Contains
                </button>
                <button class="search-mode-btn" data-mode="exact" onclick="setSearchMode('exact')">
                    <span>üéØ</span> Exact Match
                </button>
            </div>
            <!-- Search Filters -->
            <div class="global-search-filters">
                <button class="search-filter-btn active" data-filter="all" onclick="setSearchFilter('all')">T√ºm√º</button>
                <button class="search-filter-btn" data-filter="text" onclick="setSearchFilter('text')">üìù ƒ∞√ßerik</button>
                <button class="search-filter-btn" data-filter="title" onclick="setSearchFilter('title')">üìÑ Ba≈ülƒ±k</button>
                <button class="search-filter-btn" data-filter="task" onclick="setSearchFilter('task')">‚úÖ G√∂rev</button>
                <button class="search-filter-btn" data-filter="folder" onclick="setSearchFilter('folder')">üìÅ Klas√∂r</button>
                <button class="search-filter-btn" data-filter="sticky" onclick="setSearchFilter('sticky')">üìå Sticky</button>
                <button class="search-filter-btn" data-filter="image" onclick="setSearchFilter('image')">üñºÔ∏è Resim</button>
                <button class="search-filter-btn" data-filter="file" onclick="setSearchFilter('file')">üìé Dosya</button>
            </div>
            <!-- Search Results -->
            <div class="global-search-results" id="globalSearchResults">
                <div class="search-empty-state">
                    <div class="empty-icon">üîç</div>
                    <p>Search your manuscript</p>
                    <span class="hint">Type to find sections, text, authors, locations...</span>
                </div>
            </div>
            <!-- Keyboard Shortcuts -->
            <div class="search-shortcut-hint">
                <span><kbd>‚Üë</kbd><kbd>‚Üì</kbd> Navigate</span>
                <span><kbd>‚Üµ</kbd> Open</span>
                <span><kbd>ESC</kbd> Close</span>
            </div>
        </div>
    </div>

    <!-- Auto-save Indicator -->
    <div class="autosave-indicator" id="autosaveIndicator">
        <div class="autosave-spinner"></div>
        <span id="autosaveText">Saving...</span>
    </div>

    <div class="main-layout">
        <!-- Side Panel - Outline (Resizable) -->
        <div class="side-panel" id="sidePanel">
            <div class="panel-resize-handle" id="panelResizeHandle"></div>
            <div class="panel-tabs">
                <div class="panel-tab" onclick="switchTab('file')" id="tabFile">üìÑ File</div>
                <div class="panel-tab active" onclick="switchTab('outline')" id="tabOutline">üìã Outline</div>
                <div class="panel-tab" onclick="switchTab('stats')" id="tabStats">üìä Stats</div>
            </div>

            <!-- File Panel - Simple file info -->
            <div class="panel-content" id="filePanel">
                <div style="padding: 16px;">
                    <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 16px; margin-bottom: 12px;">
                        <div style="font-size: 0.75em; color: var(--text-muted); margin-bottom: 4px;">üìÑ Current File</div>
                        <div id="currentFileName" style="font-size: 1.1em; font-weight: 600; color: var(--text-primary); word-break: break-all;">No file opened</div>
                    </div>

                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <button onclick="openProject()" style="padding: 10px 16px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 8px;">
                            <span>üìÇ</span> Open File
                        </button>
                        <button onclick="cloudSave()" style="padding: 10px 16px; background: var(--bg-hover); color: var(--text-primary); border: 1px solid var(--border-subtle); border-radius: 6px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 8px;">
                            <span>üíæ</span> Save File
                        </button>
                        <button onclick="newFile()" style="padding: 10px 16px; background: var(--bg-hover); color: var(--text-primary); border: 1px solid var(--border-subtle); border-radius: 6px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; gap: 8px;">
                            <span>‚ú®</span> New File
                        </button>
                    </div>

                    <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-subtle);">
                        <div style="font-size: 0.75em; color: var(--text-muted); margin-bottom: 8px;">üìä Quick Stats</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.85em;">
                            <div style="background: var(--bg-tertiary); padding: 8px; border-radius: 4px; text-align: center;">
                                <div style="font-size: 1.2em; font-weight: 600;" id="fileNodeCount">0</div>
                                <div style="color: var(--text-muted); font-size: 0.8em;">Nodes</div>
                            </div>
                            <div style="background: var(--bg-tertiary); padding: 8px; border-radius: 4px; text-align: center;">
                                <div style="font-size: 1.2em; font-weight: 600;" id="fileWordCount">0</div>
                                <div style="color: var(--text-muted); font-size: 0.8em;">Words</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- END File Panel -->

            <!-- Outline Panel - Separate from Projects -->
            <div class="panel-content active-panel" id="outlinePanel">
                <div class="outline-toolbar" style="display:flex; gap:4px; padding:8px; background:var(--bg-tertiary); border-bottom:1px solid var(--border-subtle); flex-wrap:wrap;">
                    <button onclick="collapseAll()" title="Collapse All" style="padding:4px 8px; font-size:0.75em; background:var(--bg-hover); color:var(--text-secondary); border:none; border-radius:4px; cursor:pointer;">‚ñ∂ All</button>
                    <button onclick="expandAll()" title="Expand All" style="padding:4px 8px; font-size:0.75em; background:var(--bg-hover); color:var(--text-secondary); border:none; border-radius:4px; cursor:pointer;">‚ñº All</button>
                    <button onclick="collapseToLevel(1)" title="Level 1" style="padding:4px 8px; font-size:0.75em; background:var(--bg-hover); color:var(--text-secondary); border:none; border-radius:4px; cursor:pointer;">L1</button>
                    <button onclick="collapseToLevel(2)" title="Level 2" style="padding:4px 8px; font-size:0.75em; background:var(--bg-hover); color:var(--text-secondary); border:none; border-radius:4px; cursor:pointer;">L2</button>
                    <button onclick="collapseToLevel(3)" title="Level 3" style="padding:4px 8px; font-size:0.75em; background:var(--bg-hover); color:var(--text-secondary); border:none; border-radius:4px; cursor:pointer;">L3</button>
                </div>
                <div id="outlineTree" style="flex:1; overflow-y:auto;"></div>
            </div>
            <!-- END Outline Panel -->

            <!-- Stats Panel - Separate from Others -->
            <div class="panel-content" id="statsPanel">
                <div id="statsContent" style="overflow-y:auto; flex:1;"></div>
            </div>
            <!-- END Stats Panel -->
        </div>

        <!-- Timeline Bar (Fixed Top Panel) -->
        <div id="timelineBar" class="timeline-bar-container" style="display:none;">
            <div class="timeline-bar-header" style="flex-shrink:0;">
                <span style="font-weight:600; font-size:12px; color:#fff;">üìä Timeline</span>
                <div style="display:flex; gap:6px; align-items:center; margin-left:15px;">
                    <button onclick="setTimelineBarScale('hour')" class="tl-scale-btn" data-scale="hour">Saat</button>
                    <button onclick="setTimelineBarScale('day')" class="tl-scale-btn active" data-scale="day">G√ºn</button>
                    <button onclick="setTimelineBarScale('week')" class="tl-scale-btn" data-scale="week">Hafta</button>
                    <button onclick="setTimelineBarScale('month')" class="tl-scale-btn" data-scale="month">Ay</button>
                    <button onclick="refreshMainTimeline()" class="save-btn" style="margin-left:10px; padding:6px 14px; font-size:12px;" title="Timeline'ƒ± yenile">üîÑ Uygula Deƒüi≈üiklikleri</button>
                </div>
                <div style="display:flex; gap:5px; align-items:center; margin-left:auto;">
                    <button onclick="timelineBarZoom(-1)" class="tl-zoom-btn" title="K√º√ß√ºlt">‚àí</button>
                    <span id="timelineBarZoomLabel" style="font-size:11px; min-width:35px; text-align:center; color:#fff;">100%</span>
                    <button onclick="timelineBarZoom(1)" class="tl-zoom-btn" title="B√ºy√ºt">+</button>
                    <button onclick="toggleTimelineBar()" class="tl-zoom-btn" title="Kapat" style="margin-left:10px;">√ó</button>
                </div>
            </div>
            <div class="timeline-bar-content" id="timelineBarContent">
                <!-- Timeline lanes rendered here -->
            </div>
            <div class="timeline-bar-ruler" id="timelineBarRuler">
                <!-- Time ruler rendered here -->
            </div>
            <div class="timeline-resize-handle" title="S√ºr√ºkle ve boyutlandƒ±r">‚ãØ</div>
        </div>

        <!-- Canvas -->
        <div class="canvas-container" id="canvasContainer">
            <svg id="connections">
                <defs>
                    <marker id="arrowhead" markerWidth="6" markerHeight="5" refX="5" refY="2.5" orient="auto">
                        <polygon points="0 0, 6 2.5, 0 5" class="connection-arrow"/>
                    </marker>
                    <marker id="arrowhead-reverse" markerWidth="6" markerHeight="5" refX="1" refY="2.5" orient="auto-start-reverse">
                        <polygon points="6 0, 0 2.5, 6 5" class="connection-arrow"/>
                    </marker>
                </defs>
            </svg>
            <div id="canvas"></div>
        </div>

        <!-- Connection Menu REMOVED - drag to disconnect instead -->

        <!-- Properties Panel (Right Side) -->
        <div class="properties-panel" id="propertiesPanel">
            <div class="properties-header">
                <span class="properties-title">üìã Properties</span>
                <button class="properties-close" onclick="togglePropertiesPanel()" title="Close Panel">√ó</button>
            </div>
            <div class="properties-content" id="propertiesContent">
                <div class="properties-empty">
                    <span style="font-size:2em; opacity:0.3;">üìÑ</span>
                    <p>Select a card to view and edit its properties</p>
                </div>
            </div>
        </div>

        <!-- Zoom Controls - fixed position -->
        <div class="zoom-controls" id="zoomControls">
            <button onclick="zoomOut()">‚àí</button>
            <span id="zoomLevel">100%</span>
            <button onclick="zoomIn()">+</button>
            <button onclick="resetZoom()">‚Ü∫</button>
            <button onclick="fitToScreen()">‚ä°</button>
        </div>
    </div>

    <!-- Modern Add Menu - Notion Style -->
    <div class="context-menu" id="addMenu">
        <div class="context-menu-header">üìÑ Basic</div>
        <div class="context-menu-item" onclick="addNode('section'); hideAllMenus();">
            <span class="item-icon">üìÑ</span> Section
            <span class="item-shortcut">‚åòN</span>
        </div>
        <div class="context-menu-item" onclick="addNode('group'); hideAllMenus();">
            <span class="item-icon">üìÅ</span> Group / Folder
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-header">üìù Content Types</div>
        <div class="context-menu-item" onclick="addNode('note'); hideAllMenus();">
            <span class="item-icon">üìù</span> Note
        </div>
        <div class="context-menu-item" onclick="addNode('draft'); hideAllMenus();">
            <span class="item-icon">‚úèÔ∏è</span> Draft
        </div>
        <div class="context-menu-item" onclick="addNode('research'); hideAllMenus();">
            <span class="item-icon">üî¨</span> Research
        </div>
        <div class="context-menu-item" onclick="addNode('reference'); hideAllMenus();">
            <span class="item-icon">üìö</span> Reference
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-header">üìë Structure</div>
        <div class="context-menu-item" onclick="addNode('abstract'); hideAllMenus();">
            <span class="item-icon">üìã</span> Abstract
        </div>
        <div class="context-menu-item" onclick="addNode('introduction'); hideAllMenus();">
            <span class="item-icon">üé¨</span> Introduction
        </div>
        <div class="context-menu-item" onclick="addNode('conclusion'); hideAllMenus();">
            <span class="item-icon">üèÅ</span> Conclusion
        </div>
        <div class="context-menu-item" onclick="addNode('appendix'); hideAllMenus();">
            <span class="item-icon">üìé</span> Appendix
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="hideAllMenus(); showAddTaskMenu(event);">
            <span class="item-icon">üìã</span> Task Ekle...
        </div>
    </div>

    <!-- Add Task Menu - Dynamic with custom types -->
    <div class="context-menu" id="addTaskMenu">
        <div class="context-menu-header">üìã Task Tipi Se√ßin</div>
        <div id="taskTypeList">
            <!-- Will be populated dynamically -->
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="openTaskTypeManager(); hideAllMenus();">
            <span class="item-icon">‚öôÔ∏è</span> Tipleri Y√∂net...
        </div>
    </div>

    <!-- Right Click Menu -->
    <div class="context-menu" id="nodeMenu">
        <div class="context-menu-item" onclick="openFullEditor()">‚úèÔ∏è Edit Full Text</div>
        <div class="context-menu-item" onclick="duplicateNode()">üìã Duplicate</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="hideAllMenus(); deleteSelected()" style="color:#e94560;">üóëÔ∏è Delete</div>
    </div>

    <!-- Task Node Right Click Menu -->
    <div class="context-menu" id="taskNodeMenu">
        <div class="context-menu-item" onclick="openTaskNodeEditor()">üìù Task'ƒ± D√ºzenle</div>
        <div class="context-menu-item" onclick="toggleTaskStatus('complete')">‚úÖ Tamamlandƒ± ƒ∞≈üaretle</div>
        <div class="context-menu-item" onclick="toggleTaskStatus('working')">üîß √úzerinde √áalƒ±≈üƒ±lƒ±yor</div>
        <div class="context-menu-item" onclick="toggleTaskStatus('urgent')">üö® Acil ƒ∞≈üaretle</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="duplicateNode()">üìã Kopyala</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="hideAllMenus(); deleteSelected()" style="color:#e94560;">üóëÔ∏è Sil</div>
    </div>

    <!-- Layout Menu Modal -->
    <div class="layout-modal" id="layoutModal" onclick="if(event.target===this)closeLayoutMenu()">
        <div class="layout-modal-content">
            <div class="layout-modal-header">
                <h3>üìê Layout Mode</h3>
                <button onclick="closeLayoutMenu()" class="layout-close-btn">‚úï</button>
            </div>
            <div class="layout-grid">
                <div class="layout-option" onclick="applyLayout('tree')">
                    <div class="layout-preview layout-tree">
                        <div class="lp-node lp-root"></div>
                        <div class="lp-line lp-v1"></div>
                        <div class="lp-line lp-h1"></div>
                        <div class="lp-node lp-c1"></div>
                        <div class="lp-node lp-c2"></div>
                        <div class="lp-node lp-c3"></div>
                    </div>
                    <span>Tree Layout</span>
                </div>
                <div class="layout-option" onclick="applyLayout('freeform')">
                    <div class="layout-preview layout-free">
                        <div class="lp-node" style="top:10%;left:20%"></div>
                        <div class="lp-node" style="top:60%;left:10%"></div>
                        <div class="lp-node" style="top:30%;left:60%"></div>
                        <div class="lp-node" style="top:70%;left:70%"></div>
                        <div class="lp-node" style="top:20%;left:40%"></div>
                    </div>
                    <span>Free Form</span>
                </div>
                <div class="layout-option" onclick="applyLayout('horizontal')">
                    <div class="layout-preview layout-horz">
                        <div class="lp-node" style="top:40%;left:5%"></div>
                        <div class="lp-node" style="top:40%;left:28%"></div>
                        <div class="lp-node" style="top:40%;left:51%"></div>
                        <div class="lp-node" style="top:40%;left:74%"></div>
                        <div class="lp-hline"></div>
                    </div>
                    <span>Horizontal</span>
                </div>
                <div class="layout-option" onclick="applyLayout('vertical')">
                    <div class="layout-preview layout-vert">
                        <div class="lp-node" style="top:5%;left:40%"></div>
                        <div class="lp-node" style="top:28%;left:40%"></div>
                        <div class="lp-node" style="top:51%;left:40%"></div>
                        <div class="lp-node" style="top:74%;left:40%"></div>
                        <div class="lp-vline"></div>
                    </div>
                    <span>Vertical</span>
                </div>
                <div class="layout-option" onclick="applyLayout('grid')">
                    <div class="layout-preview layout-grid-p">
                        <div class="lp-node" style="top:15%;left:15%"></div>
                        <div class="lp-node" style="top:15%;left:55%"></div>
                        <div class="lp-node" style="top:55%;left:15%"></div>
                        <div class="lp-node" style="top:55%;left:55%"></div>
                    </div>
                    <span>Grid Layout</span>
                </div>
                <div class="layout-option" onclick="applyLayout('radial')">
                    <div class="layout-preview layout-radial">
                        <div class="lp-node lp-center"></div>
                        <div class="lp-node" style="top:5%;left:42%"></div>
                        <div class="lp-node" style="top:75%;left:42%"></div>
                        <div class="lp-node" style="top:40%;left:5%"></div>
                        <div class="lp-node" style="top:40%;left:75%"></div>
                        <div class="lp-circle"></div>
                    </div>
                    <span>Radial</span>
                </div>
                <div class="layout-option" onclick="applyLayout('timeline')">
                    <div class="layout-preview layout-time">
                        <div class="lp-timeline"></div>
                        <div class="lp-node" style="top:20%;left:10%"></div>
                        <div class="lp-node" style="top:60%;left:30%"></div>
                        <div class="lp-node" style="top:20%;left:50%"></div>
                        <div class="lp-node" style="top:60%;left:70%"></div>
                    </div>
                    <span>Timeline</span>
                </div>
                <div class="layout-option" onclick="applyLayout('mindmap')">
                    <div class="layout-preview layout-mind">
                        <div class="lp-node lp-center"></div>
                        <div class="lp-node" style="top:15%;left:60%"></div>
                        <div class="lp-node" style="top:45%;left:70%"></div>
                        <div class="lp-node" style="top:75%;left:60%"></div>
                        <div class="lp-node" style="top:15%;left:10%"></div>
                        <div class="lp-node" style="top:75%;left:10%"></div>
                        <div class="lp-mline1"></div>
                        <div class="lp-mline2"></div>
                    </div>
                    <span>Mind Map</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Full Text Editor Modal -->
    <div class="modal" id="editorModal">
        <!-- Focus Mode Toolbar -->
        <div class="focus-toolbar" id="focusToolbar">
            <button onclick="focusZoomOut()" title="Zoom Out">üîç‚àí</button>
            <span id="focusZoomLevel" onclick="focusZoomReset()" style="cursor:pointer;" title="Click to reset to 100%">100%</span>
            <button onclick="focusZoomIn()" title="Zoom In">üîç+</button>
            <span style="color:#aaa; margin:0 10px;">|</span>
            <span style="color:#888; font-size:12px;">Width:</span>
            <input type="range" id="focusWidthSlider" min="50" max="100" value="80"
                   onchange="setFocusWidth(this.value)" oninput="setFocusWidth(this.value)"
                   style="width:80px; cursor:pointer; accent-color:#6366f1;" title="Page Width">
            <span id="focusWidthLabel" style="color:#fff; font-size:12px; min-width:35px;">80%</span>
            <span style="color:#aaa; margin:0 10px;">|</span>
            <button onclick="toggleFocusFindBar()" title="Find & Replace">üîç</button>
            <button onclick="toggleFocusDarkMode()" id="focusDarkBtn" title="Toggle Theme">üåô</button>
            <button onclick="toggleFocusMode()" style="background:#e94560; font-weight:bold; padding:8px 16px;" title="Exit Focus Mode">‚úï Exit</button>
        </div>
        <!-- Focus Mode Find Panel (Modal) -->
        <div class="focus-find-panel" id="focusFindPanel">
            <div class="focus-find-header">
                <span>üîç Find & Replace</span>
                <button onclick="toggleFocusFindBar()" class="focus-find-close">‚úï</button>
            </div>
            <div class="focus-find-body">
                <div class="focus-find-row">
                    <label>Find:</label>
                    <input type="text" id="focusFindInput" placeholder="Text to find..." onkeyup="if(event.key==='Enter')focusFindText()">
                    <button onclick="focusFindText()" class="focus-find-btn">Find</button>
                </div>
                <div class="focus-find-row">
                    <label>Replace:</label>
                    <input type="text" id="focusReplaceInput" placeholder="New text...">
                    <button onclick="focusReplaceText()" class="focus-find-btn focus-replace-btn">Replace</button>
                </div>
                <div class="focus-find-options">
                    <label class="focus-find-checkbox">
                        <input type="checkbox" id="focusMatchCase" onchange="focusFindText()">
                        <span>Match Case</span>
                    </label>
                    <label class="focus-find-checkbox">
                        <input type="checkbox" id="focusWholeWord" onchange="focusFindText()">
                        <span>Whole Word</span>
                    </label>
                </div>
                <div class="focus-find-nav">
                    <button onclick="focusFindPrev()" class="focus-nav-btn">‚óÄ Previous</button>
                    <span id="focusFindCount" class="focus-find-count">0 results</span>
                    <button onclick="focusFindNext()" class="focus-nav-btn">Next ‚ñ∂</button>
                </div>
                <div class="focus-find-actions">
                    <button onclick="focusReplaceAll()" class="focus-replace-all-btn">Replace All</button>
                </div>
                <!-- Results List -->
                <div class="focus-find-results" id="focusFindResults">
                    <div class="focus-results-header">üìç Found Results</div>
                    <div class="focus-results-list" id="focusFindResultsList"></div>
                </div>
            </div>
        </div>
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="editorTitle">‚úèÔ∏è Full Text Editor</h2>
                <button class="close-btn" onclick="closeModal('editorModal')">√ó</button>
            </div>
            <div class="modal-body" style="display:flex; gap:0;">
                <!-- Editor Left Sidebar - Tree & Attachments -->
                <div class="editor-sidebar" id="editorSidebar">
                    <div class="sidebar-section">
                        <div class="sidebar-header">üìÇ Structure</div>
                        <div class="sidebar-tree" id="editorTree"></div>
                    </div>
                    <!-- Modern Attachments Section -->
                    <div class="editor-attachments-section">
                        <div class="editor-attachments-header">
                            <h4>üìé Attachments <span class="att-count" id="attCount">0</span></h4>
                            <button class="add-attachment-btn" id="addAttachmentBtn" title="Upload file">+</button>
                            <input type="file" id="attachmentFileInput" style="display:none;" multiple accept="image/*,.pdf,.doc,.docx,.txt,.rtf">
                        </div>
                        <div class="sidebar-attachments" id="editorAttachments">
                            <div class="no-attachments">
                                <div class="empty-icon">üìÇ</div>
                                <p>No attachments yet</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="editor-section" style="flex:1;">
                    <div class="editor-toolbar">
                        <label>Type:</label>
                        <select id="editType">
                            <option value="prologue">Prologue</option>
                            <option value="chapter">Chapter</option>
                            <option value="act">Act</option>
                            <option value="plotpoint">Plot Point</option>
                            <option value="midpoint">Midpoint</option>
                            <option value="climax">Climax</option>
                            <option value="resolution">Resolution</option>
                            <option value="ending">Ending</option>
                        </select>
                        <label>Status:</label>
                        <select id="editStatus">
                            <option value="none">‚óã Yok</option>
                            <option value="draft">‚úèÔ∏è Taslak</option>
                            <option value="writing">‚úçÔ∏è Yazƒ±lƒ±yor</option>
                            <option value="review">üëÅÔ∏è ƒ∞nceleme</option>
                            <option value="revision">üîÑ Revizyon</option>
                            <option value="done">‚úÖ Tamamlandƒ±</option>
                            <option value="final">üèÜ Final</option>
                        </select>
                        <label>Title:</label>
                        <input type="text" id="editTitle" style="width:200px;">
                    </div>
                    <div class="format-toolbar">
                        <button class="format-btn" onclick="editorUndo()" title="Undo (Ctrl+Z)">‚Ü©Ô∏è</button>
                        <button class="format-btn" onclick="editorRedo()" title="Redo (Ctrl+Y)">‚Ü™Ô∏è</button>
                        <div class="format-separator"></div>
                        <button class="format-btn" id="btnBold" onmousedown="event.preventDefault()" onclick="formatText('bold')" title="Bold - Click to toggle mode"><b>B</b></button>
                        <button class="format-btn format-btn-italic" id="btnItalic" onmousedown="event.preventDefault()" onclick="formatText('italic')" title="Italic - Click to toggle mode">I</button>
                        <button class="format-btn format-btn-underline" id="btnUnderline" onmousedown="event.preventDefault()" onclick="formatText('underline')" title="Underline - Click to toggle mode">U</button>
                        <button class="format-btn" onclick="formatText('strikethrough')" title="Strikethrough"><s>S</s></button>
                        <div class="format-separator"></div>
                        <button class="format-btn highlight-btn highlight-yellow" id="btnHighlightYellow" onmousedown="event.preventDefault()" onclick="formatText('highlight')" title="Yellow Marker - Click to toggle mode">üñçÔ∏è</button>
                        <button class="format-btn highlight-btn highlight-green" id="btnHighlightGreen" onmousedown="event.preventDefault()" onclick="formatText('highlight-green')" title="Green Marker - Click to toggle mode">üñçÔ∏è</button>
                        <button class="format-btn highlight-btn highlight-blue" id="btnHighlightBlue" onmousedown="event.preventDefault()" onclick="formatText('highlight-blue')" title="Blue Marker - Click to toggle mode">üñçÔ∏è</button>
                        <button class="format-btn" onclick="clearHighlight()" title="Remove Highlight/Marker">üö´</button>
                        <div class="format-separator"></div>
                        <button class="format-btn" id="btnBullet" onmousedown="event.preventDefault()" onclick="formatText('bullet')" title="Bullet List - Click to toggle mode">‚Ä¢‚â°</button>
                        <button class="format-btn" id="btnNumber" onmousedown="event.preventDefault()" onclick="formatText('number')" title="Numbered List - Click to toggle mode">1.</button>
                        <div class="format-separator"></div>
                        <button class="format-btn" onmousedown="saveSelection()" onclick="insertImage()" title="Insert Image">üñºÔ∏è</button>
                        <button class="format-btn" onmousedown="saveSelection()" onclick="insertTable()" title="Insert Table">‚äû</button>
                        <input type="file" id="editorImageInput" accept="image/*" style="display:none;" onchange="handleEditorImageUpload(event)">
                        <div class="format-separator"></div>
                        <button class="format-btn" onmousedown="saveSelection()" onclick="showTextColorPicker()" title="Text Color" style="position:relative;">üé®</button>
                        <input type="color" id="textColorPicker" style="position:absolute; visibility:hidden; width:0; height:0;" onchange="applyTextColor(this.value)">
                        <div class="format-separator"></div>
                        <button class="format-btn" onclick="clearTextFormatting()" title="Clear All Formatting">üßπ</button>
                        <button class="format-btn comment-btn" onclick="addComment()" title="Add Comment (Ctrl+M)">üí¨</button>
                        <button class="format-btn" onclick="toggleFindReplace()" title="Find & Replace (Ctrl+H)">üîç</button>
                    </div>
                    <div class="find-replace-bar" id="findReplaceBar">
                        <input type="text" id="findInput" placeholder="Find..." onkeyup="if(event.key==='Enter')findText()">
                        <button class="find-btn" onclick="findText()">Find</button>
                        <button class="nav-btn" onclick="findPrevious()" title="Previous (Shift+F3)">‚óÄ</button>
                        <span class="find-count" id="findCount" style="min-width:60px; text-align:center; color:#aaa; font-size:0.85em;"></span>
                        <button class="nav-btn" onclick="findNext()" title="Next (F3)">‚ñ∂</button>
                        <div class="find-options">
                            <label class="find-option" title="Match Case (Match Case)">
                                <input type="checkbox" id="findMatchCase" onchange="findText()">
                                <span>Aa</span>
                            </label>
                            <label class="find-option" title="Whole Word (Whole Word)">
                                <input type="checkbox" id="findWholeWord" onchange="findText()">
                                <span>W</span>
                            </label>
                            <label class="find-option" title="Regex Kullan">
                                <input type="checkbox" id="findRegex" onchange="findText()">
                                <span>.*</span>
                            </label>
                        </div>
                        <input type="text" id="replaceInput" placeholder="Replace...">
                        <button class="replace-btn" onclick="replaceText()">Replace</button>
                        <button class="replace-all-btn" onclick="replaceAllText()">Replace All</button>
                        <button class="close-find" onclick="toggleFindReplace()">‚úï</button>
                    </div>
                    <div class="find-results-panel" id="findResultsPanel">
                        <div class="find-results-header">
                            <span>üìç Found Results</span>
                            <button onclick="closeFindResults()" style="background:none; border:none; color:#aaa; cursor:pointer;">‚úï</button>
                        </div>
                        <div id="findResultsList"></div>
                    </div>
                    <div class="revision-toolbar" id="revisionToolbar">
                        <span style="font-size:0.75em; color:#666; margin-right:5px;">üìù Revizyon:</span>
                        <div id="revisionLabels"></div>
                        <button class="add-revision-btn" onclick="showAddRevisionForm()">+ Add</button>
                        <div class="revision-form" id="revisionForm" style="display:none;">
                            <input type="text" id="newRevisionName" placeholder="Revision name...">
                            <input type="color" id="newRevisionBg" value="#BBDEFB" title="Arkaplan">
                            <input type="color" id="newRevisionText" value="#1565C0" title="Text color">
                            <button onclick="addRevisionLabel()" style="padding:4px 8px; background:#4CAF50; color:white; border:none; border-radius:4px; cursor:pointer;">‚úì</button>
                            <button onclick="hideRevisionForm()" style="padding:4px 8px; background:#eee; border:none; border-radius:4px; cursor:pointer;">‚úï</button>
                        </div>
                    </div>
                    <!-- Current Revision Mode Indicator -->
                    <div class="revision-mode-indicator" id="revisionModeIndicator">
                        ‚úèÔ∏è Writing Mode: <span id="currentRevisionName">-</span>
                    </div>
                    <!-- Font & Paragraph Toolbar -->
                    <div class="font-para-toolbar">
                        <div class="toolbar-group">
                            <label>Font:</label>
                            <select id="fontFamily" onmousedown="saveSelection()" onchange="applyFontFamily()">
                                <option value="Georgia">Georgia</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Arial">Arial</option>
                                <option value="Helvetica">Helvetica</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Trebuchet MS">Trebuchet MS</option>
                                <option value="Palatino Linotype">Palatino</option>
                            </select>
                            <button class="font-size-btn" onclick="decreaseFontSize()" title="K√º√ß√ºlt">‚àí</button>
                            <select id="fontSize" onmousedown="saveSelection()" onchange="applyFontSize()">
                                <option value="12px">12</option>
                                <option value="14px">14</option>
                                <option value="16px">16</option>
                                <option value="18px" selected>18</option>
                                <option value="20px">20</option>
                                <option value="22px">22</option>
                                <option value="24px">24</option>
                                <option value="28px">28</option>
                                <option value="32px">32</option>
                                <option value="36px">36</option>
                                <option value="48px">48</option>
                                <option value="64px">64</option>
                            </select>
                            <button class="font-size-btn" onclick="increaseFontSize()" title="B√ºy√ºt">+</button>
                        </div>
                        <div class="toolbar-group">
                            <label>Line:</label>
                            <select id="lineHeight" onchange="applyLineHeight()">
                                <option value="1.4">1.4</option>
                                <option value="1.6">1.6</option>
                                <option value="1.8" selected>1.8</option>
                                <option value="2.0">2.0</option>
                                <option value="2.5">2.5</option>
                            </select>
                        </div>
                        <div class="toolbar-group">
                            <label>Hiza:</label>
                            <button class="para-btn" onclick="setAlignment('left')" title="Sola">‚¨Ö</button>
                            <button class="para-btn" onclick="setAlignment('center')" title="Ortala">‚¨å</button>
                            <button class="para-btn" onclick="setAlignment('right')" title="Align Right">‚û°</button>
                            <button class="para-btn" onclick="setAlignment('justify')" title="Justify">‚ò∞</button>
                        </div>
                        <div class="toolbar-group">
                            <label>Girinti:</label>
                            <button class="para-btn" onclick="adjustIndent(-20)" title="Girintiyi Azalt">‚á§</button>
                            <button class="para-btn" onclick="adjustIndent(20)" title="Increase Indent">‚á•</button>
                        </div>
                        <div class="toolbar-group">
                            <button class="para-btn" onclick="saveFontSettings()" title="Save Settings" style="background:#4CAF50; color:white;">üíæ</button>
                            <button class="para-btn" onclick="toggleCommentsPanel()" title="Show Comments" style="background:#fff3cd;">üí¨</button>
                            <button class="para-btn" onclick="toggleEditorSnapshotPanel()" title="Snapshots" style="background:#009688; color:white;">üì∏</button>
                        </div>
                        <div class="toolbar-group" style="border-left:1px solid #ddd; padding-left:10px; margin-left:5px;">
                            <button class="para-btn" onclick="editorZoomOut()" title="Zoom Out">üîç‚àí</button>
                            <span id="editorZoomLevel" onclick="editorZoomReset()" style="font-size:0.8em; min-width:40px; text-align:center; cursor:pointer;" title="Click to reset to 100%">100%</span>
                            <button class="para-btn" onclick="editorZoomIn()" title="Zoom In">üîç+</button>
                        </div>
                        <div class="toolbar-group" style="border-left:1px solid #ddd; padding-left:10px; margin-left:5px;">
                            <button class="para-btn" id="darkModeBtn" onclick="toggleEditorDarkMode()" title="Light Mode" style="background:#333; color:#fff;">‚òÄÔ∏è</button>
                            <button class="para-btn" id="focusModeBtn" onclick="toggleFocusMode()" title="Odak Modu" style="background:#6366f1; color:#fff;">üéØ</button>
                        </div>
                    </div>
                    <!-- Comments Panel -->
                    <div class="comments-panel" id="commentsPanel">
                        <div class="comments-panel-header">
                            <span>üí¨ Comments (<span id="commentCount">0</span>)</span>
                            <button onclick="toggleCommentsPanel()" style="background:none; border:none; cursor:pointer;">‚úï</button>
                        </div>
                        <div id="commentsList"></div>
                    </div>
                    <!-- Snapshot Panel (Scrivener style) -->
                    <div class="editor-snapshot-panel" id="editorSnapshotPanel">
                        <div class="editor-snapshot-header">
                            <h4>üì∏ Snapshots</h4>
                            <button onclick="toggleEditorSnapshotPanel()">‚úï</button>
                        </div>
                        <div class="editor-snapshot-actions">
                            <input type="text" id="editorSnapshotName" placeholder="Snapshot name...">
                            <button onclick="takeEditorSnapshot()">üì∏ Take</button>
                        </div>
                        <div class="editor-snapshot-list" id="editorSnapshotList"></div>
                    </div>
                    <!-- MS Word Style Ruler -->
                    <div class="editor-ruler" id="editorRuler">
                        <div class="ruler-track"></div>
                        <div class="ruler-numbers" id="rulerNumbers"></div>
                        <div class="ruler-markers">
                            <div class="ruler-indent-left" id="rulerIndentLeft" title="First Line Indent"></div>
                            <div class="ruler-indent-hanging" id="rulerIndentHanging" title="Left Margin"></div>
                            <div class="ruler-indent-right" id="rulerIndentRight" title="Right Margin"></div>
                        </div>
                    </div>
                    <div class="text-editor-wrapper" id="textEditorWrapper">
                        <!-- Quill Editor Container -->
                        <div id="quillEditorContainer">
                            <div id="fullTextEditor"></div>
                        </div>
                    </div>
                    <div class="editor-footer">
                        <div class="word-stats">
                            <span>Words: <strong id="editorWordCount">0</strong></span>
                            <span>Characters: <strong id="editorCharCount">0</strong></span>
                            <span>Paragraphs: <strong id="editorParaCount">0</strong></span>
                        </div>
                        <span style="color:#888;">Auto-saved</span>
                    </div>
                </div>
                <div class="meta-section">
                    <div class="meta-group">
                        <label>Author</label>
                        <select id="editPov"></select>
                    </div>
                    <div class="meta-group">
                        <label>Summary (visible on cards)</label>
                        <textarea id="editSummary" placeholder="Brief summary..."></textarea>
                    </div>
                    <div class="meta-group">
                        <label>Tags</label>
                        <div class="desc-list" id="editDescList"></div>
                        <div class="add-desc-form">
                            <select id="newDescType"></select>
                            <input type="text" id="newDescValue" placeholder="Value...">
                            <button onclick="addDescToEdit()">+</button>
                        </div>
                    </div>
                    <div class="meta-group">
                        <label>Target Word Count</label>
                        <input type="number" id="editTarget" placeholder="e.g. 2500" min="0" step="100">
                        <div style="margin-top:5px; font-size:0.75em; color:#888;">
                            Progress: <strong id="editProgress">0%</strong>
                        </div>
                    </div>
                    <div class="meta-group">
                        <label>Notes</label>
                        <textarea id="editNotes" placeholder="Personal notes..."></textarea>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button class="btn-cancel" onclick="closeModal('editorModal')">Cancel</button>
                <button class="btn-save" onclick="saveFullEdit()">üíæ Save</button>
            </div>
        </div>
    </div>

    <!-- POV Manager Modal -->
    <div class="modal manager-modal" id="povManagerModal">
        <div class="modal-content" style="background:#2d2d3d; color:#e0e0e0;">
            <div class="modal-header" style="background:#1a1a2e; border-bottom:2px solid #e94560;">
                <h2 style="color:#fff;">üë§ Author Manager</h2>
                <button class="close-btn" onclick="closeModal('povManagerModal')" style="background:#555; color:#fff;">√ó</button>
            </div>
            <div style="padding: 20px;">
                <div class="manager-list" id="povManagerList"></div>
                <div class="manager-form" id="povForm" style="background:#3a3a4a; padding:20px; border-radius:10px; margin-top:15px;">
                    <h3 id="povFormTitle" style="color:#fff; margin-bottom:15px;">Add New Author</h3>
                    <div class="form-row" style="display:flex; gap:10px;">
                        <div class="form-group" style="flex:1;">
                            <label style="color:#aaa;">Author Name</label>
                            <input type="text" id="povNameInput" placeholder="e.g. John Smith" style="background:#2d2d3d; border:1px solid #555; color:#fff; padding:12px; border-radius:6px; width:100%;">
                        </div>
                        <div class="form-group" style="flex:0 0 80px;">
                            <label style="color:#aaa;">Color</label>
                            <input type="color" id="povColorInput" value="#e94560" style="height:44px; border-radius:6px; width:100%;">
                        </div>
                    </div>
                    <div class="form-group" style="margin-top:10px;">
                        <label style="color:#aaa;">Description</label>
                        <input type="text" id="povDescInput" placeholder="Short description..." style="background:#2d2d3d; border:1px solid #555; color:#fff; padding:12px; border-radius:6px; width:100%;">
                    </div>
                    <button class="btn-save" onclick="savePov()" style="width:100%; margin-top:15px; padding:14px; font-size:1em; border-radius:8px;">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Desc Type Manager Modal -->
    <div class="modal manager-modal" id="descManagerModal" style="z-index:3000;">
        <div class="modal-content" style="background:#2d2d3d; color:#e0e0e0; max-width:550px;">
            <div class="modal-header" style="background:#1a1a2e; border-bottom:2px solid #e94560;">
                <h2 style="color:#fff;">üìù Tag Types</h2>
                <button class="close-btn" onclick="closeModal('descManagerModal')" style="background:#555; color:#fff;">√ó</button>
            </div>
            <div style="padding: 20px;">
                <div class="manager-list" id="descManagerList"></div>
                <div class="manager-form" id="descForm" style="background:#3a3a4a; padding:20px; border-radius:10px; margin-top:15px;">
                    <h3 id="descFormTitle" style="color:#fff; margin-bottom:15px;">Add New Type</h3>
                    <div class="form-row" style="display:flex; gap:10px; flex-wrap:wrap;">
                        <div class="form-group" style="flex:1; min-width:120px;">
                            <label style="color:#aaa;">Type Name</label>
                            <input type="text" id="descNameInput" placeholder="e.g. Location" style="background:#2d2d3d; border:1px solid #555; color:#fff; padding:12px; border-radius:6px; width:100%;">
                        </div>
                        <div class="form-group" style="flex:0 0 130px;">
                            <label style="color:#aaa;">Icon</label>
                            <select id="descIconInput" style="background:#2d2d3d; border:1px solid #555; color:#fff; padding:12px; border-radius:6px; width:100%;">
                                <option value="üè†">üè† Location</option>
                                <option value="üë§">üë§ Character</option>
                                <option value="‚è∞">‚è∞ Time</option>
                                <option value="üå§Ô∏è">üå§Ô∏è Atmosphere</option>
                                <option value="üîë">üîë Object</option>
                                <option value="üí≠">üí≠ Emotion</option>
                                <option value="üéµ">üéµ Sound</option>
                                <option value="üìå">üìå Note</option>
                            </select>
                        </div>
                        <div class="form-group" style="flex:0 0 80px;">
                            <label style="color:#aaa;">Color</label>
                            <input type="color" id="descColorInput" value="#FF5722" style="height:44px; border-radius:6px; width:100%;">
                        </div>
                    </div>
                    <button class="btn-save" onclick="saveDescType()" style="width:100%; margin-top:15px; padding:14px; font-size:1em; border-radius:8px;">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Node Type (Legend) Manager Modal -->
    <div class="modal manager-modal" id="nodeTypeManagerModal" style="z-index:3500;">
        <div class="modal-content" style="max-width:600px; background:#2d2d3d; color:#e0e0e0;">
            <div class="modal-header" style="background:#1a1a2e; border-bottom:2px solid #e94560;">
                <h2 style="color:#fff;">üìÅ Section Types (Legend)</h2>
                <button class="close-btn" onclick="closeModal('nodeTypeManagerModal')" style="background:#555; color:#fff;">√ó</button>
            </div>
            <div style="padding: 20px;">
                <div class="manager-list" id="nodeTypeManagerList" style="max-height:300px; overflow-y:auto;"></div>
                <div class="manager-form" id="nodeTypeForm" style="margin-top:15px; padding-top:15px; border-top:1px solid #555;">
                    <h3 id="nodeTypeFormTitle" style="margin:0 0 15px 0; color:#e94560;">‚ûï Add New Type</h3>
                    <div class="form-row" style="display:flex; gap:10px; flex-wrap:wrap;">
                        <div class="form-group" style="flex:1; min-width:150px;">
                            <label style="color:#aaa;">Type ID (lowercase)</label>
                            <input type="text" id="nodeTypeIdInput" placeholder="e.g. flashback" style="text-transform:lowercase; background:#3a3a4a; border:1px solid #555; color:#fff; padding:14px 12px; border-radius:8px; font-size:14px; height:48px;">
                        </div>
                        <div class="form-group" style="flex:1; min-width:150px;">
                            <label style="color:#aaa;">Display Name</label>
                            <input type="text" id="nodeTypeNameInput" placeholder="e.g. Flashback" style="background:#3a3a4a; border:1px solid #555; color:#fff; padding:14px 12px; border-radius:8px; font-size:14px; height:48px;">
                        </div>
                    </div>
                    <div class="form-row" style="display:flex; gap:10px; margin-top:10px;">
                        <div class="form-group" style="flex:0 0 80px;">
                            <label style="color:#aaa;">Emoji</label>
                            <input type="text" id="nodeTypeEmojiInput" placeholder="‚è™" maxlength="2" style="font-size:1.5em; text-align:center; background:#3a3a4a; border:1px solid #555; color:#fff; padding:8px; border-radius:8px; height:48px;">
                        </div>
                        <div class="form-group" style="flex:0 0 80px;">
                            <label style="color:#aaa;">Color</label>
                            <input type="color" id="nodeTypeColorInput" value="#9C27B0" style="height:48px; border-radius:8px; width:100%;">
                        </div>
                        <div class="form-group" style="flex:0 0 80px;">
                            <label style="color:#aaa;">Text</label>
                            <input type="color" id="nodeTypeTextColorInput" value="#ffffff" title="Text color" style="height:48px; border-radius:8px; width:100%;">
                        </div>
                        <div class="form-group" style="flex:1;">
                            <label style="color:#aaa;">Prefix (for Compile)</label>
                            <input type="text" id="nodeTypePrefixInput" placeholder="e.g. FLASHBACK:" style="background:#3a3a4a; border:1px solid #555; color:#fff; padding:14px 12px; border-radius:8px; font-size:14px; height:48px;">
                        </div>
                    </div>
                    <div style="display:flex; gap:10px; margin-top:15px;">
                        <button class="btn-save" onclick="saveNodeType()" style="flex:1; padding:14px; font-size:1em; border-radius:8px;">üíæ Save</button>
                        <button class="btn-gray" onclick="closeLegendManager()" style="flex:0 0 100px; padding:14px; border-radius:8px;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content settings-modal-content">
            <div class="modal-header">
                <h2>‚öôÔ∏è Settings</h2>
                <button class="close-btn" onclick="closeModal('settingsModal')">√ó</button>
            </div>
            <div class="settings-body">
                <div class="settings-grid">
                    <!-- Left Column -->
                    <div class="settings-column">
                        <h4 class="settings-section-title">üíæ Auto-Save</h4>
                        <div class="meta-group">
                            <label>Interval</label>
                            <select id="autoSaveInterval" onchange="updateAutoSaveInterval()">
                                <option value="30000">30 seconds</option>
                                <option value="60000">1 minute</option>
                                <option value="120000">2 minutes</option>
                                <option value="180000">3 minutes</option>
                                <option value="300000" selected>5 minutes</option>
                                <option value="600000">10 minutes</option>
                                <option value="0">Disabled</option>
                            </select>
                        </div>
                        <div class="meta-group">
                            <label class="settings-checkbox-label">
                                <input type="checkbox" id="settingsAutoBackup" checked>
                                <span>Daily automatic backup</span>
                            </label>
                        </div>

                        <h4 class="settings-section-title">üé® Appearance</h4>
                        <div class="meta-group">
                            <label>Theme</label>
                            <select id="settingsTheme" onchange="applyThemeFromSettings()">
                                <option value="dark">Dark</option>
                                <option value="light">Light</option>
                            </select>
                        </div>
                        <div class="meta-group">
                            <label>Card Size</label>
                            <select id="settingsCardSize">
                                <option value="small">Small</option>
                                <option value="medium" selected>Medium</option>
                                <option value="large">Large</option>
                            </select>
                        </div>

                        <h4 class="settings-section-title">üè∑Ô∏è Types</h4>
                        <button onclick="openLegendManagerFromSettings()" class="settings-btn">üè∑Ô∏è Legend Manager</button>
                    </div>

                    <!-- Right Column -->
                    <div class="settings-column">
                        <h4 class="settings-section-title">‚úèÔ∏è Editor</h4>
                        <div class="meta-group">
                            <label>Default Font</label>
                            <select id="settingsFontFamily">
                                <option value="Georgia">Georgia</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Arial">Arial</option>
                                <option value="Helvetica">Helvetica</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Palatino">Palatino</option>
                            </select>
                        </div>
                        <div class="meta-group">
                            <label>Default Font Size</label>
                            <select id="settingsFontSize">
                                <option value="14px">14px</option>
                                <option value="16px" selected>16px</option>
                                <option value="18px">18px</option>
                                <option value="20px">20px</option>
                                <option value="22px">22px</option>
                            </select>
                        </div>
                        <div class="meta-group">
                            <label>Line Spacing</label>
                            <select id="settingsLineHeight">
                                <option value="1.5">1.5</option>
                                <option value="1.8" selected>1.8</option>
                                <option value="2.0">2.0</option>
                                <option value="2.2">2.2</option>
                            </select>
                        </div>
                        <div class="meta-group">
                            <label class="settings-checkbox-label">
                                <input type="checkbox" id="settingsSpellCheck">
                                <span>Spell check</span>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="settings-footer">
                    <button class="btn-secondary" onclick="closeModal('settingsModal')">Cancel</button>
                    <button class="btn-secondary" onclick="resetSettings()">Reset</button>
                    <button class="btn-primary" onclick="saveAllSettings()">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Manager Modal - Full Page Layout -->
    <div class="modal" id="taskManagerModal">
        <div class="modal-content" style="max-width:100%; width:100%; height:100vh; background:#1a1a2e; color:#e0e0e0; margin:0; border-radius:0; display:flex; flex-direction:column;">
            <div class="modal-header" style="background:#0f0f1a; border-bottom:2px solid #8b5cf6; padding:12px 20px;">
                <h2 style="color:#fff;">üìã Task Manager</h2>
                <div style="display:flex; gap:10px; align-items:center;">
                    <div style="position:relative;">
                        <button id="newTaskDropdownBtn" onclick="toggleNewTaskDropdown()" style="background:linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color:#fff; border:none; padding:8px 16px; border-radius:8px; cursor:pointer; font-weight:600;">+ New Task</button>
                        <div id="newTaskDropdown" style="display:none; position:absolute; top:100%; left:0; background:#1a1a2e; border:1px solid #8b5cf6; border-radius:8px; min-width:200px; z-index:1000; margin-top:5px; box-shadow:0 4px 15px rgba(0,0,0,0.5);">
                            <!-- Dynamically populated by populateNewTaskDropdown() -->
                        </div>
                    </div>
                    <button id="applyTimelineChangesBtn" onclick="applyTimelineChanges()" style="display:none; background:linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color:#fff; border:none; padding:8px 16px; border-radius:8px; cursor:pointer; font-weight:600;">‚úì Deƒüi≈üiklikleri Uygula</button>
                    <button class="close-btn" onclick="closeModal('taskManagerModal')" style="background:#555; color:#fff;">√ó</button>
                </div>
            </div>
            <div style="padding:12px 20px; display:flex; gap:10px; flex-wrap:wrap; background:#252538; border-bottom:1px solid #333; align-items:center;">
                <button onclick="filterTasks(null)" class="task-filter-btn active" data-filter="all">All</button>
                <button onclick="filterTasks('todo')" class="task-filter-btn" data-filter="todo">üìã To Do</button>
                <button onclick="filterTasks('ongoing')" class="task-filter-btn" data-filter="ongoing">üîÑ On Going</button>
                <button onclick="filterTasks('working')" class="task-filter-btn" data-filter="working">üîß Working</button>
                <button onclick="filterTasks('urgent')" class="task-filter-btn" data-filter="urgent">üî¥ Urgent</button>
                <button onclick="filterTasks('complete')" class="task-filter-btn" data-filter="complete">‚úÖ Complete</button>
                <button onclick="filterTasks('dontforget')" class="task-filter-btn" data-filter="dontforget">üíú Don't Forget</button>
                <span style="flex:1;"></span>
                <div style="display:flex; gap:8px; align-items:center;">
                    <button onclick="toggleTaskView('list')" class="task-view-btn active" data-view="list" title="Liste G√∂r√ºn√ºm√º">üìã</button>
                    <button onclick="toggleTaskView('timeline')" class="task-view-btn" data-view="timeline" title="Zaman √áizelgesi">üìä</button>
                </div>
            </div>
            <!-- Timeline Scale Bar (shown when timeline view active) -->
            <div id="taskTimelineScaleBar" style="display:none; padding:8px 20px; background:linear-gradient(90deg, #8b5cf6 0%, #7c3aed 100%); border-bottom:1px solid #333; align-items:center; gap:15px;">
                <span style="color:#fff; font-size:12px; font-weight:600;">√ñl√ßek:</span>
                <button onclick="setTimelineScale('hour')" class="tl-scale-btn-white" data-scale="hour">Saat</button>
                <button onclick="setTimelineScale('day')" class="tl-scale-btn-white active" data-scale="day">G√ºn</button>
                <button onclick="setTimelineScale('week')" class="tl-scale-btn-white" data-scale="week">Hafta</button>
                <button onclick="setTimelineScale('month')" class="tl-scale-btn-white" data-scale="month">Ay</button>
                <span style="flex:1;"></span>
                <span style="color:rgba(255,255,255,0.8); font-size:11px;">Zoom:</span>
                <button onclick="timelineZoom(-1)" class="tl-zoom-btn-white">‚àí</button>
                <span id="timelineZoomLevel" style="color:#fff; font-size:12px; min-width:40px; text-align:center;">100%</span>
                <button onclick="timelineZoom(1)" class="tl-zoom-btn-white">+</button>
                <button onclick="timelineZoomFit()" class="tl-zoom-btn-white" style="margin-left:10px; padding:4px 10px;" title="T√ºm task'larƒ± g√∂ster">Fit</button>
                <button onclick="refreshTaskManagerTimeline()" class="save-btn" style="margin-left:10px; padding:6px 14px; font-size:12px;" title="Timeline'ƒ± yenile">üîÑ Uygula Deƒüi≈üiklikleri</button>
            </div>
            
            <!-- Main Content Area with Left Sidebar -->
            <div style="flex:1; display:flex; overflow:hidden;">
                <!-- Left Sidebar - Dependent Nodes -->
                <div id="taskManagerSidebar" style="width:280px; min-width:280px; background:#151525; border-right:1px solid #333; display:flex; flex-direction:column; overflow:hidden;">
                    <div style="padding:12px 15px; background:#1a1a2e; border-bottom:1px solid #333;">
                        <h3 style="margin:0; font-size:13px; color:#8b5cf6; text-transform:uppercase; letter-spacing:0.5px;">üîó Baƒülƒ± Node'lar</h3>
                    </div>
                    <div id="taskManagerNodeList" style="flex:1; overflow-y:auto; padding:10px;">
                        <!-- Node list will be rendered here -->
                    </div>
                </div>
                
                <!-- Right Content Area -->
                <div style="flex:1; display:flex; flex-direction:column; overflow:hidden;">
                    <!-- Timeline View (Hidden by default) -->
                    <div id="taskTimelineContainer" style="display:none; flex:1; overflow:hidden; flex-direction:column;">
                        <div id="taskTimelineContent" style="flex:1; overflow:auto; position:relative;">
                            <!-- Timeline will be rendered here -->
                        </div>
                    </div>
                    <div id="taskListContainer" style="flex:1; overflow-y:auto; padding:20px;">
                        <!-- Tasks will be rendered here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Editor Modal - COMPACT -->
    <div class="modal" id="taskEditorModal">
        <div class="modal-content" style="max-width:720px; min-width:600px; width:90%; background:#1a1a2e; color:#e0e0e0;">
            <div class="modal-header" style="background:#0f0f1a; border-bottom:2px solid #22c55e; padding:10px 16px;">
                <h2 style="color:#fff; font-size:1.1em;" id="taskEditorTitle">‚úèÔ∏è Edit Task</h2>
                <button class="close-btn" onclick="closeModal('taskEditorModal')" style="background:#555; color:#fff;">√ó</button>
            </div>
            <div style="padding:12px 16px; max-height:80vh; overflow-y:auto;">
                <input type="hidden" id="editingTaskId" value="">

                <!-- Task Title -->
                <div class="meta-group" style="margin-bottom:6px;">
                    <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Task Title</label>
                    <input type="text" id="taskTitle" placeholder="Enter task title..." style="width:100%; font-size:0.95em; padding:8px 10px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                </div>

                <!-- Task Description -->
                <div class="meta-group" style="margin-bottom:6px;">
                    <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Description</label>
                    <textarea id="taskDescription" placeholder="Task description..." rows="2" style="width:100%; font-size:0.9em; padding:8px 10px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px; resize:vertical;"></textarea>
                </div>

                <!-- Row 1: Status & Importance -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:6px;">
                    <div class="meta-group">
                        <label style="color:#aaa; font-size:11px; text-transform:uppercase; display:flex; justify-content:space-between; align-items:center;">
                            <span>Durum</span>
                            <button onclick="openTaskStatusManager()" style="background:#3b82f6; color:#fff; border:none; padding:3px 8px; border-radius:4px; font-size:10px; cursor:pointer; font-weight:500;">‚öôÔ∏è Y√∂net</button>
                        </label>
                        <select id="taskStatus" style="width:100%; font-size:0.9em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                            <!-- Populated dynamically by populateTaskStatusOptions() -->
                        </select>
                    </div>
                    <div class="meta-group">
                        <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Oncelik</label>
                        <select id="taskImportance" style="width:100%; font-size:0.9em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                            <option value="low">Low</option>
                            <option value="medium" selected>Medium</option>
                            <option value="high">High</option>
                            <option value="critical">Critical</option>
                        </select>
                    </div>
                </div>

                <!-- Row 2: Assigned By & Progress -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:6px;">
                    <div class="meta-group">
                        <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Atayan Kisi</label>
                        <input type="text" id="taskAssignedBy" placeholder="Your name..." style="width:100%; font-size:0.9em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                    </div>
                    <div class="meta-group">
                        <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Progress (%)</label>
                        <input type="number" id="taskProgress" min="0" max="100" value="0" style="width:100%; font-size:0.9em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                    </div>
                </div>

                <!-- Row 3: Duration (Auto-calculates End Date) -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:6px;">
                    <div class="meta-group">
                        <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Sure</label>
                        <input type="number" id="taskDuration" min="0" value="1" oninput="calculateEndDate()" style="width:100%; font-size:0.9em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                    </div>
                    <div class="meta-group">
                        <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Birim</label>
                        <select id="taskDurationType" onchange="calculateEndDate()" style="width:100%; font-size:0.9em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                            <option value="minutes">Dakika</option>
                            <option value="hours" selected>Saat</option>
                            <option value="days">Gun</option>
                            <option value="weeks">Hafta</option>
                            <option value="months">Ay</option>
                        </select>
                    </div>
                </div>

                <!-- Row 4: Dates with Time (Auto-calculate) -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:6px;">
                    <div class="meta-group">
                        <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Baslangic</label>
                        <input type="datetime-local" id="taskDateStart" oninput="calculateEndDate()" style="width:100%; font-size:0.85em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                    </div>
                    <div class="meta-group">
                        <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Bitis</label>
                        <input type="datetime-local" id="taskDateEstimated" oninput="calculateDurationFromDates()" style="width:100%; font-size:0.85em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                    </div>
                </div>

                <!-- Row 5: Assign to Node -->
                <div class="meta-group" style="margin-bottom:6px;">
                    <label style="color:#aaa; font-size:11px; text-transform:uppercase;">Bagli Node (Connection)</label>
                    <select id="taskAssignedNode" style="width:100%; font-size:0.9em; padding:8px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; margin-top:3px;">
                        <option value="">‚Äî Node Yok (Baƒüƒ±msƒ±z Task) ‚Äî</option>
                        <!-- Node options will be populated dynamically -->
                    </select>
                    <p style="color:#666; font-size:10px; margin-top:2px;">Task'ƒ± bir node'a baƒülar. Canvas'ta connection olarak g√∂r√ºn√ºr.</p>
                </div>

                <!-- Row 6: Task Dependencies (Task-to-Task) - COMPACT -->
                <div class="meta-group" style="margin-bottom:6px; padding:10px; background:linear-gradient(135deg, #1a1a2e 0%, #252540 100%); border-radius:8px; border:1px solid #8b5cf6;">
                    <label style="color:#fff; font-size:12px; font-weight:bold; display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                        <span>üîó TASK BAƒûIMLILIKLARI (Dependencies)</span>
                    </label>

                    <!-- Add New Dependency Section -->
                    <div style="display:flex; gap:6px; margin-bottom:8px; padding:8px; background:rgba(139,92,246,0.1); border-radius:6px; border:1px solid rgba(139,92,246,0.3);">
                        <select id="newDependencyTaskSelect" style="flex:1; padding:6px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; font-size:12px;">
                            <option value="">‚Äî Baƒüƒ±mlƒ± Task Se√ß ‚Äî</option>
                        </select>
                        <select id="newDependencyType" style="width:60px; padding:6px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; font-size:12px; font-weight:bold;">
                            <option value="FS">FS</option>
                            <option value="SS">SS</option>
                            <option value="FF">FF</option>
                            <option value="SF">SF</option>
                        </select>
                        <button onclick="addTaskDependencyFromSelect()" type="button" style="background:linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color:#fff; border:none; padding:6px 12px; border-radius:6px; cursor:pointer; font-size:11px; font-weight:bold; white-space:nowrap;">
                            + Baƒüƒ±mlƒ±lƒ±k Ekle
                        </button>
                    </div>

                    <!-- Dependencies List -->
                    <div id="taskDependenciesList" style="max-height:100px; overflow-y:auto; margin-bottom:6px;">
                        <!-- Dependencies will be rendered here -->
                        <p style="color:#666; font-size:11px; text-align:center; padding:8px;">Hen√ºz baƒüƒ±mlƒ±lƒ±k yok</p>
                    </div>

                    <p style="color:#888; font-size:10px; margin-top:6px; padding-top:6px; border-top:1px solid #333;">
                        <strong style="color:#22c55e;">FS:</strong> Finish-to-Start &nbsp;|&nbsp;
                        <strong style="color:#3b82f6;">SS:</strong> Start-to-Start &nbsp;|&nbsp;
                        <strong style="color:#f59e0b;">FF:</strong> Finish-to-Finish &nbsp;|&nbsp;
                        <strong style="color:#ef4444;">SF:</strong> Start-to-Finish
                    </p>
                </div>

                <!-- Save Button -->
                <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px; padding-top:10px; border-top:1px solid #333;">
                    <button onclick="closeModal('taskEditorModal')" style="background:#444; color:#fff; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; font-size:0.9em;">Cancel</button>
                    <button onclick="saveTask()" style="background:linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color:#fff; border:none; padding:8px 20px; border-radius:6px; cursor:pointer; font-size:0.9em; font-weight:600;">üíæ Save Task</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Status Manager Modal -->
    <div class="modal" id="taskStatusManagerModal">
        <div class="modal-content" style="max-width:600px; width:95%; background:#1a1a2e; color:#e0e0e0;">
            <div class="modal-header" style="background:#0f0f1a; border-bottom:2px solid #3b82f6;">
                <h2 style="color:#fff;">‚öôÔ∏è Durum Y√∂neticisi</h2>
                <button class="close-btn" onclick="closeModal('taskStatusManagerModal')" style="background:#555; color:#fff;">√ó</button>
            </div>
            <div style="padding:20px;">
                <p style="color:#aaa; margin-bottom:15px;">Task durumlarƒ±nƒ± buradan y√∂netebilirsiniz. Mevcut durumlar:</p>
                <div id="taskStatusList" style="max-height:300px; overflow-y:auto; margin-bottom:20px;">
                    <!-- Populated dynamically -->
                </div>
                <div style="display:grid; grid-template-columns:1fr auto auto auto; gap:10px; align-items:end; padding:15px; background:#252538; border-radius:10px;">
                    <div>
                        <label style="color:#aaa; font-size:11px;">DURUM ADI</label>
                        <input type="text" id="newStatusName" placeholder="Yeni durum adƒ±..." style="width:100%; padding:10px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px;">
                    </div>
                    <div>
                        <label style="color:#aaa; font-size:11px;">RENK</label>
                        <input type="color" id="newStatusColor" value="#8b5cf6" style="width:50px; height:38px; border:none; border-radius:6px; cursor:pointer;">
                    </div>
                    <div>
                        <label style="color:#aaa; font-size:11px;">ICON</label>
                        <input type="text" id="newStatusIcon" value="üìå" style="width:50px; padding:10px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:6px; text-align:center;">
                    </div>
                    <button onclick="addCustomTaskStatus()" style="background:#22c55e; color:#fff; border:none; padding:10px 20px; border-radius:6px; cursor:pointer; font-weight:600;">+ Ekle</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Type Manager Modal - Legend Style -->
    <div class="modal" id="taskTypeManagerModal">
        <div class="modal-content" style="max-width:650px; width:95%; background:#1a1a2e; color:#e0e0e0;">
            <div class="modal-header" style="background:#0f0f1a; border-bottom:2px solid #8b5cf6;">
                <h2 style="color:#fff;">üìã Task Types (Legend)</h2>
                <button class="close-btn" onclick="closeModal('taskTypeManagerModal')" style="background:#555; color:#fff;">√ó</button>
            </div>
            <div style="padding:20px;">
                <!-- Task Types List - √ñNCE Lƒ∞STE -->
                <div id="taskTypeList" style="max-height:350px; overflow-y:auto; margin-bottom:20px; min-height:100px; background:#252538; border-radius:10px; padding:10px;">
                    <!-- Populated dynamically by renderTaskTypeList() -->
                    <div style="color:#888; text-align:center; padding:20px;">Loading...</div>
                </div>

                <!-- Edit/Add Form - SONRA FORM -->
                <div id="taskTypeForm" style="padding:15px; background:#1f1f2e; border-radius:10px; border:2px solid #8b5cf6;">
                    <h3 id="taskTypeFormTitle" style="margin:0 0 15px 0; color:#8b5cf6; font-size:14px;">‚ûï ADD NEW TYPE</h3>
                    <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
                        <div style="flex:1; min-width:120px;">
                            <label style="color:#aaa; font-size:11px; display:block; margin-bottom:4px;">Type ID (lowercase)</label>
                            <input type="text" id="newTypeId" placeholder="e.g. bug-fix" style="width:100%; padding:12px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:8px; text-transform:lowercase;">
                        </div>
                        <div style="flex:1; min-width:120px;">
                            <label style="color:#aaa; font-size:11px; display:block; margin-bottom:4px;">Display Name</label>
                            <input type="text" id="newTypeName" placeholder="e.g. Bug Fix" style="width:100%; padding:12px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:8px;">
                        </div>
                    </div>
                    <div style="display:flex; gap:10px; align-items:end;">
                        <div style="flex:0 0 70px;">
                            <label style="color:#aaa; font-size:11px; display:block; margin-bottom:4px;">Emoji</label>
                            <input type="text" id="newTypeIcon" value="üìã" maxlength="2" style="width:100%; padding:12px; background:#2a2a3e; border:1px solid #444; color:#fff; border-radius:8px; text-align:center; font-size:1.3em;">
                        </div>
                        <div style="flex:0 0 70px;">
                            <label style="color:#aaa; font-size:11px; display:block; margin-bottom:4px;">Color</label>
                            <input type="color" id="newTypeColor" value="#8b5cf6" style="width:100%; height:44px; border:none; border-radius:8px; cursor:pointer;">
                        </div>
                        <div style="flex:1; display:flex; gap:8px;">
                            <button onclick="saveTaskType()" style="flex:1; background:linear-gradient(135deg, #22c55e, #16a34a); color:#fff; border:none; padding:12px 20px; border-radius:8px; cursor:pointer; font-weight:600;">üíæ Save</button>
                            <button onclick="cancelTaskTypeEdit()" style="background:#444; color:#fff; border:none; padding:12px 16px; border-radius:8px; cursor:pointer;">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Backup Modal -->
    <div class="modal" id="backupModal">
        <div class="modal-content" style="max-width:700px; width:90%; background:#2d2d3d; color:#e0e0e0;">
            <div class="modal-header" style="background:#1a1a2e; border-bottom:2px solid #e94560;">
                <h2 style="color:#fff;">üì¶ Backup</h2>
                <button class="close-btn" onclick="closeModal('backupModal')" style="background:#555; color:#fff;">√ó</button>
            </div>
            <div style="padding:25px;">
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:20px;">
                    <!-- Left -->
                    <div>
                        <div class="meta-group">
                            <label style="color:#aaa;">üìÅ BACKUP FILENAME</label>
                            <input type="text" id="backupFileName" placeholder="project_backup" value="" style="font-size:1em; padding:12px; background:#3a3a4a; border:1px solid #555; color:#fff; border-radius:8px;">
                        </div>
                        <div class="meta-group">
                            <label style="color:#aaa;">üìÑ BACKUP FORMAT</label>
                            <select id="backupFormat" style="font-size:1em; padding:12px; background:#3a3a4a; border:1px solid #555; color:#fff; border-radius:8px;">
                                <option value="json">JSON (Full Project)</option>
                                <option value="txt">TXT (Plain Text)</option>
                                <option value="md">Markdown</option>
                            </select>
                        </div>
                    </div>
                    <!-- Right -->
                    <div>
                        <div class="meta-group">
                            <label style="color:#aaa;">üìã BACKUP CONTENT</label>
                            <div style="margin-top:10px; display:flex; flex-direction:column; gap:10px;">
                                <label style="display:flex; align-items:center; gap:10px; cursor:pointer; padding:12px; background:#3a3a4a; border-radius:8px; color:#fff;">
                                    <input type="checkbox" id="backupIncludeNodes" checked style="width:18px; height:18px; accent-color:#e94560;">
                                    <span>SECTIONS AND CONTENT</span>
                                </label>
                                <label style="display:flex; align-items:center; gap:10px; cursor:pointer; padding:12px; background:#3a3a4a; border-radius:8px; color:#fff;">
                                    <input type="checkbox" id="backupIncludeConnections" checked style="width:18px; height:18px; accent-color:#e94560;">
                                    <span>CONNECTIONS</span>
                                </label>
                                <label style="display:flex; align-items:center; gap:10px; cursor:pointer; padding:12px; background:#3a3a4a; border-radius:8px; color:#fff;">
                                    <input type="checkbox" id="backupIncludeSnapshots" checked style="width:18px; height:18px; accent-color:#e94560;">
                                    <span>SNAPSHOTS</span>
                                </label>
                                <label style="display:flex; align-items:center; gap:10px; cursor:pointer; padding:12px; background:#3a3a4a; border-radius:8px; color:#fff;">
                                    <input type="checkbox" id="backupIncludeMeta" checked style="width:18px; height:18px; accent-color:#e94560;">
                                    <span>AUTHORS & TAGS</span>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="background:#3a3a4a; padding:15px; border-radius:8px; margin-top:20px; display:flex; justify-content:space-between; align-items:center;">
                    <div>
                        <strong style="color:#aaa;">üìÖ Last Backup:</strong>
                        <span id="lastBackupTime" style="color:#fff; margin-left:8px;">No backup yet</span>
                    </div>
                    <div id="backupStats" style="color:#888; font-size:0.9em;"></div>
                </div>

                <div style="margin-top:25px; display:flex; gap:15px;">
                    <button class="btn-save" onclick="performBackup()" style="flex:1; padding:16px; font-size:1.05em; border-radius:10px; font-weight:600;">üì¶ Backup All</button>
                    <button class="btn-blue" onclick="loadBackupFile()" style="flex:1; padding:16px; font-size:1.05em; border-radius:10px; font-weight:600;">üìÇ Load Backup</button>
                </div>
                <input type="file" id="backupLoadFile" accept=".json,.txt,.md" style="display:none" onchange="importBackupFile(event)">
            </div>
        </div>
    </div>

    <!-- Compile Modal (Scrivener Style) -->
    <div class="modal" id="compileModal">
        <div class="modal-content" style="max-width:1200px; width:96%; max-height:94vh;">
            <div class="modal-header">
                <h2>üìö Compile</h2>
                <button class="close-btn" onclick="closeModal('compileModal')">√ó</button>
            </div>
            <div style="padding:20px; overflow-y:auto; max-height:calc(92vh - 80px);">
                <!-- Two Column Layout -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:25px;">
                    <!-- Left Column: Section Selection -->
                    <div>
                        <div class="meta-group">
                            <label style="font-size:1.1em; font-weight:bold;">üìñ Sections to Compile</label>
                            <div style="display:flex; gap:10px; margin:10px 0;">
                                <button onclick="selectAllCompileNodes()" class="btn-gray" style="padding:6px 12px; font-size:0.85em;">‚òëÔ∏è All</button>
                                <button onclick="deselectAllCompileNodes()" class="btn-gray" style="padding:6px 12px; font-size:0.85em;">‚òê None</button>
                            </div>
                            <div id="compileNodeList" style="max-height:350px; overflow-y:auto; border:1px solid #ddd; border-radius:8px; padding:8px; background:#fafafa;"></div>
                        </div>

                        <!-- Preview -->
                        <div class="meta-group" style="margin-top:15px;">
                            <label>üìä Summary</label>
                            <div id="compilePreview" style="background:#fff; border:1px solid #ddd; border-radius:8px; padding:12px; font-size:0.9em;">
                                <p style="color:#888;">Select sections to compile...</p>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column: Settings -->
                    <div>
                        <!-- Format Selection -->
                        <div class="meta-group">
                            <label style="font-size:1.1em; font-weight:bold;">üìÅ Export Format</label>
                            <div style="display:grid; grid-template-columns:repeat(5,1fr); gap:10px; margin-top:12px;">
                                <button class="compile-format-btn active" data-format="docx" onclick="selectCompileFormat('docx')" style="padding:12px 8px;">üìÑ DOCX</button>
                                <button class="compile-format-btn" data-format="pdf" onclick="selectCompileFormat('pdf')" style="padding:12px 8px;">üìï PDF</button>
                                <button class="compile-format-btn" data-format="txt" onclick="selectCompileFormat('txt')" style="padding:12px 8px;">üìù TXT</button>
                                <button class="compile-format-btn" data-format="md" onclick="selectCompileFormat('md')" style="padding:12px 8px;">üìã MD</button>
                                <button class="compile-format-btn" data-format="html" onclick="selectCompileFormat('html')" style="padding:12px 8px;">üåê HTML</button>
                            </div>
                        </div>

                        <!-- Node Type Options -->
                        <div class="meta-group" style="margin-top:18px;">
                            <label style="font-weight:bold;">üì¶ ƒ∞√ßerik T√ºrleri</label>
                            <div style="margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#e8f5e9; border-radius:6px; border:1px solid #a5d6a7;">
                                    <input type="checkbox" id="compileIncludeNodes" checked style="width:18px; height:18px;"> üìÑ Section Nodes
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#e3f2fd; border-radius:6px; border:1px solid #90caf9;">
                                    <input type="checkbox" id="compileIncludeTasks" checked style="width:18px; height:18px;"> üìã Task Nodes
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#fff3e0; border-radius:6px; border:1px solid #ffcc80;">
                                    <input type="checkbox" id="compileIncludeFolders" checked style="width:18px; height:18px;"> üìÅ Folder Nodes
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#fce4ec; border-radius:6px; border:1px solid #f48fb1;">
                                    <input type="checkbox" id="compileIncludeImages" checked style="width:18px; height:18px;"> üñºÔ∏è Image Nodes
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#fff9c4; border-radius:6px; border:1px solid #fff176;">
                                    <input type="checkbox" id="compileIncludeSticky" checked style="width:18px; height:18px;"> üìù Sticky Notes
                                </label>
                            </div>
                        </div>

                        <!-- Layout Options -->
                        <div class="meta-group" style="margin-top:18px;">
                            <label style="font-weight:bold;">‚öôÔ∏è D√ºzen Se√ßenekleri</label>
                            <div style="margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#f9f9f9; border-radius:6px;">
                                    <input type="checkbox" id="compileIncludeTitles" checked style="width:18px; height:18px;"> Ba≈ülƒ±klarƒ± g√∂ster
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#f9f9f9; border-radius:6px;">
                                    <input type="checkbox" id="compileIncludeSummary" style="width:18px; height:18px;"> √ñzetleri dahil et
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#f9f9f9; border-radius:6px;">
                                    <input type="checkbox" id="compilePageBreaks" checked style="width:18px; height:18px;"> Sayfa sonu
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#f9f9f9; border-radius:6px;">
                                    <input type="checkbox" id="compileIncludePov" style="width:18px; height:18px;"> Yazar bilgisi
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#f9f9f9; border-radius:6px;">
                                    <input type="checkbox" id="compileStripFormatting" style="width:18px; height:18px;"> Formatƒ± kaldƒ±r
                                </label>
                                <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:0.95em; padding:10px; background:#f9f9f9; border-radius:6px;">
                                    <input type="checkbox" id="compileIncludeCover" style="width:18px; height:18px;"> Kapak sayfasƒ±
                                </label>
                            </div>
                        </div>

                        <!-- Font Settings -->
                        <div class="meta-group" style="margin-top:18px;">
                            <label style="font-weight:bold;">üî§ Font Settings</label>
                            <div style="display:grid; grid-template-columns:1fr 100px 100px; gap:10px; margin-top:10px;">
                                <select id="compileFontFamily" style="padding:10px;">
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Arial">Arial</option>
                                    <option value="Calibri">Calibri</option>
                                </select>
                                <select id="compileFontSize" style="padding:10px;">
                                    <option value="10">10pt</option>
                                    <option value="11">11pt</option>
                                    <option value="12" selected>12pt</option>
                                    <option value="14">14pt</option>
                                </select>
                                <select id="compileLineSpacing" style="padding:10px;">
                                    <option value="1"Single</option>
                                    <option value="1.5" selected>1.5x</option>
                                    <option value="2">Double</option>
                                </select>
                            </div>
                        </div>

                        <!-- Cover Info -->
                        <div class="meta-group" style="margin-top:18px;">
                            <label style="font-weight:bold;">üìï Document Info</label>
                            <input type="text" id="compileBookTitle" placeholder="Document Title" value="My Project" style="margin-top:10px; padding:10px; font-size:1em;">
                            <input type="text" id="compileAuthorName" placeholder="Author Name" value="" style="margin-top:10px; padding:10px; font-size:1em;">
                        </div>

                        <!-- Buttons -->
                        <div style="margin-top:25px; display:flex; gap:15px;">
                            <button class="btn-save" onclick="performCompile()" style="flex:1; padding:15px; font-size:1.1em;">üìö Compile & Download</button>
                            <button class="btn-blue" onclick="previewCompile()" style="flex:1; padding:15px; font-size:1.1em;">üëÅÔ∏è Preview</button>
                        </div>
                        <p id="compilePdfNote" style="display:none; margin-top:12px; padding:10px; background:rgba(16,185,129,0.15); border-radius:6px; font-size:0.85em; color:#10b981; border:1px solid rgba(16,185,129,0.3);">
                            ‚úÖ PDF will be generated and downloaded directly. Cover page, page numbers, and formatting included.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <!-- Project Context Menu - Clean & Professional -->
    <div class="project-context-menu" id="projectContextMenu" style="display:none;">
        <div class="ctx-header" id="contextMenuHeader">
            <div class="ctx-name" id="contextProjectName">Project</div>
            <div class="ctx-stats" id="contextProjectStats">-</div>
        </div>
        <div class="ctx-divider"></div>
        <div class="ctx-item" onclick="contextMenuAction('open')"><span>üìÇ</span> Open Project</div>
        <div class="ctx-item" onclick="contextMenuAction('rename')"><span>‚úèÔ∏è</span> Rename</div>
        <div class="ctx-item" onclick="contextMenuAction('duplicate')"><span>üìã</span> Duplicate</div>
        <div class="ctx-divider"></div>
        <div class="ctx-item" onclick="contextMenuAction('export')"><span>üì§</span> Export</div>
        <div class="ctx-item" onclick="contextMenuAction('backup')"><span>üíæ</span> Backup</div>
        <div class="ctx-divider"></div>
        <div class="ctx-item" onclick="contextMenuAction('star')"><span>‚≠ê</span> Favorite</div>
        <div class="ctx-item" onclick="contextMenuAction('archive')"><span>üì¶</span> Archive</div>
        <div class="ctx-divider"></div>
        <div class="ctx-item ctx-danger" onclick="contextMenuAction('delete')"><span>üóëÔ∏è</span> Delete</div>
    </div>

    <!-- Auth Modal -->
    <div class="modal" id="authModal" style="display:none;">
        <div class="auth-modal-content">
            <button class="auth-close" onclick="closeAuthModal()">&times;</button>

            <div class="auth-header">
                <div class="auth-logo">‚ú®</div>
                <h2 id="authModalTitle">Welcome Back</h2>
                <p class="auth-subtitle" id="authSubtitle">Sign in to continue to your workspace</p>
            </div>

            <div id="authError" class="auth-error"></div>

            <div id="loginForm" class="auth-form">
                <div class="auth-input-group">
                    <label>Email Address</label>
                    <div class="auth-input-wrapper">
                        <span class="auth-input-icon">‚úâÔ∏è</span>
                        <input type="email" id="loginEmail" placeholder="name@company.com">
                    </div>
                </div>
                <div class="auth-input-group">
                    <label>Password</label>
                    <div class="auth-input-wrapper">
                        <span class="auth-input-icon">üîë</span>
                        <input type="password" id="loginPassword" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                    </div>
                </div>
                <button class="auth-btn-primary" onclick="doLogin()">
                    <span>Continue</span>
                    <span class="auth-btn-arrow">‚Üí</span>
                </button>
                <div class="auth-divider"><span>or</span></div>
                <p class="auth-switch">
                    New here? <a href="#" onclick="showRegisterForm(); return false;">Create an account</a>
                </p>
            </div>

            <div id="registerForm" class="auth-form" style="display:none;">
                <div class="auth-input-group">
                    <label>Username</label>
                    <div class="auth-input-wrapper">
                        <span class="auth-input-icon">üë§</span>
                        <input type="text" id="registerUsername" placeholder="Choose a username">
                    </div>
                </div>
                <div class="auth-input-group">
                    <label>Email Address</label>
                    <div class="auth-input-wrapper">
                        <span class="auth-input-icon">‚úâÔ∏è</span>
                        <input type="email" id="registerEmail" placeholder="name@company.com">
                    </div>
                </div>
                <div class="auth-input-group">
                    <label>Password</label>
                    <div class="auth-input-wrapper">
                        <span class="auth-input-icon">üîë</span>
                        <input type="password" id="registerPassword" placeholder="Min 6 characters">
                    </div>
                </div>
                <button class="auth-btn-primary" onclick="doRegister()">
                    <span>Get Started</span>
                    <span class="auth-btn-arrow">‚Üí</span>
                </button>
                <div class="auth-divider"><span>or</span></div>
                <p class="auth-switch">
                    Have an account? <a href="#" onclick="showLoginForm(); return false;">Sign in</a>
                </p>
            </div>
        </div>
    </div>

    <!-- Projects Modal -->
    <div class="modal" id="projectsModal" style="display:none;">
        <div class="projects-modal-content">
            <div class="projects-header">
                <h2>üìÅ My Projects</h2>
                <button class="auth-close" onclick="closeProjectsModal()">&times;</button>
            </div>
            <div class="projects-toolbar">
                <button class="projects-btn projects-btn-new" onclick="createNewProject()">+ New Project</button>
                <button class="projects-btn projects-btn-refresh" onclick="loadProjectsList()">‚Üª Refresh</button>
            </div>
            <div class="projects-list" id="projectsList"></div>
        </div>
    </div>

    <script>
        // ============ STARTUP CLEANUP - Fix corrupted UTF-8 data ============
        (function cleanupCorruptedData() {
            try {
                // Very aggressive corruption detection
                function hasCorruptedChars(str) {
                    if (!str) return false;
                    // Check for ANY non-ASCII extended characters that indicate corruption
                    // These patterns appear when UTF-8 emojis are incorrectly decoded
                    for (let i = 0; i < str.length; i++) {
                        const code = str.charCodeAt(i);
                        // Check for Latin-1 Supplement range (corrupted UTF-8)
                        if (code >= 0xC0 && code <= 0xFF) {
                            return true;
                        }
                    }
                    // Also check literal patterns
                    return str.includes('√É') || str.includes('√Ç') || 
                           str.includes('√¢') || str.includes('|√É') ||
                           str.includes('√É|') || str.includes('√É√Ç');
                }
                
                // ALWAYS check and clean on every load
                let hasCorruption = false;
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const data = localStorage.getItem(key);
                    if (data && hasCorruptedChars(data)) {
                        hasCorruption = true;
                        console.warn(`üßπ Corruption found in: ${key}`);
                        break;
                    }
                }
                
                // If ANY corruption found, clear ALL app data
                if (hasCorruption) {
                    console.warn('üßπ Corrupted data detected! Clearing ALL localStorage...');
                    // Clear EVERYTHING - no exceptions
                    localStorage.clear();
                    
                    // Reload only once
                    if (!sessionStorage.getItem('dataCleanedReload')) {
                        sessionStorage.setItem('dataCleanedReload', 'true');
                        alert('Bozuk veri tespit edildi. T√ºm veriler temizlendi. Sayfa yenilenecek.');
                        location.reload();
                    }
                } else {
                    sessionStorage.removeItem('dataCleanedReload');
                }
                console.log('‚úÖ Startup cleanup completed');
            } catch (e) {
                console.warn('Startup cleanup error:', e);
            }
        })();
        
        // Global function to force clean all data (can be called from console)
        window.forceCleanAllData = function() {
            // Clear EVERYTHING
            localStorage.clear();
            sessionStorage.clear();
            console.log('üßπ ALL localStorage and sessionStorage cleared. Reloading...');
            alert('T√ºm veriler temizlendi. Sayfa yenilenecek.');
            location.reload();
        };

        // ============ OFFLINE MODE - LOCAL STORAGE ONLY ============
        // Bu versiyon internet gerektirmez, t√ºm veriler localStorage'da saklanƒ±r

        const OFFLINE_MODE = true;
        let currentUser = null; // Disabled but kept for compatibility
        let currentProjectId = null;
        let currentProjectName = 'Untitled'; // Dosya adƒ± i√ßin

        // Offline API - localStorage kullanƒ±r
        const api = {
            // Auth - Basit localStorage tabanlƒ±
            async login(email, password) {
                // Offline modda ≈üifre kontrol√º yok, sadece kullanƒ±cƒ± adƒ± kaydedilir
                const user = { username: email.split('@')[0], email: email };
                currentUser = user;
                localStorage.setItem('offlineUser', JSON.stringify(user));
                return { user };
            },

            async register(username, email, password) {
                const user = { username, email };
                currentUser = user;
                localStorage.setItem('offlineUser', JSON.stringify(user));
                return { user };
            },

            async getMe() {
                if (currentUser) return { user: currentUser };
                throw new Error('Not logged in');
            },

            logout() {
                currentUser = null;
                currentProjectId = null;
                localStorage.removeItem('offlineUser');
            },

            // Projects - localStorage tabanlƒ±
            async getProjects() {
                const projects = JSON.parse(localStorage.getItem('offlineProjects')) || [];
                return projects;
            },

            async getProject(id) {
                const projects = JSON.parse(localStorage.getItem('offlineProjects')) || [];
                const project = projects.find(p => p.id === id);
                if (!project) throw new Error('Project not found');
                return project;
            },

            async createProject(name, description = '') {
                const projects = JSON.parse(localStorage.getItem('offlineProjects')) || [];
                const newProject = {
                    id: 'proj_' + Date.now(),
                    name,
                    description,
                    nodes: [],
                    connections: [],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                projects.push(newProject);
                try {
                    localStorage.setItem('offlineProjects', JSON.stringify(projects));
                } catch (e) {
                    if (e.name === 'QuotaExceededError' || e.message.includes('quota')) {
                        throw new Error('Storage full! Delete old projects or use File ‚Üí Save to export.');
                    }
                    throw e;
                }
                return newProject;
            },

            async saveProject(id, data) {
                const projects = JSON.parse(localStorage.getItem('offlineProjects')) || [];
                const index = projects.findIndex(p => p.id === id);
                if (index === -1) throw new Error('Project not found');

                // Stats hesapla
                let totalWords = 0;
                if (data.nodes) {
                    data.nodes.forEach(node => {
                        const text = (node.fullText || '').replace(/<[^>]*>/g, ' ');
                        totalWords += text.split(/\s+/).filter(w => w.length > 0).length;
                    });
                }

                const stats = {
                    totalWords: totalWords,
                    totalNodes: data.nodes ? data.nodes.length : 0
                };

                projects[index] = { ...projects[index], ...data, stats, updatedAt: new Date().toISOString() };
                try {
                    localStorage.setItem('offlineProjects', JSON.stringify(projects));
                } catch (e) {
                    if (e.name === 'QuotaExceededError' || e.message.includes('quota')) {
                        throw new Error('Storage full! Export your project with File ‚Üí Save to free up space.');
                    }
                    throw e;
                }
                return projects[index];
            },

            async autoSaveProject(id, nodes, connections) {
                return await this.saveProject(id, { nodes, connections });
            },

            async deleteProject(id) {
                let projects = JSON.parse(localStorage.getItem('offlineProjects')) || [];
                projects = projects.filter(p => p.id !== id);
                localStorage.setItem('offlineProjects', JSON.stringify(projects));
                return { success: true };
            },

            async duplicateProject(id) {
                const projects = JSON.parse(localStorage.getItem('offlineProjects')) || [];
                const original = projects.find(p => p.id === id);
                if (!original) throw new Error('Project not found');

                const duplicate = {
                    ...JSON.parse(JSON.stringify(original)),
                    id: 'proj_' + Date.now(),
                    name: original.name + ' (Copy)',
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                projects.push(duplicate);
                localStorage.setItem('offlineProjects', JSON.stringify(projects));
                return duplicate;
            },

            // Upload - base64 olarak localStorage'a kaydet
            async uploadFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const result = { url: reader.result, filename: file.name };
                        resolve(result);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }
        };

        // ============ EXPORT / IMPORT JSON ============
        function exportAllData() {
            const data = {
                user: currentUser,
                projects: JSON.parse(localStorage.getItem('offlineProjects')) || [],
                settings: JSON.parse(localStorage.getItem('universalWriterFontSettings')) || {},
                exportDate: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `writer-backup-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('‚úÖ Backup exported successfully!');
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        if (data.projects) {
                            localStorage.setItem('offlineProjects', JSON.stringify(data.projects));
                        }
                        if (data.user) {
                            localStorage.setItem('offlineUser', JSON.stringify(data.user));
                            currentUser = data.user;
                        }
                        if (data.settings) {
                            localStorage.setItem('universalWriterFontSettings', JSON.stringify(data.settings));
                        }
                        showToast('‚úÖ Data imported successfully!');
                        loadProjectsList();
                        updateAuthUI();
                    } catch (err) {
                        showToast('‚ùå Invalid backup file', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // Open Project - JSON dosyasƒ±ndan proje a√ß
        async function openProject() {
            // Try File System Access API first (allows saving to same file later)
            if (window.showOpenFilePicker) {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'JSON Files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    currentFileHandle = fileHandle; // Save for later saving to same file
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    await loadProjectData(JSON.parse(text), file.name);
                    return;
                } catch (err) {
                    if (err.name === 'AbortError') return; // User cancelled
                    console.warn('File picker failed, using fallback:', err);
                }
            }

            /// Fallback: use traditional file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                currentFileHandle = null; // No file handle with fallback method

                const reader = new FileReader();
                reader.onload = async (ev) => {
                    await loadProjectData(JSON.parse(ev.target.result), file.name);
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // Helper function to load project data
        async function loadProjectData(data, fileName) {
            console.log('üìÇ loadProjectData called:', fileName);
            console.log('üìÇ Data keys:', Object.keys(data));
            console.log('üìÇ Nodes count:', data.nodes ? data.nodes.length : 0);
            try {
                // Proje verilerini y√ºkle
                nodes = data.nodes || [];
                connections = data.connections || [];
                povList = data.povList || povList;
                descTypes = data.descTypes ? sanitizeDescTypes(data.descTypes) : descTypes;
                revisionLabels = data.revisionLabels || [];

                // Load task types if saved in project (with sanitization)
                if (data.TASK_NODE_TYPES) {
                    // Sanitize each task type to prevent corrupted icons
                    Object.keys(data.TASK_NODE_TYPES).forEach(key => {
                        const type = data.TASK_NODE_TYPES[key];
                        if (type && typeof sanitizeTaskType === 'function') {
                            TASK_NODE_TYPES[key] = sanitizeTaskType(type);
                        } else {
                            TASK_NODE_TYPES[key] = type;
                        }
                    });
                }
                if (data.CUSTOM_TASK_TYPES && typeof sanitizeTaskType === 'function') {
                    CUSTOM_TASK_TYPES = data.CUSTOM_TASK_TYPES.map(t => sanitizeTaskType(t));
                } else if (data.CUSTOM_TASK_TYPES) {
                    CUSTOM_TASK_TYPES = data.CUSTOM_TASK_TYPES;
                }
                if (data.TASK_STATUSES) {
                    TASK_STATUSES = sanitizeTaskStatuses(data.TASK_STATUSES);
                }

                // Apply task type styles
                applyTaskTypeStyles();

                // ID counter'larƒ± g√ºncelle
                const nodeIds = nodes.map(n => parseInt(String(n.id).replace('node_', '')) || 0);
                idCounter.node = nodeIds.length > 0 ? Math.max(...nodeIds) + 1 : 1;

                // Proje adƒ±nƒ± JSON'dan veya dosya adƒ±ndan al
                currentProjectName = data.projectName || fileName.replace('.json', '');

                // Project metadata'yƒ± y√ºkle (Settings i√ßin)
                window.projectMetadata = data.projectMetadata || {
                    name: currentProjectName,
                    description: '',
                    wordTarget: 50000,
                    deadline: null
                };

                // Render
                console.log('üìÇ About to render, nodes:', nodes.length);
                renderAll();
                renderConnections();
                updateAllStats();
                renderOutline();
                updateSelects();
                adjustCanvasSize();
                scheduleConnectionRebuild();
                
                // Auto fit to screen after loading
                setTimeout(() => {
                    if (nodes.length > 0) {
                        fitToScreen();
                        renderConnections();
                    }
                }, 300);
                
                console.log('üìÇ Render complete');

                // Save to localStorage for session restore
                try {
                    const sessionData = {
                        nodes, connections, povList, descTypes, revisionLabels,
                        projectName: currentProjectName,
                        projectMetadata: window.projectMetadata || {},
                        TASK_NODE_TYPES: TASK_NODE_TYPES,
                        CUSTOM_TASK_TYPES: CUSTOM_TASK_TYPES,
                        TASK_STATUSES: TASK_STATUSES
                    };
                    localStorage.setItem('writerLastSession', JSON.stringify(sessionData));
                } catch (e) {
                    console.warn('Could not save session:', e.message);
                }

                // Update file panel
                document.getElementById('currentFileName').textContent = currentProjectName + '.json';
                updateFilePanelStats();

                showToast('üìÇ Opened: ' + currentProjectName);
            } catch (err) {
                console.error('Open project error:', err);
                showToast('‚ùå Error: ' + err.message, 'error');
            }
        }

        function scheduleConnectionRebuild() {
            // Multiple passes to stabilise after open (images/layout load late)
            renderConnections();
            setTimeout(renderConnections, 100);
            setTimeout(renderConnections, 300);
            setTimeout(renderConnections, 600);

            // Rebuild after any image loads (image nodes affect size)
            const imgs = document.querySelectorAll('#canvas img');
            let pending = 0;
            imgs.forEach(img => {
                if (!img.complete) {
                    pending++;
                    const onDone = () => {
                        pending = Math.max(0, pending - 1);
                        renderConnections();
                    };
                    img.addEventListener('load', onDone, { once: true });
                    img.addEventListener('error', onDone, { once: true });
                }
            });
            if (pending === 0) {
                renderConnections();
            }
        }

        // Import to current project - mevcut projeye node'larƒ± ekle
        function importToProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);

                        // Mevcut node ID'lerini kontrol et
                        let maxId = 0;
                        nodes.forEach(n => {
                            const id = parseInt(n.id.replace('node_', '')) || 0;
                            if (id > maxId) maxId = id;
                        });

                        // Import edilen node'larƒ±n ID'lerini g√ºncelle
                        if (data.nodes && data.nodes.length > 0) {
                            data.nodes.forEach(node => {
                                maxId++;
                                const oldId = node.id;
                                node.id = 'node_' + maxId;

                                // Connection'larda da ID'yi g√ºncelle
                                if (data.connections) {
                                    data.connections.forEach(conn => {
                                        if (conn.from === oldId) conn.from = node.id;
                                        if (conn.to === oldId) conn.to = node.id;
                                    });
                                }

                                // Node'u ekle
                                nodes.push(node);
                            });

                            // Connection'larƒ± ekle
                            if (data.connections) {
                                data.connections.forEach(conn => {
                                    connections.push(conn);
                                });
                            }

                            idCounter.node = maxId + 1;
                        }

                        // POV ve DescTypes varsa ekle (duplicate kontrol√º ile)
                        if (data.povList) {
                            data.povList.forEach(pov => {
                                if (!povList.find(p => p.name === pov.name)) {
                                    pov.id = idCounter.pov++;
                                    povList.push(pov);
                                }
                            });
                        }

                        if (data.descTypes) {
                            data.descTypes.forEach(dt => {
                                const sanitized = sanitizeDescTypeEarly(dt);
                                if (!descTypes.find(d => d.name === sanitized.name)) {
                                    sanitized.id = idCounter.desc++;
                                    descTypes.push(sanitized);
                                }
                            });
                        }

                        // Render
                        renderAll();
                        renderConnections();
                        updateAllStats();
                        renderOutline();

                        showToast('üì• Imported ' + (data.nodes ? data.nodes.length : 0) + ' items');
                    } catch (err) {
                        console.error('Import error:', err);
                        showToast('‚ùå Invalid file', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        // ============ AUTH UI (DISABLED FOR OFFLINE) ============
        function showAuthModal() { /* Disabled */ }
        function closeAuthModal() { /* Disabled */ }
        function showLoginForm() { /* Disabled */ }
        function showRegisterForm() { /* Disabled */ }
        function showAuthError(message) { /* Disabled */ }

        async function doLogin() { /* Disabled */ }
        async function doRegister() { /* Disabled */ }
        function doLogout() { /* Disabled */ }

        // Time ago helper
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            const intervals = [
                { label: 'year', seconds: 31536000 },
                { label: 'month', seconds: 2592000 },
                { label: 'week', seconds: 604800 },
                { label: 'day', seconds: 86400 },
                { label: 'hour', seconds: 3600 },
                { label: 'minute', seconds: 60 }
            ];
            for (const interval of intervals) {
                const count = Math.floor(seconds / interval.seconds);
                if (count >= 1) {
                    return `${count} ${interval.label}${count > 1 ? 's' : ''} ago`;
                }
            }
            return 'Just now';
        }

        // Project Settings Modal - Professional Design
        let currentSettingsProjectId = null;

        function openProjectSettings(projectId) {
            currentSettingsProjectId = projectId;

            // Remove existing modal if any
            const existing = document.getElementById('projectSettingsModal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.id = 'projectSettingsModal';
            modal.className = 'modal active';
            modal.style.cssText = 'display:flex; align-items:center; justify-content:center;';
            modal.onclick = function(e) { if (e.target === this) closeProjectSettingsModal(); };

            modal.innerHTML = `
                <div style="width:100%; max-width:600px; background:#1a1a2e; border-radius:20px; box-shadow:0 25px 60px -12px rgba(0,0,0,0.6); overflow:hidden; border:1px solid rgba(233,69,96,0.2);">
                    <!-- Header -->
                    <div style="display:flex; align-items:center; justify-content:space-between; padding:24px 28px; background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-bottom:2px solid #e94560;">
                        <div style="display:flex; align-items:center; gap:16px;">
                            <div style="width:50px; height:50px; background:linear-gradient(135deg, #e94560 0%, #ff6b8a 100%); border-radius:14px; display:flex; align-items:center; justify-content:center; font-size:22px; box-shadow:0 4px 15px rgba(233,69,96,0.4);">‚öôÔ∏è</div>
                            <div>
                                <h2 style="font-size:20px; font-weight:700; color:#fff; margin:0;">Project Settings</h2>
                                <p style="font-size:13px; color:#888; margin:4px 0 0 0;">Configure and manage your project</p>
                            </div>
                        </div>
                        <button id="settingsCloseBtn" style="width:36px; height:36px; border:none; background:rgba(255,255,255,0.1); border-radius:10px; color:#aaa; cursor:pointer; font-size:20px; transition:all 0.2s;">√ó</button>
                    </div>

                    <div style="padding:28px;">
                        <!-- Project Info Section -->
                        <div style="margin-bottom:24px;">
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:16px;">
                                <span style="font-size:14px;">üìù</span>
                                <span style="font-size:14px; font-weight:600; color:#fff; text-transform:uppercase; letter-spacing:0.5px;">Project Information</span>
                            </div>
                            <div style="background:rgba(255,255,255,0.03); border-radius:14px; padding:20px; border:1px solid rgba(255,255,255,0.08);">
                                <div style="margin-bottom:18px;">
                                    <label style="display:block; font-size:12px; font-weight:600; color:#888; margin-bottom:8px; text-transform:uppercase; letter-spacing:0.5px;">Project Name</label>
                                    <input type="text" id="settingsProjectName" placeholder="My Novel" style="width:100%; padding:14px 16px; background:#2d2d3d; border:1px solid #444; border-radius:12px; color:#fff; font-size:15px; outline:none; transition:border-color 0.2s;">
                                </div>
                                <div>
                                    <label style="display:block; font-size:12px; font-weight:600; color:#888; margin-bottom:8px; text-transform:uppercase; letter-spacing:0.5px;">Description</label>
                                    <textarea id="settingsProjectDesc" rows="3" placeholder="A brief description of your project..." style="width:100%; padding:14px 16px; background:#2d2d3d; border:1px solid #444; border-radius:12px; color:#fff; font-size:14px; resize:none; outline:none; font-family:inherit; line-height:1.5; transition:border-color 0.2s;"></textarea>
                                </div>
                            </div>
                        </div>

                        <!-- Goals Section -->
                        <div style="margin-bottom:24px;">
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:16px;">
                                <span style="font-size:14px;">üéØ</span>
                                <span style="font-size:14px; font-weight:600; color:#fff; text-transform:uppercase; letter-spacing:0.5px;">Goals & Timeline</span>
                            </div>
                            <div style="display:grid; grid-template-columns:1fr 1fr; gap:16px;">
                                <div style="background:rgba(255,255,255,0.03); border-radius:14px; padding:18px; border:1px solid rgba(255,255,255,0.08);">
                                    <label style="display:flex; align-items:center; gap:8px; font-size:12px; font-weight:600; color:#888; margin-bottom:10px; text-transform:uppercase; letter-spacing:0.5px;">
                                        <span style="font-size:16px;">üìä</span> Word Target
                                    </label>
                                    <input type="number" id="settingsWordTarget" placeholder="50000" style="width:100%; padding:14px 16px; background:#2d2d3d; border:1px solid #444; border-radius:12px; color:#fff; font-size:15px; outline:none; transition:border-color 0.2s;">
                                    <p style="margin:8px 0 0; font-size:11px; color:#666;">Set your target word count</p>
                                </div>
                                <div style="background:rgba(255,255,255,0.03); border-radius:14px; padding:18px; border:1px solid rgba(255,255,255,0.08);">
                                    <label style="display:flex; align-items:center; gap:8px; font-size:12px; font-weight:600; color:#888; margin-bottom:10px; text-transform:uppercase; letter-spacing:0.5px;">
                                        <span style="font-size:16px;">üìÖ</span> Deadline
                                    </label>
                                    <input type="date" id="settingsDeadline" style="width:100%; padding:14px 16px; background:#2d2d3d; border:1px solid #444; border-radius:12px; color:#fff; font-size:15px; outline:none; transition:border-color 0.2s;">
                                    <p style="margin:8px 0 0; font-size:11px; color:#666;">Your project deadline</p>
                                </div>
                            </div>
                        </div>

                        <!-- Project Stats (Read-only) -->
                        <div style="margin-bottom:24px;">
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:16px;">
                                <span style="font-size:14px;">üìà</span>
                                <span style="font-size:14px; font-weight:600; color:#fff; text-transform:uppercase; letter-spacing:0.5px;">Project Statistics</span>
                            </div>
                            <div id="projectStatsGrid" style="display:grid; grid-template-columns:repeat(4, 1fr); gap:12px;">
                                <div style="background:linear-gradient(135deg, rgba(233,69,96,0.15) 0%, rgba(233,69,96,0.05) 100%); border-radius:12px; padding:16px; text-align:center; border:1px solid rgba(233,69,96,0.2);">
                                    <div id="statWords" style="font-size:24px; font-weight:700; background:linear-gradient(135deg, #e94560 0%, #ff6b8a 100%); -webkit-background-clip:text; -webkit-text-fill-color:transparent;">-</div>
                                    <div style="font-size:10px; color:#888; text-transform:uppercase; letter-spacing:0.5px; margin-top:4px;">Words</div>
                                </div>
                                <div style="background:linear-gradient(135deg, rgba(99,102,241,0.15) 0%, rgba(99,102,241,0.05) 100%); border-radius:12px; padding:16px; text-align:center; border:1px solid rgba(99,102,241,0.2);">
                                    <div id="statSections" style="font-size:24px; font-weight:700; color:#6366f1;">-</div>
                                    <div style="font-size:10px; color:#888; text-transform:uppercase; letter-spacing:0.5px; margin-top:4px;">Sections</div>
                                </div>
                                <div style="background:linear-gradient(135deg, rgba(16,185,129,0.15) 0%, rgba(16,185,129,0.05) 100%); border-radius:12px; padding:16px; text-align:center; border:1px solid rgba(16,185,129,0.2);">
                                    <div id="statPages" style="font-size:24px; font-weight:700; color:#10b981;">-</div>
                                    <div style="font-size:10px; color:#888; text-transform:uppercase; letter-spacing:0.5px; margin-top:4px;">Pages</div>
                                </div>
                                <div style="background:linear-gradient(135deg, rgba(245,158,11,0.15) 0%, rgba(245,158,11,0.05) 100%); border-radius:12px; padding:16px; text-align:center; border:1px solid rgba(245,158,11,0.2);">
                                    <div id="statProgress" style="font-size:24px; font-weight:700; color:#f59e0b;">-</div>
                                    <div style="font-size:10px; color:#888; text-transform:uppercase; letter-spacing:0.5px; margin-top:4px;">Progress</div>
                                </div>
                            </div>
                        </div>

                        <!-- Timestamps -->
                        <div style="display:flex; gap:20px; padding:16px 20px; background:rgba(255,255,255,0.02); border-radius:12px; margin-bottom:24px; border:1px solid rgba(255,255,255,0.05);">
                            <div style="flex:1;">
                                <div style="font-size:10px; color:#666; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:4px;">Created</div>
                                <div id="statCreated" style="font-size:13px; color:#aaa; display:flex; align-items:center; gap:6px;">
                                    <span style="font-size:12px;">üìÜ</span> <span>-</span>
                                </div>
                            </div>
                            <div style="width:1px; background:rgba(255,255,255,0.1);"></div>
                            <div style="flex:1;">
                                <div style="font-size:10px; color:#666; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:4px;">Last Modified</div>
                                <div id="statUpdated" style="font-size:13px; color:#aaa; display:flex; align-items:center; gap:6px;">
                                    <span style="font-size:12px;">üïê</span> <span>-</span>
                                </div>
                            </div>
                        </div>

                        <!-- Actions -->
                        <div style="display:flex; gap:12px; justify-content:flex-end; padding-top:20px; border-top:1px solid rgba(255,255,255,0.08);">
                            <button id="settingsCancelBtn" style="padding:14px 28px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:12px; color:#aaa; cursor:pointer; font-size:14px; font-weight:500; transition:all 0.2s;">Cancel</button>
                            <button id="settingsSaveBtn" style="padding:14px 32px; background:linear-gradient(135deg, #e94560 0%, #ff6b8a 100%); border:none; border-radius:12px; color:white; cursor:pointer; font-size:14px; font-weight:600; box-shadow:0 4px 15px rgba(233,69,96,0.3); transition:all 0.2s;">Save Changes</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Add event listeners
            document.getElementById('settingsCloseBtn').onclick = closeProjectSettingsModal;
            document.getElementById('settingsCancelBtn').onclick = closeProjectSettingsModal;
            document.getElementById('settingsSaveBtn').onclick = doSaveProjectSettings;

            // Load current settings - bellekteki verileri kullan
            const loadSettings = (p) => {
                document.getElementById('settingsProjectName').value = p.name || currentProjectName || '';
                document.getElementById('settingsProjectDesc').value = p.description || '';
                document.getElementById('settingsWordTarget').value = p.wordTarget || '';
                document.getElementById('settingsDeadline').value = p.deadline || '';

                // Update statistics from current memory state
                let totalWords = 0;
                nodes.forEach(node => {
                    const text = (node.fullText || '').replace(/<[^>]*>/g, ' ');
                    totalWords += text.split(/\s+/).filter(w => w.length > 0).length;
                });

                const words = totalWords;
                const sections = nodes.length;
                const pages = Math.ceil(words / 250);
                const target = p.wordTarget || 50000;
                const progress = Math.min(Math.round((words / target) * 100), 100);

                document.getElementById('statWords').textContent = words.toLocaleString();
                document.getElementById('statSections').textContent = sections;
                document.getElementById('statPages').textContent = pages;
                document.getElementById('statProgress').textContent = progress + '%';

                // Update timestamps
                if (p.createdAt) {
                    const created = new Date(p.createdAt);
                    document.getElementById('statCreated').querySelector('span:last-child').textContent = created.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                }
                if (p.updatedAt) {
                    const updated = new Date(p.updatedAt);
                    document.getElementById('statUpdated').querySelector('span:last-child').textContent = getTimeAgo(updated);
                } else {
                    document.getElementById('statUpdated').querySelector('span:last-child').textContent = 'Just now';
                }
            };

            // √ñnce bellekteki projectMetadata'yƒ± kullan, sonra localStorage'a bak
            if (window.projectMetadata && window.projectMetadata.name) {
                // Bellekte kaydedilmi≈ü ayarlar var, onlarƒ± kullan
                loadSettings(window.projectMetadata);
            } else if (projectId) {
                api.getProject(projectId).then(result => {
                    const p = result.project || result;
                    if (p) loadSettings(p);
                }).catch(() => {
                    // localStorage'da yok, mevcut proje adƒ±nƒ± kullan
                    loadSettings({ name: currentProjectName });
                });
            } else {
                // projectId yok, bellekteki deƒüerleri kullan
                loadSettings({ name: currentProjectName });
            }
        }

        function closeProjectSettingsModal() {
            const modal = document.getElementById('projectSettingsModal');
            if (modal) modal.remove();
            currentSettingsProjectId = null;
        }

        async function doSaveProjectSettings() {
            const name = document.getElementById('settingsProjectName').value;
            const description = document.getElementById('settingsProjectDesc').value;
            const wordTarget = parseInt(document.getElementById('settingsWordTarget').value) || null;
            const deadline = document.getElementById('settingsDeadline').value || null;

            // Update global project settings in memory
            currentProjectName = name || currentProjectName;

            // Store project metadata globally
            if (!window.projectMetadata) {
                window.projectMetadata = {};
            }
            window.projectMetadata = {
                name: name,
                description: description,
                wordTarget: wordTarget,
                deadline: deadline,
                updatedAt: new Date().toISOString()
            };

            // Also try to save to localStorage if we have a project ID
            if (currentSettingsProjectId) {
                try {
                    await api.saveProject(currentSettingsProjectId, { name, description, wordTarget, deadline });
                } catch (e) {
                    // Ignore localStorage errors for offline mode
                    console.log('localStorage save skipped:', e.message);
                }
            }

            // Update sidebar project name if visible
            const sidebarItem = document.querySelector(`.project-item[data-id="${currentSettingsProjectId}"] span`);
            if (sidebarItem) {
                sidebarItem.textContent = name;
            }

            showToast('‚úÖ Settings saved');
            closeProjectSettingsModal();
        }

        async function quickExportProject(projectId) {
            try {
                const result = await api.getProject(projectId);
                const p = result.project || result;
                if (p) {
                    const exportData = {
                        name: p.name,
                        nodes: p.nodes,
                        connections: p.connections,
                        povList: p.povList,
                        descTypes: p.descTypes,
                        exportedAt: new Date().toISOString()
                    };
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${p.name.replace(/[^a-z0-9]/gi, '_')}_export.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast('üì§ Exported successfully');
                }
            } catch (e) {
                showToast('‚ùå Export failed');
            }
        }

        function updateAuthUI() { /* Disabled for offline */ }

        // ============ PROJECTS UI (DISABLED FOR OFFLINE - FILE BASED) ============
        function showProjectsModal() { /* Disabled */ }
        function closeProjectsModal() { /* Disabled */ }
        async function loadProjectsList() { /* Disabled */ }
        async function loadProjectsSideList() { /* Disabled */ }

        function updateCurrentProjectInfo() {
            // Just update the file panel
            const nameEl = document.getElementById('currentFileName');
            if (nameEl && currentProjectName) {
                nameEl.textContent = currentProjectName + '.json';
            }
        }

        // ============ PROJECT CONTEXT MENU ============
        let contextMenuProjectId = null;
        let contextMenuProjectName = null;

        async function showProjectContextMenu(event, projectId, projectName) {
            event.preventDefault();
            event.stopPropagation();

            contextMenuProjectId = projectId;
            contextMenuProjectName = projectName;

            const menu = document.getElementById('projectContextMenu');
            menu.style.display = 'block';

            // Update header with project name immediately
            document.getElementById('contextProjectName').textContent = projectName;
            document.getElementById('contextProjectStats').textContent = 'Loading stats...';

            // Position menu
            let x = event.clientX;
            let y = event.clientY;

            // Adjust if near edge
            if (x + 260 > window.innerWidth) x = window.innerWidth - 260;
            if (y + 450 > window.innerHeight) y = window.innerHeight - 450;

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Fetch project details for stats
            try {
                const result = await api.getProject(projectId);
                const p = result.project || result;
                if (p) {
                    const nodeCount = p.nodes ? p.nodes.length : 0;
                    const wordCount = p.stats?.totalWords || 0;
                    const lastEdit = p.updatedAt ? new Date(p.updatedAt).toLocaleDateString() : 'Never';
                    document.getElementById('contextProjectStats').innerHTML =
                        `<span>üìÑ ${nodeCount} items</span> ‚Ä¢ <span>üìù ${wordCount.toLocaleString()} words</span> ‚Ä¢ <span>üìÖ ${lastEdit}</span>`;
                }
            } catch (e) {
                document.getElementById('contextProjectStats').textContent = 'Stats unavailable';
            }
        }

        function hideProjectContextMenu() {
            document.getElementById('projectContextMenu').style.display = 'none';
            contextMenuProjectId = null;
            contextMenuProjectName = null;
        }

        // Close context menu on click outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.project-context-menu')) {
                hideProjectContextMenu();
            }
        });

        async function contextMenuAction(action) {
            // Save values before hiding menu (which clears them)
            const projectId = contextMenuProjectId;
            const projectName = contextMenuProjectName;

            hideProjectContextMenu();

            if (!projectId) return;

            switch(action) {
                case 'open':
                    loadProject(projectId);
                    break;

                case 'rename':
                    const newName = prompt('Rename project:', projectName);
                    if (newName && newName !== projectName) {
                        try {
                            await api.saveProject(projectId, { name: newName });
                            showToast('‚úèÔ∏è Project renamed');
                            loadProjectsSideList();
                        } catch (e) {
                            showToast('‚ùå Error renaming');
                        }
                    }
                    break;

                case 'duplicate':
                    try {
                        await api.duplicateProject(projectId);
                        showToast('üìã Project duplicated');
                        loadProjectsSideList();
                    } catch (e) {
                        showToast('‚ùå Error duplicating');
                    }
                    break;

                case 'export':
                    try {
                        const result = await api.getProject(projectId);
                        const project = result.project || result;
                        const exportData = {
                            name: project.name,
                            nodes: project.nodes,
                            connections: project.connections,
                            povList: project.povList,
                            descTypes: project.descTypes,
                            revisionLabels: project.revisionLabels,
                            exportedAt: new Date().toISOString()
                        };
                        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${project.name.replace(/[^a-z0-9]/gi, '_')}_export.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        showToast('üì§ Project exported');
                    } catch (e) {
                        showToast('‚ùå Error exporting');
                    }
                    break;

                case 'backup':
                    try {
                        const result = await api.getProject(projectId);
                        const project = result.project || result;
                        const backupData = {
                            ...project,
                            backupDate: new Date().toISOString()
                        };
                        const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${project.name}_backup_${new Date().toISOString().split('T')[0]}.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        showToast('üíæ Backup created');
                    } catch (e) {
                        showToast('‚ùå Error creating backup');
                    }
                    break;

                case 'star':
                    showToast('‚≠ê Added to favorites');
                    break;

                case 'lock':
                    showToast('üîí Lock feature coming soon');
                    break;

                case 'archive':
                    showToast('üì¶ Archive feature coming soon');
                    break;

                case 'delete':
                    if (confirm(`Delete "${projectName}"? This cannot be undone.`)) {
                        try {
                            await api.deleteProject(projectId);
                            showToast('üóëÔ∏è Project deleted');
                            if (currentProjectId === projectId) {
                                currentProjectId = null;
                                nodes = [];
                                connections = [];
                                renderAll();
                                renderConnections();
                            }
                            loadProjectsSideList();
                        } catch (e) {
                            showToast('‚ùå Error deleting');
                        }
                    }
                    break;
            }
        }

        function updateProjectsUserInfo() {
            const userInfo = document.getElementById('projectsUserInfo');
            const loginBtn = document.getElementById('projectsLoginBtn');

            if (currentUser) {
                userInfo.innerHTML = `
                    <span class="user-avatar">‚ú®</span>
                    <div class="user-info">
                        <span class="user-name">${currentUser.username}</span>
                        <span class="user-status">‚óè Online</span>
                    </div>
                `;
                // Hide login button when signed in - Sign Out is in header dropdown
                loginBtn.style.display = 'none';
            } else {
                userInfo.innerHTML = `
                    <span class="user-avatar">üë§</span>
                    <div class="user-info">
                        <span class="user-name">Guest User</span>
                        <span class="user-status">Not signed in</span>
                    </div>
                `;
                loginBtn.innerHTML = '<span>üîê</span> Sign In';
                loginBtn.onclick = showAuthModal;
                loginBtn.style.display = 'block';
                loginBtn.style.background = 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)';
                loginBtn.style.color = 'white';
            }
        }

        async function createNewProject() {
            const name = prompt('Project name:', 'New Project');
            if (!name) return;

            try {
                const result = await api.createProject(name);
                // Offline API returns project directly
                const projectId = result.id || result._id || (result.project && result.project._id);
                currentProjectId = projectId;
                nodes = [];
                connections = [];
                renderAll();
                renderConnections();
                updateAllStats();
                loadProjectsSideList();
                showToast('üìÅ Project created: ' + name);
            } catch (error) {
                console.error('Create project error:', error);
                showToast('‚ùå Error creating project');
            }
        }

        async function loadProject(projectId) {
            // Eƒüer aynƒ± proje zaten y√ºkl√ºyse, tekrar y√ºkleme
            if (currentProjectId === projectId) {
                showToast('üìÇ Already loaded');
                return;
            }

            try {
                const result = await api.getProject(projectId);
                // Offline API returns project directly, not wrapped
                const project = result.project || result;

                currentProjectId = project.id || project._id;
                nodes = project.nodes || [];
                connections = project.connections || [];
                povList = project.povList || [];
                descTypes = project.descTypes || [];
                revisionLabels = project.revisionLabels || [];

                // Safe ID counter calculation
                const nodeIds = nodes.map(n => parseInt(String(n.id).replace('node_', '')) || 0);
                idCounter.node = nodeIds.length > 0 ? Math.max(...nodeIds) + 1 : 1;
                const povIds = povList.map(p => p.id || 0);
                idCounter.pov = povIds.length > 0 ? Math.max(...povIds) + 1 : 1;
                const descIds = descTypes.map(d => d.id || 0);
                idCounter.desc = descIds.length > 0 ? Math.max(...descIds) + 1 : 1;

                renderAll();
                renderConnections();
                updateAllStats();
                renderOutline();
                updateSelects();
                adjustCanvasSize();

                closeProjectsModal();
                showToast('üìÇ Loaded: ' + project.name);
            } catch (error) {
                console.error('Load project error:', error);
                showToast('‚ùå Error: ' + error.message);
            }
        }

        async function deleteProject(projectId) {
            if (!confirm('Delete this project? This cannot be undone.')) return;

            try {
                await api.deleteProject(projectId);
                showToast('üóë Project deleted');

                if (currentProjectId === projectId) {
                    currentProjectId = null;
                    nodes = [];
                    connections = [];
                    renderAll();
                    renderConnections();
                }

                loadProjectsList();
            } catch (error) {
                showToast('‚ùå Error deleting project');
            }
        }

        // File handle for saving to same file
        let currentFileHandle = null;

        /// Override save function - OFFLINE MODE: Save to same file or download
        async function cloudSave() {
            const data = {
                nodes,
                connections,
                povList,
                descTypes,
                revisionLabels,
                projectName: currentProjectName,
                projectMetadata: window.projectMetadata || {},
                TASK_NODE_TYPES: TASK_NODE_TYPES,
                CUSTOM_TASK_TYPES: CUSTOM_TASK_TYPES,
                TASK_STATUSES: TASK_STATUSES,
                settings: JSON.parse(localStorage.getItem('universalWriterFontSettings')) || {},
                exportDate: new Date().toISOString()
            };
            const jsonString = JSON.stringify(data, null, 2);

            // Also save to localStorage for session restore
            try {
                localStorage.setItem('writerLastSession', jsonString);
            } catch (e) {
                console.warn('Could not save to localStorage:', e.message);
            }

            // Try to save to same file using File System Access API
            if (currentFileHandle) {
                try {
                    const writable = await currentFileHandle.createWritable();
                    await writable.write(jsonString);
                    await writable.close();
                    showToast('üíæ Saved: ' + currentProjectName + '.json');
                    return;
                } catch (err) {
                    console.warn('Could not save to same file:', err);
                    currentFileHandle = null;
                }
            }

            // If no file handle or save failed, use Save As dialog
            if (window.showSaveFilePicker) {
                try {
                    currentFileHandle = await window.showSaveFilePicker({
                        suggestedName: currentProjectName + '.json',
                        types: [{
                            description: 'JSON Files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    const writable = await currentFileHandle.createWritable();
                    await writable.write(jsonString);
                    await writable.close();
                    // Update project name from chosen file
                    currentProjectName = currentFileHandle.name.replace('.json', '');
                    showToast('üíæ Saved: ' + currentFileHandle.name);
                    return;
                } catch (err) {
                    if (err.name === 'AbortError') return; // User cancelled
                    console.warn('Save picker failed:', err);
                }
            }

            // Fallback: download file
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentProjectName + '.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('üíæ Downloaded: ' + currentProjectName + '.json');
        }

        // Auto-save to cloud
        async function cloudAutoSave() {
            // If no user or no project, skip cloud autosave (localStorage handles it)
            if (!currentUser || !currentProjectId) {
                return;
            }

            try {
                await api.autoSaveProject(currentProjectId, nodes, connections);
                console.log('Cloud autosaved');
            } catch (error) {
                console.error('Cloud autosave failed:', error);
            }
        }

        // Main autoSave function - saves to localStorage only
        function autoSave() {
            saveToLocalStorage();
        }

        // Check auth on page load (Offline mode - just check localStorage)
        async function checkAuth() { /* Disabled for offline */ }

        // ============ STATE ============
        let nodes = [];
        let connections = [];
        let povList = [];
        let descTypes = [];
        let selectedNode = null;
        let editingNodeId = null;
        let quillEditor = null; // Quill.js editor instance

        // Custom Undo/Redo system for editor (includes images)
        let editorUndoStack = [];
        let editorRedoStack = [];
        let lastEditorContent = '';
        let editingPovId = null;
        let editingDescTypeId = null;
        let isConnecting = false;
        let connectionStart = null;
        let connectionStartPos = null;
        let zoom = 1;
        let idCounter = { node: 0, pov: 0, desc: 0 };
        let tempDescs = [];
        let revisionLabels = [
            { id: 1, name: 'First Draft', bg: '#BBDEFB', text: '#1565C0' },
            { id: 2, name: 'Second Revision', bg: '#FFE0B2', text: '#E65100' },
            { id: 3, name: 'Final Draft', bg: '#C8E6C9', text: '#2E7D32' },
            { id: 4, name: 'Needs Review', bg: '#FFCDD2', text: '#C62828' },
        ];
        let revisionIdCounter = 5;
        let activeRevisionId = null;
        let draggedOutlineItem = null;

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STACK = 50;

        // Trash for deleted nodes
        let trash = [];

        // ============ TASK MANAGEMENT SYSTEM ============
        let tasks = [];
        let taskIdCounter = 1;
        let currentTaskFilter = null; // null = all, or status name

        // Customizable Task Statuses (can be modified by user)
        let TASK_STATUSES = [
            { id: 'todo', name: 'To Do', color: '#3b82f6', icon: '‚ñ¢' },
            { id: 'ongoing', name: 'On Going', color: '#f59e0b', icon: '‚óé' },
            { id: 'working', name: 'Working On', color: '#f59e0b', icon: '‚öô' },
            { id: 'review', name: 'Review', color: '#8b5cf6', icon: '‚óâ' },
            { id: 'under-review', name: 'Under Review', color: '#8b5cf6', icon: '‚äô' },
            { id: 'draft', name: 'Draft', color: '#6b7280', icon: '‚úé' },
            { id: 'complete', name: 'Complete', color: '#22c55e', icon: '‚úì' },
            { id: 'done', name: 'Done', color: '#22c55e', icon: '‚úî' },
            { id: 'sent', name: 'Sent', color: '#06b6d4', icon: '‚Üó' },
            { id: 'received', name: 'Received', color: '#06b6d4', icon: '‚Üô' },
            { id: 'closed', name: 'Closed', color: '#374151', icon: '‚äò' },
            { id: 'archived', name: 'Archived', color: '#9ca3af', icon: '‚ñ£' },
            { id: 'urgent', name: 'Urgent', color: '#ef4444', icon: '‚óè' },
            { id: 'dontforget', name: "Don't Forget", color: '#8b5cf6', icon: '‚ô•' }
        ];
        
        // ============ EARLY SANITIZATION FUNCTIONS ============
        // These must be defined early so they can be used during initialization
        
        // Check if text contains corrupted UTF-8 characters
        function hasCorruptedText(str) {
            if (!str || typeof str !== 'string') return false;
            return str.includes('√É¬∞') || str.includes('√É¬¢') || str.includes('√É¬ß') || 
                   str.includes('√Ç√Ç') || str.includes('√Ç¬∞') || str.includes('√Ç¬π') ||
                   str.includes('√É¬±') || str.includes('√É¬∂') || str.includes('√É¬º') ||
                   str.includes('√Ç|') || str.includes('√É') || str.includes('√Ç') ||
                   str.includes('√¢¬¢') || str.includes('√¢¬£') || str.includes('√¢¬•') ||
                   str.includes('√¢ ') || str.includes('√¢') || str.includes('¬©');
        }
        
        // Sanitize any text that might contain corrupted UTF-8 characters
        function sanitizeText(text) {
            if (!text || typeof text !== 'string') return text || '';
            if (hasCorruptedText(text)) {
                // Remove all corrupted character sequences
                return text.replace(/√É[¬∞¬¢¬ß¬π√¢¬µ¬∂¬±¬º]?/g, '')
                           .replace(/√Ç[¬∞¬π¬≤¬≥√Ç≈∏\|]?/g, '')
                           .replace(/[\xC0-\xFF][\x80-\xBF]*/g, '')
                           .trim();
            }
            return text;
        }
        
        // Sanitize corrupted UTF-8 icon characters
        function sanitizeCorruptedIconEarly(icon) {
            if (!icon || typeof icon !== 'string') return '‚ñ¢';
            // Check for common corruption patterns
            const corruptPatterns = ['√¢', '√É', '√Ç', '¬∞', '¬¢', '¬£', '¬•', '¬ß', '¬©', '√Ç≈∏'];
            const hasCorrupt = corruptPatterns.some(p => icon.includes(p));
            // If icon has corrupted chars or is too long, return default
            if (hasCorrupt || hasCorruptedText(icon) || icon.length > 4) {
                return '‚ñ¢';
            }
            return icon;
        }
        
        // Sanitize status object
        function sanitizeStatusEarly(status) {
            if (!status) return status;
            return {
                ...status,
                icon: sanitizeCorruptedIconEarly(status.icon)
            };
        }
        
        // Check if TASK_STATUSES array is corrupted and reset to defaults
        function sanitizeTaskStatuses(statuses) {
            if (!statuses || !Array.isArray(statuses)) return getDefaultTaskStatuses();
            
            // More aggressive corruption detection
            let hasCorruption = statuses.some(s => {
                const icon = s?.icon || '';
                const name = s?.name || '';
                // Check for common corruption patterns
                const corruptPatterns = ['√¢', '√É', '√Ç', '¬∞', '¬¢', '¬£', '¬•', '¬ß', '¬©'];
                const hasCorruptIcon = icon.length > 4 || corruptPatterns.some(p => icon.includes(p));
                const hasCorruptName = corruptPatterns.some(p => name.includes(p));
                return hasCorruptIcon || hasCorruptName || hasCorruptedText(icon) || hasCorruptedText(name);
            });
            
            if (hasCorruption) {
                console.warn('üßπ Corrupted TASK_STATUSES detected, resetting to defaults...');
                return getDefaultTaskStatuses();
            }
            
            return statuses.map(s => sanitizeStatusEarly(s));
        }
        
        // Get default task statuses (duplicated here for early access)
        function getDefaultTaskStatuses() {
            return [
                { id: 'todo', name: 'To Do', color: '#3b82f6', icon: '‚ñ¢' },
                { id: 'ongoing', name: 'On Going', color: '#f59e0b', icon: '‚óé' },
                { id: 'working', name: 'Working On', color: '#f59e0b', icon: '‚öô' },
                { id: 'review', name: 'Review', color: '#8b5cf6', icon: '‚óâ' },
                { id: 'under-review', name: 'Under Review', color: '#8b5cf6', icon: '‚äô' },
                { id: 'draft', name: 'Draft', color: '#6b7280', icon: '‚úé' },
                { id: 'complete', name: 'Complete', color: '#22c55e', icon: '‚úì' },
                { id: 'done', name: 'Done', color: '#22c55e', icon: '‚úî' },
                { id: 'sent', name: 'Sent', color: '#06b6d4', icon: '‚Üó' },
                { id: 'received', name: 'Received', color: '#06b6d4', icon: '‚Üô' },
                { id: 'closed', name: 'Closed', color: '#374151', icon: '‚äò' },
                { id: 'archived', name: 'Archived', color: '#9ca3af', icon: '‚ñ£' },
                { id: 'urgent', name: 'Urgent', color: '#ef4444', icon: '‚óè' },
                { id: 'dontforget', name: "Don't Forget", color: '#8b5cf6', icon: '‚ô•' }
            ];
        }
        
        // Get default desc types (for tag types)
        function getDefaultDescTypes() {
            return [
                { id: 1, name: 'Topic', icon: 'üìå', color: '#4CAF50' },
                { id: 2, name: 'Source', icon: 'üìö', color: '#2196F3' },
                { id: 3, name: 'Date', icon: 'üìÖ', color: '#FF9800' },
                { id: 4, name: 'Status', icon: 'üîÑ', color: '#9C27B0' },
                { id: 5, name: 'Priority', icon: '‚≠ê', color: '#f44336' },
                { id: 6, name: 'Category', icon: 'üè∑Ô∏è', color: '#E91E63' },
            ];
        }
        
        // Sanitize desc type object
        function sanitizeDescTypeEarly(descType) {
            if (!descType) return descType;
            return {
                ...descType,
                name: sanitizeText(descType.name || ''),
                icon: sanitizeCorruptedIconEarly(descType.icon)
            };
        }
        
        // Check if descTypes array is corrupted and reset to defaults
        function sanitizeDescTypes(types) {
            if (!types || !Array.isArray(types)) return getDefaultDescTypes();
            
            // Check for corruption patterns
            let hasCorruption = types.some(t => {
                const icon = t?.icon || '';
                const name = t?.name || '';
                // Check for common corruption patterns
                const corruptPatterns = ['√¢', '√É', '√Ç', '¬∞', '¬¢', '¬£', '¬•', '¬ß', '¬©'];
                const hasCorruptIcon = icon.length > 4 || corruptPatterns.some(p => icon.includes(p));
                const hasCorruptName = corruptPatterns.some(p => name.includes(p));
                return hasCorruptIcon || hasCorruptName || hasCorruptedText(icon) || hasCorruptedText(name);
            });
            
            if (hasCorruption) {
                console.warn('üßπ Corrupted descTypes detected, resetting to defaults...');
                return getDefaultDescTypes();
            }
            
            return types.map(t => sanitizeDescTypeEarly(t));
        }
        
        // Section/Node Statuses (for regular content nodes)
        const SECTION_STATUSES = [
            { id: 'none', name: 'Yok', color: '#6b7280', icon: '‚óã' },
            { id: 'draft', name: 'Taslak', color: '#f59e0b', icon: '‚úé' },
            { id: 'writing', name: 'Yaziliyor', color: '#3b82f6', icon: '‚úç' },
            { id: 'review', name: 'Inceleme', color: '#8b5cf6', icon: '‚óâ' },
            { id: 'revision', name: 'Revizyon', color: '#f97316', icon: '‚Üª' },
            { id: 'done', name: 'Tamamlandi', color: '#22c55e', icon: '‚úì' },
            { id: 'final', name: 'Final', color: '#10b981', icon: '‚òÖ' }
        ];

        // Customizable Task Types (can be modified by user)
        let CUSTOM_TASK_TYPES = [];

        // Task Node Types Configuration (Default + Custom)
        let TASK_NODE_TYPES = {
            'todo': { icon: '‚ñ¢', name: 'To Do', color: '#3b82f6' },
            'task': { icon: '‚ñ¢', name: 'Task', color: '#22c55e' },
            'research-task': { icon: '‚óé', name: 'Research Task', color: '#8b5cf6' },
            'review-task': { icon: '‚óâ', name: 'Review Task', color: '#06b6d4' },
            'edit-task': { icon: '‚úé', name: 'Edit Task', color: '#f59e0b' },
            'deadline': { icon: '‚è±', name: 'Deadline', color: '#ef4444' },
            'milestone': { icon: '‚óÜ', name: 'Milestone', color: '#22c55e' },
            'reminder': { icon: '‚ô™', name: 'Reminder', color: '#ec4899' }
        };

        const IMPORTANCE_LEVELS = [
            { id: 'low', name: 'Low', color: '#22c55e' },
            { id: 'medium', name: 'Medium', color: '#f59e0b' },
            { id: 'high', name: 'High', color: '#ef4444' },
            { id: 'critical', name: 'Critical', color: '#dc2626' }
        ];

        const DURATION_TYPES = [
            { id: 'minutes', name: 'Minutes' },
            { id: 'hours', name: 'Hours' },
            { id: 'days', name: 'Days' },
            { id: 'weeks', name: 'Weeks' },
            { id: 'months', name: 'Months' }
        ];

        // Special Node Types (Folder, Sticky Note, Image)
        const SPECIAL_NODE_TYPES = {
            'folder': { icon: '‚ñ§', name: 'Folder', color: '#3b82f6' },
            'sticky': { icon: '‚ñ¶', name: 'Sticky Note', color: '#fde047' },
            'image': { icon: '‚ñ£', name: 'Image', color: '#8b5cf6' }
        };

        // Sticky Note Colors
        const STICKY_COLORS = [
            { id: 'yellow', name: 'Sarƒ±', color: '#fde047' },
            { id: 'red', name: 'Kƒ±rmƒ±zƒ± (Important)', color: '#f87171' },
            { id: 'green', name: 'Ye≈üil (Done/Idea)', color: '#4ade80' },
            { id: 'blue', name: 'Mavi (Info)', color: '#60a5fa' },
            { id: 'purple', name: 'Mor (Creative)', color: '#a78bfa' },
            { id: 'orange', name: 'Turuncu (Don\'t Forget)', color: '#fb923c' },
            { id: 'pink', name: 'Pembe', color: '#f472b6' }
        ];

        // Sticky Note Tags
        const STICKY_TAGS = [
            { id: 'none', name: 'Yok', class: '' },
            { id: 'important', name: '‚óè Important', class: 'important' },
            { id: 'idea', name: '‚òÖ Idea', class: 'idea' },
            { id: 'todo', name: '‚ñ¢ To Do', class: 'todo' },
            { id: 'done', name: '‚úì Done', class: 'done' },
            { id: 'dont-forget', name: '! Don\'t Forget', class: 'dont-forget' }
        ];

        // Folder Colors
        const FOLDER_COLORS = [
            { id: 'blue', name: 'Mavi', color: '#3b82f6' },
            { id: 'red', name: 'Kƒ±rmƒ±zƒ±', color: '#ef4444' },
            { id: 'green', name: 'Ye≈üil', color: '#22c55e' },
            { id: 'purple', name: 'Mor', color: '#a855f7' },
            { id: 'orange', name: 'Turuncu', color: '#f97316' },
            { id: 'yellow', name: 'Sarƒ±', color: '#eab308' },
            { id: 'pink', name: 'Pembe', color: '#ec4899' },
            { id: 'gray', name: 'Gri', color: '#6b7280' }
        ];

        // Folder Types/Categories
        const FOLDER_TYPES = [
            { id: 'general', name: 'Genel', icon: '‚ñ§' },
            { id: 'important', name: 'Onemli', icon: '‚òÖ' },
            { id: 'personal', name: 'Kisisel', icon: '‚óâ' },
            { id: 'private', name: 'Ozel', icon: '‚äò' },
            { id: 'school', name: 'Okul', icon: '‚óà' },
            { id: 'work', name: 'Is', icon: '‚ñ£' },
            { id: 'travel', name: 'Gezi', icon: '‚ñ∏' },
            { id: 'project', name: 'Proje', icon: '‚ñ¢' }
        ];

        // Canvas Constants
        const CANVAS_WIDTH = 5000;
        const CANVAS_HEIGHT = 3000;

        const canvas = document.getElementById('canvas');
        const connectionsEl = document.getElementById('connections');
        const canvasContainer = document.getElementById('canvasContainer');

        // ============ INITIALIZE ============
        function init() {
            povList = [
                { id: 1, name: 'Primary Author', color: '#e94560', desc: 'Main contributor' },
                { id: 2, name: 'Co-Author', color: '#4fc3f7', desc: 'Secondary contributor' },
                { id: 3, name: 'Reviewer', color: '#ff6b9d', desc: 'Review & feedback' },
                { id: 4, name: 'Editor', color: '#a5d6a7', desc: 'Editing & proofreading' },
            ];
            idCounter.pov = 5;

            descTypes = getDefaultDescTypes();
            idCounter.desc = 7;

            // First load settings
            loadAppSettings();

            // Try to restore last session from localStorage
            const lastSession = localStorage.getItem('writerLastSession');
            if (lastSession) {
                try {
                    const data = JSON.parse(lastSession);
                    nodes = data.nodes || [];
                    connections = data.connections || [];
                    povList = data.povList || povList;
                    descTypes = data.descTypes ? sanitizeDescTypes(data.descTypes) : descTypes;
                    revisionLabels = data.revisionLabels || [];
                    currentProjectName = data.projectName || 'Untitled';
                    window.projectMetadata = data.projectMetadata || {};

                    // Load task types if saved (skip if corrupted - will load from separate storage)
                    // Don't load TASK_NODE_TYPES and CUSTOM_TASK_TYPES from session - use loadTaskTypesFromStorage() instead
                    if (data.TASK_STATUSES) {
                        TASK_STATUSES = sanitizeTaskStatuses(data.TASK_STATUSES);
                    }

                    // ID counter'larƒ± g√ºncelle
                    const nodeIds = nodes.map(n => parseInt(String(n.id).replace('node_', '')) || 0);
                    idCounter.node = nodeIds.length > 0 ? Math.max(...nodeIds) + 1 : 1;

                    console.log('üìÇ Restored last session:', nodes.length, 'nodes');
                } catch (e) {
                    console.warn('Could not restore last session:', e);
                    nodes = [];
                    connections = [];
                    currentProjectId = null;
                }
            } else {
                // Start with empty canvas
                nodes = [];
                connections = [];
                currentProjectId = null;
            }

            // ALWAYS load task types from localStorage (separate storage for reliability)
            loadTaskTypesFromStorage();

            try {
                // Apply task type styles (for edited default types)
                applyTaskTypeStyles();
                renderAll();
                updateAllStats();
                renderOutline();
                updateSelects();
                // Update task dropdown with custom types
                updateNewTaskDropdown();
                updateAddTaskMenuTypes();
                // Set default tab to Outline
                switchTab('outline');
                // Update file panel if session was restored
                if (nodes.length > 0 && currentProjectName) {
                    document.getElementById('currentFileName').textContent = currentProjectName + '.json';
                    updateFilePanelStats();
                }
            } catch(e) {
                console.error('Error rendering:', e);
            }

            // Adjust canvas size based on content
            adjustCanvasSize();

            // Start auto-save
            startAutoSave();

            // Initialize connection menu listeners
            initConnectionMenuListeners();

            // Check auth status
            checkAuth();
        }

        function loadBookData() {
            nodes = [
                // Root - Project Overview
                { id: 1, type: 'abstract', title: 'Project Overview', summary: 'AI in Healthcare - Research Summary', fullText: 'This research project explores the applications of artificial intelligence in modern healthcare systems.\n\nKey Areas:\n‚Ä¢ Diagnostic imaging analysis\n‚Ä¢ Patient data management\n‚Ä¢ Predictive analytics\n‚Ä¢ Treatment optimization', povId: 1, descs: [{tid:1,val:'AI Healthcare'},{tid:4,val:'In Progress'}], notes: '', x: 550, y: 50, parentId: null, collapsed: false, target: 500, attachments: [] },

                // Literature Review - Parent folder
                { id: 2, type: 'group', title: 'Literature Review', summary: 'Background research and sources', fullText: '', povId: 1, descs: [{tid:6,val:'Research'}], notes: '', x: 100, y: 250, parentId: null, collapsed: false, target: 0, attachments: [] },
                { id: 3, type: 'research', title: 'AI Diagnostics Studies', summary: 'Medical imaging AI research', fullText: 'Key findings from recent studies on AI-powered diagnostic tools:\n\n1. Stanford Study (2024): 94% accuracy\n2. MIT Research: Deep learning for radiology', povId: 2, descs: [{tid:2,val:'Stanford, MIT'}], notes: '', x: 130, y: 450, parentId: 2, collapsed: false, target: 300, attachments: [] },
                { id: 4, type: 'reference', title: 'Key Citations', summary: 'Important references', fullText: '‚Ä¢ Smith et al. (2024) - Machine Learning in Medicine\n‚Ä¢ Johnson & Lee (2023) - Ethics of AI Diagnostics', povId: null, descs: [{tid:2,val:'Academic Papers'}], notes: '', x: 130, y: 650, parentId: 2, collapsed: false, target: 200, attachments: [] },

                // Methodology - Parent folder
                { id: 5, type: 'group', title: 'Methodology', summary: 'Research methods and approach', fullText: '', povId: 1, descs: [{tid:6,val:'Methods'}], notes: '', x: 400, y: 250, parentId: null, collapsed: false, target: 0, attachments: [] },
                { id: 6, type: 'section', title: 'Data Collection', summary: 'Survey and interview methods', fullText: 'Data collection methodology:\n\n1. Survey Design\n- 500 healthcare professionals\n- Online questionnaire', povId: 1, descs: [{tid:4,val:'Completed'}], notes: '', x: 430, y: 450, parentId: 5, collapsed: false, target: 400, attachments: [] },
                { id: 7, type: 'section', title: 'Analysis Framework', summary: 'Statistical methods used', fullText: 'Analysis approach:\n\n‚Ä¢ Quantitative: SPSS statistical analysis\n‚Ä¢ Qualitative: Thematic coding', povId: 2, descs: [{tid:4,val:'In Progress'}], notes: '', x: 430, y: 650, parentId: 5, collapsed: false, target: 350, attachments: [] },

                // Findings - Parent folder
                { id: 8, type: 'group', title: 'Findings', summary: 'Research results and insights', fullText: '', povId: 1, descs: [{tid:6,val:'Results'}], notes: '', x: 700, y: 250, parentId: null, collapsed: false, target: 0, attachments: [] },
                { id: 9, type: 'draft', title: 'Key Results', summary: 'Main findings from research', fullText: 'Preliminary findings:\n\n1. 78% of hospitals plan to implement AI within 5 years\n2. Main barriers: cost, training, data privacy', povId: 1, descs: [{tid:5,val:'High'}], notes: '', x: 730, y: 450, parentId: 8, collapsed: false, target: 500, attachments: [] },
                { id: 10, type: 'note', title: 'Discussion Points', summary: 'Items to address', fullText: '‚ö†Ô∏è Need to verify:\n- Sample size adequacy\n- Regional bias in responses', povId: null, descs: [{tid:5,val:'Medium'}], notes: '', x: 730, y: 650, parentId: 8, collapsed: false, target: 150, attachments: [] },

                // Final Sections
                { id: 11, type: 'conclusion', title: 'Conclusions', summary: 'Summary and recommendations', fullText: 'AI integration in healthcare shows significant promise but requires standardized frameworks.', povId: 1, descs: [{tid:4,val:'Pending Review'}], notes: '', x: 1000, y: 250, parentId: null, collapsed: false, target: 400, attachments: [] },
                { id: 12, type: 'appendix', title: 'Survey Questions', summary: 'Full questionnaire', fullText: 'Appendix A: Survey Questionnaire\n\nSection 1: Demographics', povId: null, descs: [], notes: '', x: 1000, y: 500, parentId: null, collapsed: false, target: 100, attachments: [] },
            ];
            idCounter.node = 13;

            connections = [];
        }

        // ============ HIERARCHY HELPERS ============
        function getChildren(parentId) {
            // Handle both string and number ID comparisons
            const directChildren = nodes.filter(n => String(n.parentId) === String(parentId));
            
            // Also include tasks that depend on this task (if parentId is a task node)
            const parentNode = nodes.find(n => String(n.id) === String(parentId));
            if (parentNode && (parentNode.isTaskNode || TASK_NODE_TYPES[parentNode.type])) {
                // Find tasks that have this task as a dependency (successors)
                const dependentTasks = nodes.filter(n => {
                    if (!n.taskDependencies || n.taskDependencies.length === 0) return false;
                    // Check if this task depends on the parent task
                    return n.taskDependencies.some(d => String(d.taskId) === String(parentId));
                });
                
                // Add dependent tasks that are not already children
                dependentTasks.forEach(dt => {
                    if (!directChildren.some(c => String(c.id) === String(dt.id))) {
                        directChildren.push(dt);
                    }
                });
            }
            
            return directChildren;
        }

        // Check if a node is a descendant of another node (to prevent circular references)
        function isDescendantOf(nodeId, potentialAncestorId) {
            let current = nodes.find(n => n.id === nodeId);
            while (current && current.parentId) {
                if (current.parentId === potentialAncestorId) return true;
                current = nodes.find(n => n.id === current.parentId);
            }
            return false;
        }

        // Get node element at specific screen coordinates
        function getDropTargetNode(clientX, clientY, excludeId) {
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();

            for (const node of nodes) {
                if (node.id === excludeId) continue;

                const nodeEl = document.querySelector(`.node[data-id="${node.id}"]`);
                if (!nodeEl) continue;

                const rect = nodeEl.getBoundingClientRect();
                if (clientX >= rect.left && clientX <= rect.right &&
                    clientY >= rect.top && clientY <= rect.bottom) {
                    return node;
                }
            }
            return null;
        }

        // Highlight the drop target node
        function highlightDropTarget(clientX, clientY, excludeId) {
            clearDropHighlights();

            const targetNode = getDropTargetNode(clientX, clientY, excludeId);
            if (targetNode) {
                const targetEl = document.querySelector(`.node[data-id="${targetNode.id}"]`);
                if (targetEl) {
                    targetEl.classList.add('drop-target-highlight');
                }
            }
        }

        // Clear all drop highlights
        function clearDropHighlights() {
            document.querySelectorAll('.drop-target-highlight').forEach(el => {
                el.classList.remove('drop-target-highlight');
            });
        }

        // Make a node a child of another node
        function makeNodeChild(childId, parentId) {
            const childNode = nodes.find(n => n.id === childId);
            const parentNode = nodes.find(n => n.id === parentId);

            if (!childNode || !parentNode) return;

            // Prevent making a node a child of its own descendant
            if (isDescendantOf(parentId, childId)) {
                showToast('‚ö†Ô∏è Cannot make a parent into its own child!');
                return;
            }

            // Prevent making a node a child of itself
            if (childId === parentId) return;

            // Already a child of this parent?
            if (childNode.parentId === parentId) {
                showToast('Already a child of this node');
                return;
            }

            const oldParentId = childNode.parentId;
            childNode.parentId = parentId;

            // Ensure parent is not collapsed so the new child is visible
            if (parentNode.collapsed) {
                parentNode.collapsed = false;
            }

            renderAll();
            renderOutline();
            renderConnections();

            showToast(`üìÅ "${childNode.title}" ‚Üí child of "${parentNode.title}"`);
        }

        // Remove parent relationship (make root level)
        function removeParent(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (node && node.parentId) {
                const oldParent = nodes.find(n => n.id === node.parentId);
                node.parentId = null;
                renderAll();
                renderOutline();
                renderConnections();
                showToast(`üì§ "${node.title}" moved to root level`);
            }
        }

        function countAllDescendants(parentId) {
            let count = 0;
            const children = getChildren(parentId);
            count += children.length;
            children.forEach(child => {
                count += countAllDescendants(child.id);
            });
            return count;
        }

        function toggleCollapse(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                node.collapsed = !node.collapsed;
                renderAll();
                renderOutline();
            }
        }

        // Collapse/Expand All functions
        function collapseAll() {
            nodes.forEach(n => {
                if (getChildren(n.id).length > 0) {
                    n.collapsed = true;
                }
            });
            renderAll();
            renderOutline();
            renderConnections();
            showToast('‚ñ∂ All collapsed');
        }

        function expandAll() {
            nodes.forEach(n => n.collapsed = false);
            renderAll();
            renderOutline();
            renderConnections();
            showToast('‚ñº All expanded');
        }

        function collapseToLevel(level) {
            // Get node level
            function getNodeLevel(node) {
                let lvl = 0;
                let current = node;
                while (current.parentId) {
                    lvl++;
                    current = nodes.find(n => n.id === current.parentId);
                    if (!current) break;
                }
                return lvl;
            }

            nodes.forEach(n => {
                const nodeLevel = getNodeLevel(n);
                const hasChildren = getChildren(n.id).length > 0;
                if (hasChildren) {
                    // Collapse if at or below the target level
                    n.collapsed = nodeLevel >= level;
                }
            });
            renderAll();
            renderOutline();
            renderConnections();
            showToast(`üìä Collapsed to level ${level}`);
        }

        // ============ RENDER ============
        function isNodeHidden(node) {
            // Check if any ancestor is collapsed
            let current = node;
            while (current.parentId) {
                const parent = nodes.find(n => n.id === current.parentId);
                if (!parent) break;
                if (parent.collapsed) return true;
                current = parent;
            }
            return false;
        }

        function countHiddenDescendants(nodeId) {
            // Count all descendants when collapsed
            let count = 0;
            const children = getChildren(nodeId);
            children.forEach(child => {
                count++;
                count += countHiddenDescendants(child.id);
            });
            return count;
        }

        function renderAll() {
            canvas.innerHTML = '';
            nodes.forEach(n => {
                if (!isNodeHidden(n)) {
                    renderNode(n);
                }
            });
            renderConnections();
        }

        // ============ RENDER SPECIAL NODES (FOLDER, STICKY, IMAGE) ============
        function renderSpecialNode(el, node) {
            el.id = `node-${node.id}`;
            el.style.left = node.x + 'px';
            el.style.top = node.y + 'px';
            el.style.position = 'absolute';

            if (node.type === 'folder') {
                // FOLDER NODE with color and type support
                el.className = 'folder-node' + (selectedNode === node.id ? ' selected' : '');

                const files = node.folderFiles || [];
                const fileCount = files.length;
                const folderColor = node.folderColor || 'blue';
                const folderType = node.folderType || 'general';
                const colorInfo = FOLDER_COLORS.find(c => c.id === folderColor) || FOLDER_COLORS[0];
                const typeInfo = FOLDER_TYPES.find(t => t.id === folderType) || FOLDER_TYPES[0];

                // Calculate total size
                let totalSize = 0;
                files.forEach(f => {
                    if (f.size) totalSize += f.size;
                });
                const sizeText = totalSize > 0 ? formatFileSize(totalSize) : '';

                // Set folder color as CSS variable
                el.style.setProperty('--folder-color', colorInfo.color);

                el.innerHTML = `
                    <div class="folder-node-header" style="background: ${colorInfo.color};">
                        <div class="folder-node-icon">${typeInfo.icon}</div>
                        <div class="folder-node-title">${node.title || 'Klas√∂r'}</div>
                        <div class="folder-node-count">${fileCount}</div>
                    </div>
                    <div class="folder-node-body">
                        <span class="folder-info-icon">üìÑ</span>
                        <span class="folder-info-text">${fileCount === 0 ? 'Bo≈ü' : fileCount + ' dosya'}${sizeText ? ' ‚Ä¢ ' + sizeText : ''}</span>
                    </div>
                    <div class="conn-point top" data-id="${node.id}" data-pos="top"></div>
                    <div class="conn-point bottom" data-id="${node.id}" data-pos="bottom"></div>
                    <div class="conn-point left" data-id="${node.id}" data-pos="left"></div>
                    <div class="conn-point right" data-id="${node.id}" data-pos="right"></div>
                `;

            } else if (node.type === 'sticky') {
                // STICKY NOTE NODE
                const stickyColor = node.stickyColor || 'yellow';
                const stickyTag = node.stickyTag || 'none';
                const tagInfo = STICKY_TAGS.find(t => t.id === stickyTag) || STICKY_TAGS[0];

                el.className = 'sticky-node color-' + stickyColor + (selectedNode === node.id ? ' selected' : '');

                let tagHtml = '';
                if (stickyTag && stickyTag !== 'none') {
                    tagHtml = `<span class="sticky-node-tag ${tagInfo.class}">${tagInfo.name.split(' ')[0]}</span>`;
                }

                el.innerHTML = `
                    <div class="sticky-node-header">
                        <div class="sticky-node-title">${node.title || 'Not'}</div>
                        <div class="sticky-node-pin">üìå</div>
                    </div>
                    <div class="sticky-node-body">
                        <div class="sticky-node-content">${node.summary || node.stickyContent || 'ƒ∞√ßerik ekle...'}</div>
                    </div>
                    <div class="sticky-node-footer">
                        ${tagHtml}
                        <span></span>
                    </div>
                    <div class="conn-point top" data-id="${node.id}" data-pos="top"></div>
                    <div class="conn-point bottom" data-id="${node.id}" data-pos="bottom"></div>
                    <div class="conn-point left" data-id="${node.id}" data-pos="left"></div>
                    <div class="conn-point right" data-id="${node.id}" data-pos="right"></div>
                `;

            } else if (node.type === 'image') {
                // IMAGE NODE - with size and color support
                const imageSize = node.imageSize || 'medium';
                const imageColor = node.imageColor || 'purple';
                const colorInfo = STICKY_COLORS.find(c => c.id === imageColor) || STICKY_COLORS[4]; // Default purple
                
                const sizeClass = 'size-' + imageSize;
                el.className = 'image-node ' + sizeClass + (selectedNode === node.id ? ' selected' : '');
                el.style.borderColor = colorInfo.color;
                el.style.boxShadow = `0 4px 16px ${colorInfo.color}22`;

                let previewHtml = '';
                if (node.imageData || node.imageSrc) {
                    previewHtml = `
                        <img src="${node.imageData || node.imageSrc}" alt="${node.title || 'Image'}" onload="renderConnections()">
                        <div class="image-node-overlay">
                            <div class="image-node-actions">
                                <button class="image-node-action-btn" onclick="event.stopPropagation(); viewImageFullscreen('${node.id}')" title="Tam Ekran">üîç</button>
                                <button class="image-node-action-btn" onclick="event.stopPropagation(); changeNodeImage('${node.id}')" title="Deƒüi≈ütir">üîÑ</button>
                            </div>
                        </div>
                    `;
                } else {
                    previewHtml = `
                        <div class="image-node-placeholder" onclick="event.stopPropagation(); selectNodeImage('${node.id}')">
                            <div class="image-node-placeholder-icon">üñºÔ∏è</div>
                            <div>Resim ekle</div>
                        </div>
                    `;
                }

                el.innerHTML = `
                    <div class="image-node-preview">
                        ${previewHtml}
                    </div>
                    <div class="image-node-body">
                        <div class="image-node-title">${node.title || 'Untitled'}</div>
                        ${node.imageCaption || node.summary ? `<div class="image-node-caption">${node.imageCaption || node.summary}</div>` : ''}
                    </div>
                    <div class="conn-point top" data-id="${node.id}" data-pos="top"></div>
                    <div class="conn-point bottom" data-id="${node.id}" data-pos="bottom"></div>
                    <div class="conn-point left" data-id="${node.id}" data-pos="left"></div>
                    <div class="conn-point right" data-id="${node.id}" data-pos="right"></div>
                `;
            }

            canvas.appendChild(el);
            
            // Force connection re-render after special node is added to DOM
            requestAnimationFrame(() => {
                renderConnections();
            });

            // ============ USE SAME DRAG SYSTEM AS REGULAR NODES ============
            let dragging = false, startX, startY, initX, initY;
            let currentDragNode = null;
            let hasMoved = false;
            let undoSaved = false;
            const GRID_SIZE = 25;

            function snapToGrid(value) {
                return Math.round(value / GRID_SIZE) * GRID_SIZE;
            }

            el.addEventListener('mousedown', e => {
                if (e.target.classList.contains('conn-point')) return;
                if (e.target.classList.contains('folder-indicator')) return;
                if (e.target.closest('.folder-file-item')) return;
                if (e.target.closest('.image-node-action-btn')) return;
                if (e.target.closest('.image-node-placeholder')) return;
                if (e.button !== 0) return;

                dragging = true;
                hasMoved = false;
                undoSaved = false;
                currentDragNode = node;
                startX = e.clientX;
                startY = e.clientY;
                initX = node.x || 0;
                initY = node.y || 0;
                selectNode(node.id);
                el.style.zIndex = '1000';
                el.style.opacity = '0.8';
                e.preventDefault();
            });

            document.addEventListener('mousemove', e => {
                if (!dragging || !currentDragNode || currentDragNode.id !== node.id) return;
                
                // Check if actually moved (more than 5px)
                const moveDistance = Math.abs(e.clientX - startX) + Math.abs(e.clientY - startY);
                if (moveDistance > 5 && !undoSaved) {
                    saveUndoState('move node');
                    undoSaved = true;
                }
                
                if (moveDistance > 5) {
                    hasMoved = true;
                }
                
                let newX = Math.max(0, initX + (e.clientX - startX) / zoom);
                let newY = Math.max(0, initY + (e.clientY - startY) / zoom);

                node.x = snapToGrid(newX);
                node.y = snapToGrid(newY);

                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';
                
                // Render connections directly - uses predefined dimensions for special nodes
                renderConnections();
                highlightDropTarget(e.clientX, e.clientY, node.id);
            });

            document.addEventListener('mouseup', e => {
                if (!dragging || !currentDragNode || currentDragNode.id !== node.id) return;

                el.style.zIndex = '';
                el.style.opacity = '1';

                node.x = snapToGrid(node.x);
                node.y = snapToGrid(node.y);
                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';

                const dropTarget = getDropTargetNode(e.clientX, e.clientY, node.id);
                if (dropTarget && !e.shiftKey) {
                    makeNodeChild(node.id, dropTarget.id);
                }

                clearDropHighlights();
                dragging = false;
                currentDragNode = null;
                saveToLocalStorage();
            });

            // Connection points
            el.querySelectorAll('.conn-point').forEach(cp => {
                cp.addEventListener('click', e => {
                    e.stopPropagation();
                    handleConnClick(node.id, cp.dataset.pos);
                });
                cp.addEventListener('mousedown', e => {
                    e.stopPropagation();
                    e.preventDefault();
                    startConnectionDrag(node.id, cp.dataset.pos, e.clientX, e.clientY);
                });
            });

            // Double click = open properties
            el.addEventListener('dblclick', e => {
                if (e.target.closest('.folder-file-item')) return;
                if (e.target.closest('.image-node-action-btn')) return;
                selectNode(node.id);
                if (!propertiesPanelVisible) togglePropertiesPanel();
                updatePropertiesPanel(node.id);
            });

            // Right click = context menu
            el.addEventListener('contextmenu', e => {
                e.preventDefault();
                selectNode(node.id);
                showSpecialNodeContextMenu(e, node);
            });
        }

        // Context menu for special nodes
        function showSpecialNodeContextMenu(e, node) {
            hideAllMenus();

            let menu = document.getElementById('specialNodeContextMenu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'specialNodeContextMenu';
                menu.className = 'context-menu';
                document.body.appendChild(menu);
            }

            const typeInfo = SPECIAL_NODE_TYPES[node.type] || { icon: 'üìÑ', name: 'Node' };

            menu.innerHTML = `
                <div class="context-menu-header">${typeInfo.icon} ${node.title}</div>
                <div class="context-menu-item" onclick="openSpecialNodeEditor('${node.id}'); hideAllMenus();">
                    <span class="item-icon">‚úèÔ∏è</span> D√ºzenle
                </div>
                ${node.type === 'folder' ? `
                <div class="context-menu-item" onclick="addFilesToFolder('${node.id}'); hideAllMenus();">
                    <span class="item-icon">üìÅ</span> Dosya Ekle
                </div>
                ` : ''}
                ${node.type === 'image' ? `
                <div class="context-menu-item" onclick="selectNodeImage('${node.id}'); hideAllMenus();">
                    <span class="item-icon">üñºÔ∏è</span> Resim Se√ß
                </div>
                ` : ''}
                <div class="context-menu-divider"></div>
                <div class="context-menu-item" onclick="duplicateSpecialNode('${node.id}'); hideAllMenus();">
                    <span class="item-icon">üìã</span> Kopyala
                </div>
                <div class="context-menu-divider"></div>
                <div class="context-menu-item" style="color:#ef4444;" onclick="deleteNodeById('${node.id}'); hideAllMenus();">
                    <span class="item-icon">üóëÔ∏è</span> Sil
                </div>
            `;

            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
            menu.classList.add('active');

            // Adjust position if off-screen
            setTimeout(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
                }
            }, 10);
        }

        function editSpecialNode(nodeId) {
            selectNode(nodeId);
            if (!propertiesPanelVisible) {
                togglePropertiesPanel();
            }
            updatePropertiesPanel(nodeId);
        }

        // Open Special Node Editor Modal
        function openSpecialNodeEditor(nodeId) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;

            selectNode(nodeId);

            // ALWAYS remove and recreate modal for fresh content
            let existingModal = document.getElementById('specialNodeEditorModal');
            if (existingModal) {
                existingModal.remove();
            }

            let modal = document.createElement('div');
            modal.id = 'specialNodeEditorModal';
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 id="specialEditorTitle">D√ºzenle</h3>
                        <button class="modal-close" onclick="closeModal('specialNodeEditorModal')">√ó</button>
                    </div>
                    <div class="modal-body" id="specialEditorBody"></div>
                    <div class="modal-footer">
                        <button class="btn btn-secondary" onclick="closeModal('specialNodeEditorModal')">‚úï ƒ∞ptal</button>
                        <button class="btn btn-primary" onclick="saveSpecialNodeEditor()">üíæ Kaydet</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            const typeInfo = SPECIAL_NODE_TYPES[node.type] || { icon: 'üìÑ', name: 'Node' };
            document.getElementById('specialEditorTitle').innerHTML = `${typeInfo.icon} ${typeInfo.name} D√ºzenle`;

            let bodyHtml = '';

            if (node.type === 'folder') {
                const files = node.folderFiles || [];

                // Calculate total size
                let totalSize = 0;
                files.forEach(f => { if (f.size) totalSize += f.size; });

                // Get file type from extension
                function getFileType(filename) {
                    const ext = filename.split('.').pop().toLowerCase();
                    const types = {
                        'pdf': 'PDF', 'doc': 'Word', 'docx': 'Word',
                        'xls': 'Excel', 'xlsx': 'Excel', 'ppt': 'PPT', 'pptx': 'PPT',
                        'jpg': 'JPEG', 'jpeg': 'JPEG', 'png': 'PNG', 'gif': 'GIF', 'webp': 'WebP',
                        'mp4': 'Video', 'mov': 'Video', 'avi': 'Video', 'mkv': 'Video',
                        'mp3': 'Audio', 'wav': 'Audio', 'ogg': 'Audio',
                        'zip': 'Ar≈üiv', 'rar': 'Ar≈üiv', '7z': 'Ar≈üiv',
                        'txt': 'Metin', 'html': 'HTML', 'css': 'CSS', 'js': 'JS', 'json': 'JSON'
                    };
                    return types[ext] || ext.toUpperCase();
                }

                // Folder color and type options
                const folderColor = node.folderColor || 'blue';
                const folderType = node.folderType || 'general';

                const colorOptions = FOLDER_COLORS.map(c =>
                    `<div onclick="setFolderEditorColor('${c.id}')" class="folder-color-option ${folderColor === c.id ? 'selected' : ''}" style="background:${c.color};" title="${c.name}"></div>`
                ).join('');

                const typeOptions = FOLDER_TYPES.map(t =>
                    `<option value="${t.id}" ${folderType === t.id ? 'selected' : ''}>${t.icon} ${t.name}</option>`
                ).join('');

                const fileListHtml = files.length === 0
                    ? `<div class="folder-empty">
                        <div class="folder-empty-icon">üìÇ</div>
                        <div>Klas√∂r bo≈ü</div>
                       </div>`
                    : `<table class="folder-files-table">
                        <thead>
                            <tr>
                                <th style="width:40px;"></th>
                                <th>Dosya Adƒ±</th>
                                <th style="width:70px;">T√ºr</th>
                                <th style="width:80px;">Boyut</th>
                                <th style="width:90px;">ƒ∞≈ülem</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${files.map((f, i) => `
                            <tr>
                                <td class="file-icon">${getFileIconByName(f.name)}</td>
                                <td class="file-name" title="${escapeHtml(f.name)}">${escapeHtml(f.name)}</td>
                                <td class="file-type">${getFileType(f.name)}</td>
                                <td class="file-size">${formatFileSize(f.size)}</td>
                                <td class="file-actions">
                                    <button type="button" class="file-action-btn preview-btn" onclick="event.preventDefault(); event.stopPropagation(); previewFolderFile('${nodeId}', ${i});" title="√ñnizle">üëÅÔ∏è</button>
                                    <button type="button" class="file-action-btn delete-btn" onclick="event.preventDefault(); event.stopPropagation(); removeFolderFileFromEditor('${nodeId}', ${i});" title="Sil">‚úï</button>
                                </td>
                            </tr>
                            `).join('')}
                        </tbody>
                       </table>`;

                bodyHtml = `
                    <div class="folder-editor-wide">
                        <div class="folder-editor-top">
                            <div class="form-group">
                                <label>üìå Klas√∂r Adƒ±</label>
                                <input type="text" id="specialEditTitle" class="form-control" value="${escapeHtml(node.title || '')}">
                            </div>
                            <div class="form-group">
                                <label>üìÅ Klas√∂r T√ºr√º</label>
                                <select id="specialEditFolderType" class="form-control">
                                    ${typeOptions}
                                </select>
                            </div>
                            <div class="form-group">
                                <label>üé® Renk</label>
                                <div class="folder-color-grid" id="folderColorPicker">
                                    ${colorOptions}
                                </div>
                                <input type="hidden" id="specialEditFolderColor" value="${folderColor}">
                            </div>
                            <div class="folder-editor-stats-inline">
                                <div class="folder-stat-inline">
                                    <span class="stat-label">Dosya:</span>
                                    <span class="stat-value">${files.length}</span>
                                </div>
                                <div class="folder-stat-inline">
                                    <span class="stat-label">Boyut:</span>
                                    <span class="stat-value">${formatFileSize(totalSize)}</span>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>üìÇ Dosyalar</label>
                            <div class="folder-files-container">
                                ${fileListHtml}
                            </div>
                            <button class="folder-add-btn" type="button" onclick="event.preventDefault(); event.stopPropagation(); addFilesToFolderFromEditor('${nodeId}');">
                                <span>‚ûï</span> Dosya Ekle
                            </button>
                        </div>
                    </div>
                `;
            } else if (node.type === 'sticky') {
                const colorOptions = STICKY_COLORS.map(c =>
                    `<div onclick="setSpecialEditorColor('${c.id}')" id="colorOpt_${c.id}" class="sticky-color-option ${node.stickyColor === c.id ? 'selected' : ''}" style="background:${c.color};" title="${c.name}"></div>`
                ).join('');

                const tagOptions = STICKY_TAGS.map(t =>
                    `<option value="${t.id}" ${node.stickyTag === t.id ? 'selected' : ''}>${t.name}</option>`
                ).join('');

                bodyHtml = `
                    <div class="sticky-editor-new">
                        <div class="sticky-editor-top-row">
                            <div class="form-group" style="flex:1;">
                                <label>üìå Ba≈ülƒ±k</label>
                                <input type="text" id="specialEditTitle" class="form-control" value="${escapeHtml(node.title || '')}">
                            </div>
                            <div class="form-group" style="width:180px;">
                                <label>üè∑Ô∏è Etiket</label>
                                <select id="specialEditTag" class="form-control">
                                    ${tagOptions}
                                </select>
                            </div>
                            <div class="form-group">
                                <label>üé® Renk</label>
                                <div class="sticky-color-grid" id="stickyColorPicker">
                                    ${colorOptions}
                                </div>
                                <input type="hidden" id="specialEditColor" value="${node.stickyColor || 'yellow'}">
                            </div>
                        </div>
                        <div class="form-group sticky-content-full">
                            <label>üìù Not ƒ∞√ßeriƒüi</label>
                            <textarea id="specialEditContent" class="form-control sticky-textarea-large" placeholder="Notunuzu buraya yazƒ±n...">${escapeHtml(node.summary || node.stickyContent || '')}</textarea>
                        </div>
                    </div>
                `;
            } else if (node.type === 'image') {
                const hasImage = node.imageData || node.imageSrc;
                const previewHtml = hasImage
                    ? `<img src="${node.imageData || node.imageSrc}">`
                    : `<div class="image-editor-placeholder">
                        <div class="image-editor-placeholder-icon">üñºÔ∏è</div>
                        <div>Resim se√ßilmedi</div>
                       </div>`;

                const currentSize = node.imageSize || 'medium';

                bodyHtml = `
                    <div class="image-editor-new">
                        <div class="image-editor-top">
                            <div class="image-editor-preview ${hasImage ? 'has-image' : ''}" id="imagePreviewContainer">
                                ${previewHtml}
                                <button class="image-change-btn" onclick="selectImageForEditor('${nodeId}')">
                                    ${hasImage ? 'üîÑ Deƒüi≈ütir' : '‚ûï Resim Se√ß'}
                                </button>
                            </div>
                            <div class="image-editor-info">
                                <div class="form-group">
                                    <label>üìå Ba≈ülƒ±k</label>
                                    <input type="text" id="specialEditTitle" class="form-control" value="${escapeHtml(node.title || '')}">
                                </div>
                                <div class="form-group">
                                    <label>üìê G√∂r√ºnt√º Boyutu</label>
                                    <div class="image-size-selector">
                                        <button type="button" class="image-size-btn ${currentSize === 'small' ? 'selected' : ''}" onclick="setImageSize('small')">
                                            S<small>120</small>
                                        </button>
                                        <button type="button" class="image-size-btn ${currentSize === 'medium' ? 'selected' : ''}" onclick="setImageSize('medium')">
                                            M<small>160</small>
                                        </button>
                                        <button type="button" class="image-size-btn ${currentSize === 'large' ? 'selected' : ''}" onclick="setImageSize('large')">
                                            L<small>200</small>
                                        </button>
                                    </div>
                                    <input type="hidden" id="specialEditImageSize" value="${currentSize}">
                                </div>
                            </div>
                        </div>
                        <div class="form-group image-caption-full">
                            <label>üí¨ Alt Yazƒ± / A√ßƒ±klama</label>
                            <textarea id="specialEditCaption" class="form-control image-textarea-large" placeholder="Resim hakkƒ±nda a√ßƒ±klama yazƒ±n...">${escapeHtml(node.imageCaption || node.summary || '')}</textarea>
                        </div>
                    </div>
                `;
            }

            document.getElementById('specialEditorBody').innerHTML = bodyHtml;
            modal.dataset.nodeId = nodeId;
            openModal('specialNodeEditorModal');
        }

        function setImageSize(size) {
            document.getElementById('specialEditImageSize').value = size;
            document.querySelectorAll('.image-size-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.closest('.image-size-btn').classList.add('selected');
        }

        function setSpecialEditorColor(colorId) {
            document.getElementById('specialEditColor').value = colorId;
            document.querySelectorAll('#stickyColorPicker .sticky-color-option').forEach(el => {
                if (el.id === 'colorOpt_' + colorId) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }

        function setFolderEditorColor(colorId) {
            document.getElementById('specialEditFolderColor').value = colorId;
            document.querySelectorAll('#folderColorPicker .folder-color-option').forEach(el => {
                el.classList.remove('selected');
            });
            event.target.classList.add('selected');
        }

        // Update folder file list in editor modal without closing/reopening
        function updateFolderEditorFileList(nodeId) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node || node.type !== 'folder') return;

            const files = node.folderFiles || [];
            let totalSize = 0;
            files.forEach(f => { if (f.size) totalSize += f.size; });

            // Helper function for file type
            function getFileType(filename) {
                const ext = filename.split('.').pop().toLowerCase();
                const types = {
                    'pdf': 'PDF', 'doc': 'Word', 'docx': 'Word',
                    'xls': 'Excel', 'xlsx': 'Excel', 'ppt': 'PPT', 'pptx': 'PPT',
                    'jpg': 'JPEG', 'jpeg': 'JPEG', 'png': 'PNG', 'gif': 'GIF', 'webp': 'WebP',
                    'mp4': 'Video', 'mov': 'Video', 'avi': 'Video', 'mkv': 'Video',
                    'mp3': 'Audio', 'wav': 'Audio', 'ogg': 'Audio',
                    'zip': 'Ar≈üiv', 'rar': 'Ar≈üiv', '7z': 'Ar≈üiv',
                    'txt': 'Metin', 'html': 'HTML', 'css': 'CSS', 'js': 'JS', 'json': 'JSON'
                };
                return types[ext] || ext.toUpperCase();
            }

            const fileListHtml = files.length === 0
                ? `<div class="folder-empty">
                    <div class="folder-empty-icon">üìÇ</div>
                    <div>Klas√∂r bo≈ü</div>
                   </div>`
                : `<table class="folder-files-table">
                    <thead>
                        <tr>
                            <th style="width:40px;"></th>
                            <th>Dosya Adƒ±</th>
                            <th style="width:70px;">T√ºr</th>
                            <th style="width:80px;">Boyut</th>
                            <th style="width:90px;">ƒ∞≈ülem</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${files.map((f, i) => `
                        <tr>
                            <td class="file-icon">${getFileIconByName(f.name)}</td>
                            <td class="file-name" title="${escapeHtml(f.name)}">${escapeHtml(f.name)}</td>
                            <td class="file-type">${getFileType(f.name)}</td>
                            <td class="file-size">${formatFileSize(f.size)}</td>
                            <td class="file-actions">
                                <button type="button" class="file-action-btn preview-btn" onclick="event.preventDefault(); event.stopPropagation(); previewFolderFile('${nodeId}', ${i});" title="√ñnizle">üëÅÔ∏è</button>
                                <button type="button" class="file-action-btn delete-btn" onclick="event.preventDefault(); event.stopPropagation(); removeFolderFileFromEditor('${nodeId}', ${i});" title="Sil">‚úï</button>
                            </td>
                        </tr>
                        `).join('')}
                    </tbody>
                   </table>`;

            // Update the file list container - MUST search within modal
            const modal = document.getElementById('specialNodeEditorModal');
            if (!modal) {
                console.error('Modal not found for update');
                return;
            }

            const container = modal.querySelector('.folder-files-container');
            console.log('updateFolderEditorFileList - container found:', !!container, 'files:', files.length);
            if (container) {
                container.innerHTML = fileListHtml;
            }

            // Update stats - MUST search within modal
            const statsContainer = modal.querySelector('.folder-editor-stats-inline');
            if (statsContainer) {
                statsContainer.innerHTML = `
                    <div class="folder-stat-inline">
                        <span class="stat-label">Dosya:</span>
                        <span class="stat-value">${files.length}</span>
                    </div>
                    <div class="folder-stat-inline">
                        <span class="stat-label">Boyut:</span>
                        <span class="stat-value">${formatFileSize(totalSize)}</span>
                    </div>
                `;
            }
        }

        function previewFolderFile(nodeId, index) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node || !node.folderFiles || !node.folderFiles[index]) {
                showToast('Dosya bulunamadƒ±', 'error');
                return;
            }

            const file = node.folderFiles[index];

            // Remove existing modal if any
            const existingModal = document.getElementById('folderFilePreviewModal');
            if (existingModal) existingModal.remove();

            // Create preview modal
            const previewModal = document.createElement('div');
            previewModal.id = 'folderFilePreviewModal';
            previewModal.className = 'modal';
            previewModal.style.display = 'flex';
            previewModal.style.zIndex = '100001';

            // Get file extension
            const ext = file.name.split('.').pop().toLowerCase();
            const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp'];
            const textExts = ['txt', 'md', 'html', 'css', 'js', 'json', 'xml', 'csv'];
            const pdfExts = ['pdf'];
            const videoExts = ['mp4', 'webm', 'ogg', 'mov'];
            const audioExts = ['mp3', 'wav', 'ogg', 'aac'];

            // Check for file data - could be in data or preview property
            const fileData = file.data || file.preview || null;
            let previewContent = '';

            if (fileData) {
                if (imageExts.includes(ext)) {
                    previewContent = `
                        <div style="display:flex; justify-content:center; align-items:center; padding:30px; background:#0a0a15; min-height:400px;">
                            <img src="${fileData}" style="max-width:100%; max-height:70vh; object-fit:contain; border-radius:8px; box-shadow:0 8px 32px rgba(0,0,0,0.5);">
                        </div>
                    `;
                } else if (pdfExts.includes(ext)) {
                    // PDF preview with fallback
                    const pdfId = 'pdfEmbed_' + Date.now();
                    previewContent = `
                        <div style="width:100%; min-height:500px; display:flex; flex-direction:column; background:#0a0a15; position:relative;">
                            <iframe id="${pdfId}" src="${fileData}" style="width:100%; height:70vh; min-height:500px; border:none; background:#fff;"></iframe>
                            <div id="${pdfId}_fallback" style="display:none; position:absolute; top:0; left:0; right:0; bottom:0; padding:60px; text-align:center; color:#888; background:#0a0a15; flex-direction:column; justify-content:center; align-items:center;">
                                <div style="font-size:6rem; margin-bottom:28px;">üìï</div>
                                <div style="font-size:1.4rem; color:#ccc; margin-bottom:14px; font-weight:500;">${escapeHtml(file.name)}</div>
                                <div style="font-size:1rem; color:#777; margin-bottom:24px;">Boyut: ${formatFileSize(file.size)}</div>
                                <div style="margin:20px 0; padding:20px 32px; background:rgba(99,102,241,0.1); border:2px solid rgba(99,102,241,0.3); border-radius:12px;">
                                    <div style="color:#a5b4fc; font-size:15px; margin-bottom:12px;">PDF tarayƒ±cƒ±da √∂nizlenemiyor</div>
                                    <button onclick="downloadFolderPreviewFile()" style="background:linear-gradient(135deg, #6366f1 0%, #4f46e5 100%); color:#fff; border:none; padding:14px 36px; border-radius:8px; cursor:pointer; font-weight:600; font-size:15px;">
                                        ‚¨áÔ∏è PDF'i ƒ∞ndir ve G√∂r√ºnt√ºle
                                    </button>
                                </div>
                            </div>
                        </div>
                        <script>
                            setTimeout(() => {
                                const iframe = document.getElementById('${pdfId}');
                                const fallback = document.getElementById('${pdfId}_fallback');
                                if (iframe && fallback) {
                                    iframe.onerror = () => { fallback.style.display = 'flex'; iframe.style.display = 'none'; };
                                    // Check if PDF loaded after 2 seconds
                                    setTimeout(() => {
                                        try {
                                            if (!iframe.contentDocument || iframe.contentDocument.body.innerHTML === '') {
                                                fallback.style.display = 'flex';
                                                iframe.style.display = 'none';
                                            }
                                        } catch(e) { /* cross-origin, PDF probably loaded */ }
                                    }, 2000);
                                }
                            }, 100);
                        <\/script>
                    `;
                } else if (videoExts.includes(ext)) {
                    previewContent = `
                        <div style="display:flex; justify-content:center; align-items:center; padding:30px; background:#0a0a15;">
                            <video controls style="max-width:100%; max-height:70vh; border-radius:8px;">
                                <source src="${fileData}" type="video/${ext}">
                                Tarayƒ±cƒ±nƒ±z video oynatmayƒ± desteklemiyor.
                            </video>
                        </div>
                    `;
                } else if (audioExts.includes(ext)) {
                    previewContent = `
                        <div style="display:flex; flex-direction:column; justify-content:center; align-items:center; padding:50px; background:#0a0a15;">
                            <div style="font-size:5rem; margin-bottom:24px;">üéµ</div>
                            <div style="color:#aaa; margin-bottom:24px; font-size:16px;">${escapeHtml(file.name)}</div>
                            <audio controls style="width:100%; max-width:500px;">
                                <source src="${fileData}" type="audio/${ext === 'mp3' ? 'mpeg' : ext}">
                                Tarayƒ±cƒ±nƒ±z ses oynatmayƒ± desteklemiyor.
                            </audio>
                        </div>
                    `;
                } else if (textExts.includes(ext)) {
                    try {
                        const base64Data = fileData.split(',')[1];
                        const textContent = atob(base64Data);
                        previewContent = `
                            <pre style="padding:24px; background:#0a0a15; color:#ddd; margin:0; white-space:pre-wrap; word-wrap:break-word; font-family:'Monaco', 'Consolas', monospace; font-size:13px; line-height:1.6; max-height:70vh; overflow:auto;">${escapeHtml(textContent)}</pre>
                        `;
                    } catch(e) {
                        previewContent = `
                            <div style="padding:50px; text-align:center; color:#888; background:#0a0a15;">
                                <div style="font-size:4rem; margin-bottom:20px;">üìÑ</div>
                                <div style="font-size:14px;">Metin √∂nizleme yapƒ±lamadƒ±</div>
                            </div>
                        `;
                    }
                } else {
                    previewContent = `
                        <div style="padding:60px; text-align:center; color:#888; background:#0a0a15;">
                            <div style="font-size:5rem; margin-bottom:24px;">${getFileIconByName(file.name)}</div>
                            <div style="font-size:1.2rem; color:#bbb; margin-bottom:12px;">${escapeHtml(file.name)}</div>
                            <div style="font-size:0.95rem; color:#666;">Boyut: ${formatFileSize(file.size)}</div>
                            <div style="margin-top:24px; font-size:0.9rem; color:#555;">Bu dosya t√ºr√º i√ßin √∂nizleme desteklenmiyor</div>
                        </div>
                    `;
                }
            } else {
                // No file data - show file info and explain
                previewContent = `
                    <div style="padding:60px 40px; text-align:center; color:#888; background:#0a0a15; width:100%; min-height:400px; display:flex; flex-direction:column; justify-content:center; align-items:center;">
                        <div style="font-size:6rem; margin-bottom:28px;">${getFileIconByName(file.name)}</div>
                        <div style="font-size:1.4rem; color:#ccc; margin-bottom:14px; font-weight:500;">${escapeHtml(file.name)}</div>
                        <div style="font-size:1rem; color:#777; margin-bottom:24px;">Boyut: ${formatFileSize(file.size)}</div>
                        <div style="margin-top:16px; padding:20px 32px; background:rgba(245,158,11,0.1); border:2px solid rgba(245,158,11,0.3); border-radius:12px; max-width:450px;">
                            <div style="color:#f59e0b; font-size:16px; font-weight:600; margin-bottom:8px;">‚ö†Ô∏è Dosya i√ßeriƒüi √∂nizlenemiyor</div>
                            <div style="color:#999; font-size:13px; line-height:1.5;">Dosya eski bir kayƒ±tta olabilir veya veri y√ºklenmemi≈ü olabilir.<br>Yeni dosya eklerseniz √∂nizleme √ßalƒ±≈üacaktƒ±r.</div>
                        </div>
                    </div>
                `;
            }

            previewModal.innerHTML = `
                <div class="modal-content" style="max-width:1100px; width:95%; max-height:92vh; background:#1a1a2e; border:1px solid #444; border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,0.6);">
                    <div class="modal-header" style="background:linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%); border-bottom:1px solid #333; padding:16px 24px; border-radius:16px 16px 0 0;">
                        <h3 style="color:#fff; display:flex; align-items:center; gap:14px; font-size:17px; flex:1;">
                            <span style="font-size:32px;">${getFileIconByName(file.name)}</span>
                            <span style="word-break:break-all; flex:1;">${escapeHtml(file.name)}</span>
                            <span style="font-size:13px; color:#888; font-weight:normal; background:rgba(255,255,255,0.1); padding:4px 12px; border-radius:20px;">${formatFileSize(file.size)}</span>
                        </h3>
                        <button class="modal-close" onclick="document.getElementById('folderFilePreviewModal').remove()" style="background:#333; color:#fff; width:36px; height:36px; border-radius:8px; border:1px solid #444; font-size:20px; margin-left:16px;">√ó</button>
                    </div>
                    <div class="modal-body" style="padding:0; overflow:auto; max-height:calc(92vh - 140px); display:flex; justify-content:center; align-items:center; min-height:400px;">
                        ${previewContent}
                    </div>
                    <div class="modal-footer" style="display:flex; gap:12px; justify-content:flex-end; padding:16px 24px; background:linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 100%); border-top:1px solid #333; border-radius:0 0 16px 16px;">
                        <button onclick="document.getElementById('folderFilePreviewModal').remove()" style="background:#333; color:#fff; border:1px solid #444; padding:12px 28px; border-radius:8px; cursor:pointer; font-size:14px;">
                            ‚úï Kapat
                        </button>
                        ${fileData ? `<button onclick="downloadFolderPreviewFile()" style="background:linear-gradient(135deg, #6366f1 0%, #4f46e5 100%); color:#fff; border:none; padding:12px 28px; border-radius:8px; cursor:pointer; font-weight:600; font-size:14px;">
                            ‚¨áÔ∏è ƒ∞ndir
                        </button>` : ''}
                    </div>
                </div>
            `;

            // Store file data for download
            previewModal.dataset.fileData = fileData || '';
            previewModal.dataset.fileName = file.name;

            document.body.appendChild(previewModal);
        }

        function downloadFolderPreviewFile() {
            const modal = document.getElementById('folderFilePreviewModal');
            if (!modal) return;

            const link = document.createElement('a');
            link.href = modal.dataset.fileData;
            link.download = modal.dataset.fileName;
            link.click();
        }

        function saveSpecialNodeEditor() {
            const modal = document.getElementById('specialNodeEditorModal');
            const nodeId = modal.dataset.nodeId;
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;

            saveUndoState('edit special node');

            node.title = document.getElementById('specialEditTitle')?.value || node.title;

            if (node.type === 'folder') {
                node.folderColor = document.getElementById('specialEditFolderColor')?.value || 'blue';
                node.folderType = document.getElementById('specialEditFolderType')?.value || 'general';
            } else if (node.type === 'sticky') {
                node.stickyColor = document.getElementById('specialEditColor')?.value || 'yellow';
                node.stickyTag = document.getElementById('specialEditTag')?.value || 'none';
                node.summary = document.getElementById('specialEditContent')?.value || '';
                node.stickyContent = node.summary;
            } else if (node.type === 'image') {
                node.imageCaption = document.getElementById('specialEditCaption')?.value || '';
                node.summary = node.imageCaption;
                node.imageSize = document.getElementById('specialEditImageSize')?.value || 'medium';
            }

            renderNode(node);
            closeModal('specialNodeEditorModal');
            
            // Update properties panel if this node is selected
            if (selectedNode === nodeId || String(selectedNode) === String(nodeId)) {
                requestAnimationFrame(() => {
                    updatePropertiesPanel(nodeId);
                });
            }
            
            autoSave();
            showToast('‚úÖ Kaydedildi');
        }

        // Global storage for folder operations
        window._folderOpContext = { nodeId: null, fileIndex: null };

        // Refresh folder editor content without closing modal
        function refreshFolderEditorContent(nodeId) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node || node.type !== 'folder') return;

            const modal = document.getElementById('specialNodeEditorModal');
            if (!modal) return;

            const files = node.folderFiles || [];
            let totalSize = 0;
            files.forEach(f => { if (f.size) totalSize += f.size; });

            function getFileType(filename) {
                const ext = filename.split('.').pop().toLowerCase();
                const types = {
                    'pdf': 'PDF', 'doc': 'Word', 'docx': 'Word',
                    'xls': 'Excel', 'xlsx': 'Excel', 'ppt': 'PPT', 'pptx': 'PPT',
                    'jpg': 'JPEG', 'jpeg': 'JPEG', 'png': 'PNG', 'gif': 'GIF', 'webp': 'WebP',
                    'mp4': 'Video', 'mov': 'Video', 'avi': 'Video', 'mkv': 'Video',
                    'mp3': 'Audio', 'wav': 'Audio', 'ogg': 'Audio',
                    'zip': 'Ar≈üiv', 'rar': 'Ar≈üiv', '7z': 'Ar≈üiv',
                    'txt': 'Metin', 'html': 'HTML', 'css': 'CSS', 'js': 'JS', 'json': 'JSON'
                };
                return types[ext] || ext.toUpperCase();
            }

            const fileListHtml = files.length === 0
                ? `<div class="folder-empty"><div class="folder-empty-icon">üìÇ</div><div>Klas√∂r bo≈ü</div></div>`
                : `<table class="folder-files-table">
                    <thead><tr><th style="width:40px;"></th><th>Dosya Adƒ±</th><th style="width:70px;">T√ºr</th><th style="width:80px;">Boyut</th><th style="width:90px;">ƒ∞≈ülem</th></tr></thead>
                    <tbody>${files.map((f, i) => `<tr>
                        <td class="file-icon">${getFileIconByName(f.name)}</td>
                        <td class="file-name" title="${escapeHtml(f.name)}">${escapeHtml(f.name)}</td>
                        <td class="file-type">${getFileType(f.name)}</td>
                        <td class="file-size">${formatFileSize(f.size)}</td>
                        <td class="file-actions">
                            <button type="button" class="file-action-btn preview-btn" onclick="event.preventDefault(); event.stopPropagation(); previewFolderFile('${nodeId}', ${i});" title="√ñnizle">üëÅÔ∏è</button>
                            <button type="button" class="file-action-btn delete-btn" onclick="event.preventDefault(); event.stopPropagation(); removeFolderFileFromEditor('${nodeId}', ${i});" title="Sil">‚úï</button>
                        </td>
                    </tr>`).join('')}</tbody></table>`;

            const container = modal.querySelector('.folder-files-container');
            if (container) container.innerHTML = fileListHtml;

            const statsContainer = modal.querySelector('.folder-editor-stats-inline');
            if (statsContainer) {
                statsContainer.innerHTML = `
                    <div class="folder-stat-inline"><span class="stat-label">Dosya:</span><span class="stat-value">${files.length}</span></div>
                    <div class="folder-stat-inline"><span class="stat-label">Boyut:</span><span class="stat-value">${formatFileSize(totalSize)}</span></div>
                `;
            }
        }

        function addFilesToFolderFromEditor(nodeId) {
            const savedNodeId = String(nodeId);
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;

            input.onchange = function(e) {
                const files = Array.from(e.target.files);
                const node = nodes.find(n => String(n.id) === String(savedNodeId));
                if (!node || files.length === 0) return;

                if (!node.folderFiles) node.folderFiles = [];

                let loadedCount = 0;
                const totalFiles = files.length;

                files.forEach((file, idx) => {
                    const fileObj = {
                        id: 'file_' + Date.now() + '_' + idx + '_' + Math.random().toString(36).substr(2, 9),
                        name: file.name,
                        size: file.size,
                        type: file.type || 'application/octet-stream',
                        addedAt: new Date().toISOString()
                    };

                    node.folderFiles.push(fileObj);

                    const reader = new FileReader();
                    reader.onload = function(ev) {
                        fileObj.data = ev.target.result;
                        if (file.type && file.type.startsWith('image/')) {
                            fileObj.preview = ev.target.result;
                        }
                        loadedCount++;
                        // Update UI after each file loads
                        renderNode(node);
                        refreshFolderEditorContent(savedNodeId);
                        autoSave();
                    };
                    reader.readAsDataURL(file);
                });

                showToast('üìÅ ' + totalFiles + ' dosya eklendi');
            };

            input.click();
        }

        function removeFolderFileFromEditor(nodeId, index) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node || !node.folderFiles || !node.folderFiles[index]) {
                showToast('Dosya bulunamadƒ±', 'error');
                return;
            }

            // Direct delete like Properties panel - no confirmation
            node.folderFiles.splice(index, 1);
            renderNode(node);
            refreshFolderEditorContent(nodeId);
            autoSave();
            showToast('üóëÔ∏è Dosya silindi');
        }

        function selectImageForEditor(nodeId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const node = nodes.find(n => String(n.id) === String(nodeId));
                        if (node) {
                            node.imageData = ev.target.result;
                            const container = document.getElementById('imagePreviewContainer');
                            if (container) {
                                container.innerHTML = `
                                    <img src="${ev.target.result}">
                                    <button class="image-change-btn" onclick="selectImageForEditor('${nodeId}')">
                                        üîÑ Resmi Deƒüi≈ütir
                                    </button>
                                `;
                            }
                        }
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }

        function duplicateSpecialNode(nodeId) {
            const orig = nodes.find(n => String(n.id) === String(nodeId));
            if (!orig) return;

            saveUndoState('duplicate special node');

            const newNode = {
                ...JSON.parse(JSON.stringify(orig)),
                id: 'special_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                x: (orig.x || 0) + 30,
                y: (orig.y || 0) + 30,
                title: (orig.title || '') + ' (kopya)',
                parentId: null  // Remove parent connection - duplicate as independent node
            };

            nodes.push(newNode);
            renderNode(newNode);
            selectNode(newNode.id);
            autoSave();
            showToast('üìã Kopyalandƒ±');
        }

        // ============ SPECIAL NODE HELPER FUNCTIONS ============
        function openFolderFile(nodeId, fileId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node || !node.folderFiles) return;

            const file = node.folderFiles.find(f => f.id === fileId);
            if (!file) return;

            // Open file based on type
            if (file.preview || file.data) {
                window.open(file.preview || file.data, '_blank');
            }
            showToast(`üìÑ ${file.name} a√ßƒ±lƒ±yor...`);
        }

        function viewImageFullscreen(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node || (!node.imageData && !node.imageSrc)) return;

            const imgSrc = node.imageData || node.imageSrc;
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:99999;display:flex;align-items:center;justify-content:center;cursor:zoom-out;';
            overlay.innerHTML = `<img src="${imgSrc}" style="max-width:90%;max-height:90%;object-fit:contain;border-radius:8px;box-shadow:0 20px 60px rgba(0,0,0,0.5);">`;
            overlay.onclick = () => overlay.remove();
            document.body.appendChild(overlay);
        }

        function selectNodeImage(nodeId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const node = nodes.find(n => n.id === nodeId);
                        if (node) {
                            node.imageData = ev.target.result;
                            node.title = node.title || file.name.split('.')[0];
                            renderNode(node);
                            // Update properties panel for this node immediately and on next frame
                            updatePropertiesPanel(nodeId);
                            requestAnimationFrame(() => updatePropertiesPanel(nodeId));
                            
                            autoSave();
                            showToast('üñºÔ∏è Resim eklendi');
                        }
                    };
                    reader.readAsDataURL(file);
                }
            };
            input.click();
        }

        function changeNodeImage(nodeId) {
            selectNodeImage(nodeId);
        }

        function renderNode(node) {
            // Remove existing node element if it exists (prevent duplicates)
            const existingEl = document.getElementById(`node-${node.id}`);
            if (existingEl) {
                existingEl.remove();
            }

            const el = document.createElement('div');

            // Check if this is a special node (folder, sticky, image)
            const isSpecialNode = SPECIAL_NODE_TYPES[node.type];

            // Check if this is a task node
            const isTaskNode = node.isTaskNode || TASK_NODE_TYPES[node.type];

            if (isSpecialNode) {
                // ==========================================
                // SPECIAL NODE RENDERING (FOLDER, STICKY, IMAGE)
                // ==========================================
                renderSpecialNode(el, node);
                return; // IMPORTANT: Don't continue with regular node rendering
            } else if (isTaskNode) {
                // ==========================================
                // NEW TASK NODE RENDERING - COMPLETELY NEW DESIGN
                // ==========================================
                const taskTypeInfo = TASK_NODE_TYPES[node.type] || { icon: '‚ñ¢', name: 'Task', color: '#8b5cf6' };
                const statusInfo = TASK_STATUSES.find(s => s.id === node.taskStatus) || TASK_STATUSES[0];
                const progress = node.taskProgress || 0;

                // Status class for border and type class for header color
                let statusClass = 'status-' + (node.taskStatus || 'todo');
                let typeClass = 'type-' + (node.type || 'todo');

                el.className = `task-node-card ${typeClass} ${statusClass}`;
                el.id = `node-${node.id}`;
                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';

                // Progress bar color class
                let progressClass = 'low';
                if (progress >= 75) progressClass = 'high';
                else if (progress >= 50) progressClass = 'medium';
                else if (progress === 100) progressClass = 'complete';

                // Duration display
                const durationText = node.taskDuration ? `${node.taskDuration} ${node.taskDurationType || 'hours'}` : '-';

                // Date formatting with time
                const formatDate = (dateStr) => {
                    if (!dateStr) return '-';
                    const d = new Date(dateStr);
                    return d.toLocaleDateString('tr-TR', { day: 'numeric', month: 'short' });
                };

                const formatDateTime = (dateStr) => {
                    if (!dateStr) return '-';
                    const d = new Date(dateStr);
                    const date = d.toLocaleDateString('tr-TR', { day: 'numeric', month: 'short' });
                    const time = d.toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' });
                    return `${date} ${time}`;
                };

                // Due date status - Enhanced with hours for overdue/critical
                let dueDateClass = '';
                let dueDateDisplay = formatDateTime(node.taskDateDue);
                let deadlineIndicator = '';
                if (node.taskDateDue) {
                    const now = new Date();
                    const due = new Date(node.taskDateDue);
                    const diffMs = due - now;
                    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
                    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                    const diffMins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

                    if (diffMs < 0) {
                        // OVERDUE - show hours and minutes
                        dueDateClass = 'overdue';
                        const overdueHours = Math.abs(diffHours);
                        const overdueMins = Math.abs(diffMins);
                        if (overdueHours >= 24) {
                            const overdueDays = Math.floor(overdueHours / 24);
                            const remainingHours = overdueHours % 24;
                            dueDateDisplay = `${overdueDays}g ${remainingHours}s gecikti`;
                        } else if (overdueHours > 0) {
                            dueDateDisplay = `${overdueHours}s ${overdueMins}dk gecikti`;
                        } else {
                            dueDateDisplay = `${Math.abs(Math.ceil(diffMs / (1000 * 60)))}dk gecikti`;
                        }
                        deadlineIndicator = `<div class="deadline-indicator overdue">OVERDUE ${dueDateDisplay.toUpperCase()}</div>`;
                    } else if (diffHours < 24) {
                        // Less than 24 hours - show hours and minutes
                        dueDateClass = 'critical';
                        const remainingMins = diffMins > 0 ? diffMins : 0;
                        if (diffHours > 0) {
                            dueDateDisplay = `${diffHours}s ${remainingMins}dk kaldƒ±`;
                            deadlineIndicator = `<div class="deadline-indicator critical">${diffHours}s ${remainingMins}dk</div>`;
                        } else {
                            dueDateDisplay = `${Math.max(0, Math.floor(diffMs / (1000 * 60)))}dk kaldƒ±`;
                            deadlineIndicator = `<div class="deadline-indicator critical">${dueDateDisplay}</div>`;
                        }
                    } else if (diffDays <= 3) {
                        // SOON (within 3 days) - show days and hours
                        dueDateClass = 'approaching';
                        const remainingHours = diffHours % 24;
                        dueDateDisplay = `${diffDays}g ${remainingHours}s kaldƒ±`;
                        deadlineIndicator = `<div class="deadline-indicator approaching">${diffDays}g ${remainingHours}s</div>`;
                    } else if (diffDays <= 7) {
                        // This week
                        dueDateClass = 'soon';
                        dueDateDisplay = `${diffDays} g√ºn kaldƒ±`;
                        deadlineIndicator = `<div class="deadline-indicator soon">${diffDays} g√ºn</div>`;
                    } else {
                        // More than a week
                        dueDateDisplay = formatDateTime(node.taskDateDue);
                    }
                }

                // Priority indicator (no emoji, just class for colored dot)
                const priorityConfig = {
                    low: { label: 'Low', color: '#22c55e', class: 'priority-low' },
                    medium: { label: 'Medium', color: '#f59e0b', class: 'priority-medium' },
                    high: { label: 'High', color: '#f97316', class: 'priority-high' },
                    critical: { label: 'Critical', color: '#ef4444', class: 'priority-critical' }
                };
                const priority = priorityConfig[node.taskPriority] || priorityConfig.medium;

                // Linked nodes
                let linkedHtml = '';
                if (node.linkedNodeIds && node.linkedNodeIds.length > 0) {
                    const linkedNode = nodes.find(n => n.id === node.linkedNodeIds[0]);
                    if (linkedNode) {
                        linkedHtml = `
                            <div class="task-node-links">
                                <div class="task-node-link-label">Baƒülƒ± Node</div>
                                <div class="task-node-link-item">
                                    <span>üîó</span>
                                    <span>${linkedNode.title}</span>
                                </div>
                            </div>
                        `;
                    }
                }

                // Dependencies display
                let dependenciesHtml = '';
                if (node.taskDependencies && node.taskDependencies.length > 0) {
                    const depCount = node.taskDependencies.length;
                    dependenciesHtml = `<span class="task-badge dependency-badge" title="Has ${depCount} dependency(ies)">${depCount} dep</span>`;
                }

                el.innerHTML = `
                    <!-- Priority Corner Indicator (colored dot, no emoji) -->
                    <div class="priority-corner ${priority.class}" title="Priority: ${priority.label}"></div>

                    <!-- Deadline Indicator (if critical/overdue) -->
                    ${deadlineIndicator}

                    <!-- Task Node Header - Like regular node -->
                    <div class="task-node-header">
                        <div class="task-node-title-wrap">
                            <div class="task-node-type">${taskTypeInfo.name}</div>
                            <div class="task-node-title">${node.title}</div>
                        </div>
                    </div>

                    <!-- Task Node Body - Like regular node -->
                    <div class="task-node-body">
                        <div class="task-node-desc">${node.summary || 'A√ßƒ±klama ekle...'}</div>

                        <!-- Progress Bar -->
                        <div class="task-node-progress-bar">
                            <div class="task-node-progress-fill ${progressClass}" style="width:${progress}%"></div>
                        </div>

                        <!-- Meta Info Row 1: Status & Progress -->
                        <div class="task-node-meta">
                            <span class="task-badge status-${node.taskStatus || 'todo'}">${statusInfo.name}</span>
                            ${progress > 0 ? `<span class="task-badge">${progress}%</span>` : ''}
                            ${dependenciesHtml}
                        </div>

                        <!-- Meta Info Row 2: Start & Deadline -->
                        <div class="task-node-dates">
                            ${node.taskDateStart ? `<span class="task-date-badge start">${formatDateTime(node.taskDateStart)}</span>` : ''}
                            ${node.taskDateDue ? `<span class="task-date-badge due ${dueDateClass}">${dueDateDisplay}</span>` : ''}
                        </div>
                    </div>

                    <!-- Connection Points -->
                    <div class="conn-point top" data-id="${node.id}" data-pos="top"></div>
                    <div class="conn-point bottom" data-id="${node.id}" data-pos="bottom"></div>
                    <div class="conn-point left" data-id="${node.id}" data-pos="left"></div>
                    <div class="conn-point right" data-id="${node.id}" data-pos="right"></div>
                `;
            } else {
                // REGULAR NODE RENDERING
                el.className = `node node-${node.type}`;
                el.id = `node-${node.id}`;
                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';

                const pov = povList.find(p => p.id === node.povId);
                const typeLabels = {
                    section: '', group: '', introduction: '', note: 'üìù',
                    research: 'üî¨', reference: 'üìö', draft: '‚úèÔ∏è', conclusion: 'üèÅ',
                    appendix: 'üìé', abstract: 'üìã'
                };

                let descsHtml = '';
                if (node.descs && node.descs.length > 0) {
                    const tags = node.descs.map(d => {
                        const dt = descTypes.find(t => t.id === d.tid);
                        return dt ? `<span class="node-desc-tag">${dt.icon} ${d.val}</span>` : '';
                    }).join('');
                    descsHtml = `<div class="node-descs">${tags}</div>`;
                }

                // Folder indicator for nodes with children
                const children = getChildren(node.id);
                const hasChildren = children.length > 0;
                const grandchildCount = countAllDescendants(node.id) - children.length;

                // Attachment indicator
                const attachCount = (node.attachments && node.attachments.length) || 0;

                // Show toolbar only if has children or attachments
                const showToolbar = hasChildren || attachCount > 0;
                let toolbarHtml = '';
                if (showToolbar) {
                    let folderBtn = '<span style="flex:1;"></span>';
                    if (hasChildren) {
                        const arrow = node.collapsed ? '‚ñ∂' : '‚ñº';
                        const countText = grandchildCount > 0 ? `${children.length}+${grandchildCount}` : children.length;
                        folderBtn = `<span class="folder-indicator ${node.collapsed ? 'collapsed' : ''}" onclick="event.stopPropagation(); toggleCollapse('${node.id}')">${arrow} ${countText}</span>`;
                    }
                    let attachBtn = '';
                    if (attachCount > 0) {
                        attachBtn = `<span class="attachment-indicator">üìé ${attachCount}</span>`;
                    }
                    toolbarHtml = `<div class="node-toolbar">${folderBtn}${attachBtn}</div>`;
                }

                // Check for linked tasks
                const linkedTasks = tasks.filter(t => t.assignedNodeId === node.id);
                const taskBadge = linkedTasks.length > 0
                    ? `<span style="background:#8b5cf6;color:white;padding:2px 6px;border-radius:8px;font-size:10px;margin-left:6px;">üìã${linkedTasks.length}</span>` : '';
                
                // Section status circle
                const sectionStatus = node.sectionStatus || 'none';
                const sectionStatusInfo = SECTION_STATUSES.find(s => s.id === sectionStatus) || SECTION_STATUSES[0];
                const statusCircleHtml = `<span class="node-status-circle" style="background:${sectionStatusInfo.color};" title="${sectionStatusInfo.name}"></span>`;

                el.innerHTML = `
                    ${toolbarHtml}
                    <div class="node-header">
                        <span class="node-type-label">${typeLabels[node.type] || ''}</span>
                        <div class="node-title-row">
                        <span class="node-title">${node.title}${taskBadge}</span>
                            ${statusCircleHtml}
                        </div>
                    </div>
                    <div class="node-body">
                        <div class="node-summary">${node.summary}</div>
                    </div>
                    <div class="node-meta">
                        ${pov ? `<div class="node-pov"><span class="pov-dot" style="background:${pov.color}"></span>${pov.name}</div>` : '<div></div>'}
                        <div></div>
                    </div>
                    ${descsHtml}
                    <div class="conn-point top" data-id="${node.id}" data-pos="top"></div>
                    <div class="conn-point bottom" data-id="${node.id}" data-pos="bottom"></div>
                    <div class="conn-point left" data-id="${node.id}" data-pos="left"></div>
                    <div class="conn-point right" data-id="${node.id}" data-pos="right"></div>
                `;
            }

            // Drag with drop-to-parent feature + GRID SNAP
            let dragging = false, startX, startY, initX, initY;
            let currentDragNode = null;
            const GRID_SIZE = 25; // Snap to 25px grid

            // Grid snap helper function
            function snapToGrid(value) {
                return Math.round(value / GRID_SIZE) * GRID_SIZE;
            }

            let hasMoved = false;
            let undoSaved = false;

            el.addEventListener('mousedown', e => {
                if (e.target.classList.contains('conn-point')) return;
                if (e.target.classList.contains('folder-indicator')) return;
                
                dragging = true;
                hasMoved = false;
                undoSaved = false;
                currentDragNode = node;
                startX = e.clientX; startY = e.clientY;
                initX = node.x; initY = node.y;
                selectNode(node.id);
                el.style.zIndex = '1000';
                el.style.opacity = '0.8';
                e.preventDefault();
            });

            document.addEventListener('mousemove', e => {
                if (!dragging || !currentDragNode || currentDragNode.id !== node.id) return;
                
                // Check if actually moved (more than 5px)
                const moveDistance = Math.abs(e.clientX - startX) + Math.abs(e.clientY - startY);
                if (moveDistance > 5 && !undoSaved) {
                    saveUndoState('move node');
                    undoSaved = true;
                }
                
                if (moveDistance > 5) {
                    hasMoved = true;
                }
                
                let newX = Math.max(0, initX + (e.clientX - startX) / zoom);
                let newY = Math.max(0, initY + (e.clientY - startY) / zoom);

                // Apply grid snap
                node.x = snapToGrid(newX);
                node.y = snapToGrid(newY);

                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';
                
                // Render connections directly - uses node data coordinates
                renderConnections();

                // Check for drop targets (other nodes)
                highlightDropTarget(e.clientX, e.clientY, node.id);
            });

            document.addEventListener('mouseup', e => {
                if (!dragging || !currentDragNode || currentDragNode.id !== node.id) return;

                el.style.zIndex = '';
                el.style.opacity = '1';

                // Final snap to grid
                node.x = snapToGrid(node.x);
                node.y = snapToGrid(node.y);
                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';

                // Check if dropped on another node
                const dropTarget = getDropTargetNode(e.clientX, e.clientY, node.id);
                if (dropTarget && !e.shiftKey) {
                    // Make this node a child of the drop target
                    makeNodeChild(node.id, dropTarget.id);
                }

                // Clear all drop highlights
                clearDropHighlights();

                dragging = false;
                currentDragNode = null;
                saveToLocalStorage();
            });

            // Connection points - both click and drag support
            el.querySelectorAll('.conn-point').forEach(cp => {
                // Click support (existing)
                cp.addEventListener('click', e => {
                    e.stopPropagation();
                    handleConnClick(node.id, cp.dataset.pos);
                });

                // Drag support for connection drawing
                cp.addEventListener('mousedown', e => {
                    e.stopPropagation();
                    e.preventDefault();
                    startConnectionDrag(node.id, cp.dataset.pos, e.clientX, e.clientY);
                });
            });

            // Double click = full editor OR task editor for task nodes
            el.addEventListener('dblclick', () => {
                const isTask = node.isTaskNode || TASK_NODE_TYPES[node.type];
                if (isTask) {
                    openTaskNodeEditor(node.id);
                } else {
                    openFullEditor(node.id);
                }
            });

            // Right click
            el.addEventListener('contextmenu', e => {
                e.preventDefault();
                selectNode(node.id);
                const isTask = node.isTaskNode || TASK_NODE_TYPES[node.type];
                if (isTask) {
                    showMenu('taskNodeMenu', e.clientX, e.clientY);
                } else {
                    showMenu('nodeMenu', e.clientX, e.clientY);
                }
            });

            canvas.appendChild(el);
        }

        function renderConnections() {
            // Remove all paths AND lines (including temp lines)
            const paths = connectionsEl.querySelectorAll('path');
            paths.forEach(p => p.remove());
            const lines = connectionsEl.querySelectorAll('line');
            lines.forEach(l => l.remove());
            // Remove dependency labels
            const labels = connectionsEl.querySelectorAll('.dependency-label, .dependency-label-bg');
            labels.forEach(l => l.remove());

            // Get current canvas size (dynamic)
            const canvasEl = document.getElementById('canvas');
            const canvasWidth = parseInt(canvasEl.style.width) || CANVAS_WIDTH;
            const canvasHeight = parseInt(canvasEl.style.height) || CANVAS_HEIGHT;

            // Apply same transform as canvas to SVG
            connectionsEl.style.transform = `scale(${zoom})`;
            connectionsEl.style.transformOrigin = '0 0';
            connectionsEl.style.width = canvasWidth + 'px';
            connectionsEl.style.height = canvasHeight + 'px';
            connectionsEl.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);

            // Get current card size for width calculation
            const cardSize = appSettings.cardSize || 'medium';
            const defaultNodeWidth = cardSize === 'small' ? 180 : cardSize === 'large' ? 320 : 240;

            // Helper function to get node width (task nodes and special nodes have different widths)
            function getNodeWidth(node, el) {
                // Always try DOM measurement first for accuracy
                if (el) {
                    const rect = el.getBoundingClientRect();
                    if (rect.width > 0) return rect.width / zoom;
                }
                
                // Fallbacks
                const isTaskNode = node.isTaskNode || TASK_NODE_TYPES[node.type];
                const isSpecialNode = SPECIAL_NODE_TYPES && SPECIAL_NODE_TYPES[node.type];
                
                if (isSpecialNode) {
                    if (node.type === 'folder') return 180;
                    if (node.type === 'sticky') return 200;
                    if (node.type === 'image') {
                        const size = node.imageSize || 'medium';
                        if (size === 'small') return 120;
                        if (size === 'large') return 200;
                        return 160; // medium
                    }
                }
                if (isTaskNode) return 300;
                
                return defaultNodeWidth;
            }
            
            // Helper function to get node height
            function getNodeHeight(node, el) {
                // Always try DOM measurement first for accuracy
                if (el) {
                    const rect = el.getBoundingClientRect();
                    if (rect.height > 0) return rect.height / zoom;
                }
                
                // Fallback for special nodes
                const isSpecialNode = SPECIAL_NODE_TYPES && SPECIAL_NODE_TYPES[node.type];
                if (isSpecialNode) {
                    if (node.type === 'folder') return 85;
                    if (node.type === 'sticky') return 150;
                    if (node.type === 'image') {
                        const size = node.imageSize || 'medium';
                        if (size === 'small') return 110;
                        if (size === 'large') return 200;
                        return 155; // medium
                    }
                }
                
                return 100; // default height
            }

            // Helper function to draw a connection
            // NO ARROWS - connections from node EDGES (not center)
            function drawConnection(fromN, toN, isHierarchy = false, customConnection = null) {
                const fromEl = document.getElementById(`node-${fromN.id}`);
                const toEl = document.getElementById(`node-${toN.id}`);
                if (!fromEl || !toEl) return;

                // Use helper functions that prefer predefined sizes for special nodes
                const fromWidth = getNodeWidth(fromN, fromEl);
                const toWidth = getNodeWidth(toN, toEl);
                const fromHeight = getNodeHeight(fromN, fromEl);
                const toHeight = getNodeHeight(toN, toEl);

                // Smart routing: determine best connection points based on positions
                const dx = toN.x - fromN.x;
                const dy = toN.y - fromN.y;
                let fp, tp;

                // Calculate optimal connection points based on relative positions
                if (Math.abs(dy) > Math.abs(dx) * 0.5) {
                    // Primarily vertical relationship
                    if (dy > 0) {
                        fp = 'bottom'; tp = 'top';
                    } else {
                        fp = 'top'; tp = 'bottom';
                    }
                } else {
                    // Primarily horizontal relationship
                    if (dx > 0) {
                        fp = 'right'; tp = 'left';
                    } else {
                        fp = 'left'; tp = 'right';
                    }
                }

                const getPoint = (node, height, width, pos) => {
                    let x, y;
                    switch(pos) {
                        case 'top': x = node.x + width/2; y = node.y; break;
                        case 'bottom': x = node.x + width/2; y = node.y + height; break;
                        case 'left': x = node.x; y = node.y + height/2; break;
                        case 'right': x = node.x + width; y = node.y + height/2; break;
                    }
                    return { x, y };
                };

                const p1 = getPoint(fromN, fromHeight, fromWidth, fp);
                const p2 = getPoint(toN, toHeight, toWidth, tp);

                // Bezier curve control points
                const curveX = Math.abs(p2.x - p1.x) / 2;
                const curveY = Math.abs(p2.y - p1.y) / 2;
                let cp1x, cp1y, cp2x, cp2y;

                if (fp === 'bottom' || fp === 'top') {
                    cp1x = p1.x; cp1y = p1.y + (fp === 'bottom' ? curveY : -curveY);
                    cp2x = p2.x; cp2y = p2.y + (tp === 'top' ? -curveY : curveY);
                } else {
                    cp1x = p1.x + (fp === 'right' ? curveX : -curveX); cp1y = p1.y;
                    cp2x = p2.x + (tp === 'left' ? -curveX : curveX); cp2y = p2.y;
                }

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${p1.x} ${p1.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`);
                path.classList.add('connection-path');

                if (isHierarchy) {
                    path.classList.add('hierarchy-connection');
                }

                // Get connection style from customConnection object
                const connStyle = customConnection || {};

                const strokeColor = connStyle.color || '#4fc3f7';
                const strokeWidth = connStyle.width || 4;

                path.setAttribute('stroke', strokeColor);
                path.setAttribute('stroke-width', strokeWidth);
                path.setAttribute('fill', 'none');

                // Store connection data
                path.dataset.fromId = String(fromN.id);
                path.dataset.toId = String(toN.id);
                path.dataset.isHierarchy = isHierarchy ? 'true' : 'false';

                // DRAG TO DISCONNECT - mousedown on path
                path.onmousedown = function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    console.log('Connection mousedown:', fromN.id, '->', toN.id);
                    window.activeConnectionDrag = {
                        path: path,
                        startX: e.clientX,
                        startY: e.clientY,
                        fromId: fromN.id,
                        toId: toN.id,
                        isHierarchy: isHierarchy,
                        originalColor: strokeColor,
                        originalWidth: strokeWidth
                    };
                    path.style.strokeWidth = (strokeWidth + 4) + 'px';
                    path.style.stroke = '#ff6b6b';
                    path.style.filter = 'drop-shadow(0 0 12px rgba(239, 69, 96, 0.9))';
                };

                connectionsEl.appendChild(path);

                // Calculate label position (middle of the path)
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;

                // Check if this is a task-to-task connection
                const isFromTask = fromN.isTaskNode || TASK_NODE_TYPES[fromN.type];
                const isToTask = toN.isTaskNode || TASK_NODE_TYPES[toN.type];

                if (isFromTask && isToTask) {
                    // Find dependency info - check both directions
                    let depInfo = (toN.taskDependencies || []).find(d => d.taskId === fromN.id);
                    if (!depInfo) {
                        depInfo = (fromN.taskDependencies || []).find(d => d.taskId === toN.id);
                    }

                    // Build label text - show FS as default if no dependency info
                    let labelText = depInfo ? (depInfo.type || 'FS') : 'FS';
                    if (depInfo && depInfo.lag && depInfo.lag !== 0) {
                        const lagUnit = depInfo.lagUnit || 'days';
                        const unitShort = {
                            'hours': 'h',
                            'days': 'd',
                            'weeks': 'w',
                            'months': 'm',
                            'years': 'y'
                        };
                        const sign = depInfo.lag > 0 ? '+' : '';
                        labelText += ` ${sign}${depInfo.lag}${unitShort[lagUnit] || 'd'}`;
                    }

                    // Create background rect for label
                    const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    const textWidth = labelText.length * 8 + 16;
                    labelBg.setAttribute('x', midX - textWidth/2);
                    labelBg.setAttribute('y', midY - 12);
                    labelBg.setAttribute('width', textWidth);
                    labelBg.setAttribute('height', 24);
                    labelBg.setAttribute('rx', 6);
                    labelBg.setAttribute('fill', '#1a1a2e');
                    labelBg.setAttribute('stroke', '#e94560');
                    labelBg.setAttribute('stroke-width', '2');
                    labelBg.classList.add('dependency-label-bg');
                    connectionsEl.appendChild(labelBg);

                    // Create text label
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', midX);
                    label.setAttribute('y', midY + 5);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', '#fff');
                    label.setAttribute('font-size', '12');
                    label.setAttribute('font-weight', 'bold');
                    label.setAttribute('font-family', 'monospace');
                    label.classList.add('dependency-label');
                    label.textContent = labelText;
                    connectionsEl.appendChild(label);

                    // Style the path differently for task dependencies
                    path.classList.add('task-dependency-path');
                }
                // NO direction indicators - clean lines only
            }

            // Draw parent-child hierarchy connections
            nodes.forEach(node => {
                if (node.parentId && !isNodeHidden(node)) {
                    const parent = nodes.find(n => String(n.id) === String(node.parentId));
                    if (parent && !isNodeHidden(parent)) {
                        // Check if there's style info in connections array
                        const connStyle = connections.find(c =>
                            (String(c.from) === String(parent.id) && String(c.to) === String(node.id)) ||
                            (String(c.from) === String(node.id) && String(c.to) === String(parent.id))
                        );
                        drawConnection(parent, node, true, connStyle);
                    }
                }
            });

            // Draw explicit connections from connections array
            // Skip if already drawn as hierarchy connection
            connections.forEach(conn => {
                const fromNode = nodes.find(n => String(n.id) === String(conn.from));
                const toNode = nodes.find(n => String(n.id) === String(conn.to));
                if (fromNode && toNode && !isNodeHidden(fromNode) && !isNodeHidden(toNode)) {
                    // Check if this is already a hierarchy connection (parentId relationship)
                    const isAlreadyHierarchy = (String(toNode.parentId) === String(fromNode.id)) || (String(fromNode.parentId) === String(toNode.id));
                    if (!isAlreadyHierarchy) {
                        // Only draw if not already drawn as hierarchy
                        drawConnection(fromNode, toNode, false, conn);
                    }
                }
            });
        }

        // ============ GLOBAL CONNECTION DRAG HANDLERS ============
        window.activeConnectionDrag = null;

        document.addEventListener('mousemove', (e) => {
            if (!window.activeConnectionDrag) return;
            const drag = window.activeConnectionDrag;
            if (!drag.path || !drag.path.parentNode) {
                window.activeConnectionDrag = null;
                return;
            }

            const dx = Math.abs(e.clientX - drag.startX);
            const dy = Math.abs(e.clientY - drag.startY);
            const distance = Math.sqrt(dx*dx + dy*dy);

            // Visual feedback based on distance
            if (distance > 30) {
                drag.path.setAttribute('stroke', '#ef4444');
                drag.path.style.opacity = '0.5';
                drag.path.style.strokeDasharray = '10,5';
            } else {
                drag.path.setAttribute('stroke', drag.originalColor);
                drag.path.style.opacity = '1';
                drag.path.style.strokeDasharray = '';
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (!window.activeConnectionDrag) return;
            const drag = window.activeConnectionDrag;

            const dx = Math.abs(e.clientX - drag.startX);
            const dy = Math.abs(e.clientY - drag.startY);
            const distance = Math.sqrt(dx*dx + dy*dy);

            // If dragged more than 50px, disconnect
            if (distance > 50) {
                const fId = String(drag.fromId);
                const tId = String(drag.toId);

                console.log('Disconnecting:', fId, tId, 'isHierarchy:', drag.isHierarchy);

                if (drag.isHierarchy) {
                    // Remove parent-child relationship
                    const childNode = nodes.find(n => String(n.id) === tId);
                    if (childNode) {
                        childNode.parentId = null;
                        console.log('Removed parent from child:', childNode.title);
                    }
                }

                // Remove from connections array
                const connIdx = connections.findIndex(c =>
                    (String(c.from) === fId && String(c.to) === tId) ||
                    (String(c.from) === tId && String(c.to) === fId)
                );
                if (connIdx !== -1) {
                    connections.splice(connIdx, 1);
                    console.log('Removed connection at index:', connIdx);
                }

                // Also remove task dependencies
                const node1 = nodes.find(n => String(n.id) === fId);
                const node2 = nodes.find(n => String(n.id) === tId);
                if (node1 && node1.taskDependencies) {
                    node1.taskDependencies = node1.taskDependencies.filter(d => String(d.taskId) !== tId);
                }
                if (node2 && node2.taskDependencies) {
                    node2.taskDependencies = node2.taskDependencies.filter(d => String(d.taskId) !== fId);
                }

                window.activeConnectionDrag = null;
                saveToLocalStorage();
                renderConnections();
                showToast('‚úÇÔ∏è Baƒülantƒ± koparƒ±ldƒ±');
            } else {
                // Reset styles if not disconnected
                if (drag.path && drag.path.parentNode) {
                    drag.path.setAttribute('stroke', drag.originalColor);
                    drag.path.style.strokeWidth = drag.originalWidth + 'px';
                    drag.path.style.filter = '';
                    drag.path.style.opacity = '1';
                    drag.path.style.strokeDasharray = '';
                }
                window.activeConnectionDrag = null;
            }
        });

        // ============ CONNECTIONS ============
        let isDraggingConnection = false;
        let dragConnectionFrom = null;
        let dragConnectionFromPos = null;
        let tempConnectionLine = null;

        function startConnection() {
            isConnecting = true;
            connectionStart = null;
            showToast('Click starting point');
        }

        // ============ CONNECTION MENU - COMPLETELY REWRITTEN ============
        // Store selected connection info globally
        let currentConnection = {
            fromId: null,
            toId: null,
            isHierarchy: false
        };

        function showConnectionMenu(e, fromId, toId, isHierarchy) {
            e.preventDefault();
            e.stopPropagation();

            // Store connection info
            currentConnection = { fromId, toId, isHierarchy };
            console.log('Connection menu opened:', currentConnection);

            const menu = document.getElementById('connectionMenu');
            menu.style.display = 'block';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';

            // Highlight selected connection
            document.querySelectorAll('.connection-path').forEach(p => {
                p.classList.remove('selected');
                if ((p.dataset.fromId === fromId && p.dataset.toId === toId) ||
                    (p.dataset.fromId === toId && p.dataset.toId === fromId)) {
                    p.classList.add('selected');
                }
            });
        }

        function hideConnectionMenu() {
            const menu = document.getElementById('connectionMenu');
            if (menu) menu.style.display = 'none';
            document.querySelectorAll('.connection-path').forEach(p => p.classList.remove('selected'));
        }

        // Get or create connection object
        function getOrCreateConnection(fromId, toId) {
            let conn = connections.find(c =>
                (c.from === fromId && c.to === toId) ||
                (c.from === toId && c.to === fromId)
            );

            if (!conn) {
                conn = { from: fromId, to: toId };
                connections.push(conn);
                console.log('Created new connection entry:', conn);
            }

            return conn;
        }

        // Apply connection change
        function applyConnectionChange(property, value) {
            const { fromId, toId } = currentConnection;

            console.log('applyConnectionChange:', property, value, 'connection:', fromId, '->', toId);

            if (!fromId || !toId) {
                showToast('Baƒülantƒ± se√ßilmedi!', 'error');
                return false;
            }

            const conn = getOrCreateConnection(fromId, toId);
            conn[property] = value;

            console.log('Connection updated:', conn);

            hideConnectionMenu();
            renderConnections();
            saveToLocalStorage();

            return true;
        }

        // Disconnect nodes
        function disconnectNodes() {
            const { fromId, toId } = currentConnection;

            console.log('disconnectNodes:', fromId, '->', toId);

            if (!fromId || !toId) {
                showToast('Baƒülantƒ± se√ßilmedi!', 'error');
                return;
            }

            saveUndoState('disconnect nodes');

            // Remove from connections array
            connections = connections.filter(c =>
                !(c.from === fromId && c.to === toId) &&
                !(c.from === toId && c.to === fromId)
            );

            // Clear parentId relationships (both directions)
            const node1 = nodes.find(n => n.id === toId);
            if (node1 && node1.parentId === fromId) {
                node1.parentId = null;
                node1.linkedNodeIds = [];
            }
            const node2 = nodes.find(n => n.id === fromId);
            if (node2 && node2.parentId === toId) {
                node2.parentId = null;
                node2.linkedNodeIds = [];
            }

            // Remove task dependencies (both directions)
            [fromId, toId].forEach(id => {
                const node = nodes.find(n => n.id === id);
                if (node && node.taskDependencies) {
                    const otherId = id === fromId ? toId : fromId;
                    node.taskDependencies = node.taskDependencies.filter(d => d.taskId !== otherId);
                }
            });

            hideConnectionMenu();
            renderConnections();
            renderOutline();
            saveToLocalStorage();
            showToast('Baƒülantƒ± koparƒ±ldƒ±');
            currentConnection = { fromId: null, toId: null, isHierarchy: false };
        }

        // Flip connection direction
        function flipConnectionDirection() {
            const { fromId, toId } = currentConnection;

            console.log('flipConnectionDirection:', fromId, '->', toId);

            if (!fromId || !toId) {
                showToast('Baƒülantƒ± se√ßilmedi!', 'error');
                return;
            }

            saveUndoState('flip connection');

            // Find and flip the connection
            const conn = connections.find(c =>
                (c.from === fromId && c.to === toId) ||
                (c.from === toId && c.to === fromId)
            );

            if (conn) {
                // Swap from and to
                const temp = conn.from;
                conn.from = conn.to;
                conn.to = temp;
                console.log('Connection flipped:', conn);
            } else {
                // Check parentId relationships
                const childNode = nodes.find(n => n.id === toId);
                const parentNode = nodes.find(n => n.id === fromId);

                if (childNode && childNode.parentId === fromId) {
                    // Flip: child becomes parent, parent becomes child
                    childNode.parentId = null;
                    if (parentNode) parentNode.parentId = toId;

                    // Add to connections array with flipped direction
                    connections.push({ from: toId, to: fromId });
                } else if (parentNode && parentNode.parentId === toId) {
                    parentNode.parentId = null;
                    if (childNode) childNode.parentId = fromId;
                    connections.push({ from: fromId, to: toId });
                }
            }

            // Update currentConnection for subsequent operations
            currentConnection = { fromId: toId, toId: fromId, isHierarchy: currentConnection.isHierarchy };

            hideConnectionMenu();
            renderConnections();
            saveToLocalStorage();
            showToast('üîÑ Y√∂n √ßevrildi');
        }

        // Initialize connection menu event listeners - SIMPLIFIED (only disconnect)
        function initConnectionMenuListeners() {
            const menu = document.getElementById('connectionMenu');
            if (!menu) return;

            // Prevent menu from closing when clicking inside
            menu.addEventListener('click', (e) => e.stopPropagation());

            // Disconnect button - ONLY button now
            document.getElementById('connMenuDisconnect')?.addEventListener('click', (e) => {
                e.stopPropagation();
                disconnectNodes();
            });

            // Add hover effect
            const disconnectBtn = document.getElementById('connMenuDisconnect');
            if (disconnectBtn) {
                disconnectBtn.addEventListener('mouseenter', () => {
                    disconnectBtn.style.background = 'rgba(239, 68, 68, 0.2)';
                });
                disconnectBtn.addEventListener('mouseleave', () => {
                    disconnectBtn.style.background = 'transparent';
                });
            }

            console.log('Connection menu listeners initialized (simplified)');
        }

        // Close connection menu on click outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('connectionMenu');
            if (menu && menu.style.display === 'block' && !menu.contains(e.target)) {
                hideConnectionMenu();
                currentConnection = { fromId: null, toId: null, isHierarchy: false };
            }
        });

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            initConnectionMenuListeners();
        });

        // Also call immediately if DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(initConnectionMenuListeners, 100);
        }

        function handleConnClick(nodeId, pos) {
            if (!isConnecting) {
                isConnecting = true;
                connectionStart = nodeId;
                connectionStartPos = pos;
                showToast('Click target point');
                return;
            }

            if (connectionStart === null) {
                connectionStart = nodeId;
                connectionStartPos = pos;
                showToast('Click target point');
            } else if (nodeId !== connectionStart) {
                const exists = connections.some(c => c.from === connectionStart && c.to === nodeId);
                if (!exists) {
                    saveUndoState('create connection');
                    connections.push({ from: connectionStart, to: nodeId, fp: connectionStartPos, tp: pos });

                    // If both are task nodes, create default dependency
                    const fromNode = nodes.find(n => n.id === connectionStart);
                    const toNode = nodes.find(n => n.id === nodeId);
                    const isFromTask = fromNode && (fromNode.isTaskNode || TASK_NODE_TYPES[fromNode.type]);
                    const isToTask = toNode && (toNode.isTaskNode || TASK_NODE_TYPES[toNode.type]);

                    // If both are task nodes, set parent-child relationship for outline hierarchy
                    if (isFromTask && isToTask) {
                        // TO node becomes a child of FROM node (for outline nesting)
                        if (!toNode.parentId) {
                            toNode.parentId = connectionStart;
                            toNode.linkedNodeIds = [connectionStart];
                        }
                        
                        // Also add task dependency
                        if (!toNode.taskDependencies) toNode.taskDependencies = [];
                        const existingDep = toNode.taskDependencies.find(d => d.taskId === connectionStart);
                        if (!existingDep) {
                            toNode.taskDependencies.push({
                                taskId: connectionStart,
                                type: 'FS',
                                lag: 0,
                                lagUnit: 'days'
                            });
                        }
                    }

                    renderConnections();
                    renderOutline();
                    showToast('Connection created');
                }
                isConnecting = false;
                connectionStart = null;
            }
        }

        // ============ DRAG CONNECTION (from conn-point) ============
        function startConnectionDrag(nodeId, pos, clientX, clientY) {
            isDraggingConnection = true;
            dragConnectionFrom = nodeId;
            dragConnectionFromPos = pos;

            // Create temporary line element
            if (!tempConnectionLine) {
                tempConnectionLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                tempConnectionLine.setAttribute('stroke', '#e94560');
                tempConnectionLine.setAttribute('stroke-width', '3');
                tempConnectionLine.setAttribute('stroke-dasharray', '8,4');
                tempConnectionLine.id = 'tempConnectionLine';
            }

            const fromNode = nodes.find(n => n.id === nodeId);
            if (!fromNode) return;

            const cardSize = appSettings.cardSize || 'medium';
            const fromEl = document.getElementById(`node-${nodeId}`);
            // Check if this is a task node - use 260px width for task nodes
            const isTaskNodeEl = fromEl && fromEl.classList.contains('task-node-card');
            const nodeWidth = isTaskNodeEl ? 300 : (cardSize === 'small' ? 180 : cardSize === 'large' ? 320 : 240);
            const fromHeight = fromEl ? fromEl.getBoundingClientRect().height / zoom : 100;

            const startPoint = getConnectionPoint(fromNode, fromHeight, nodeWidth, pos);
            tempConnectionLine.setAttribute('x1', startPoint.x);
            tempConnectionLine.setAttribute('y1', startPoint.y);
            tempConnectionLine.setAttribute('x2', startPoint.x);
            tempConnectionLine.setAttribute('y2', startPoint.y);

            connectionsEl.appendChild(tempConnectionLine);

            // Highlight source node
            const sourceNode = document.getElementById(`node-${nodeId}`);
            if (sourceNode) {
                sourceNode.classList.add('connection-source');
            }

            // Highlight all other conn-points and show hint on nodes
            document.querySelectorAll('.conn-point').forEach(cp => {
                if (cp.dataset.id !== nodeId) {
                    cp.classList.add('conn-target-highlight');
                }
            });
        }

        function getConnectionPoint(node, height, width, pos) {
            let x, y;
            switch(pos) {
                case 'top': x = node.x + width/2; y = node.y; break;
                case 'bottom': x = node.x + width/2; y = node.y + height; break;
                case 'left': x = node.x; y = node.y + height/2; break;
                case 'right': x = node.x + width; y = node.y + height/2; break;
                default: x = node.x + width/2; y = node.y + height;
            }
            return { x, y };
        }

        function updateConnectionDrag(clientX, clientY) {
            if (!isDraggingConnection || !tempConnectionLine) return;

            const canvasRect = canvas.getBoundingClientRect();
            const x = (clientX - canvasRect.left) / zoom + canvas.scrollLeft;
            const y = (clientY - canvasRect.top) / zoom + canvas.scrollTop;

            tempConnectionLine.setAttribute('x2', x);
            tempConnectionLine.setAttribute('y2', y);

            // Check if hovering over a node or conn-point
            const hoveredElement = document.elementFromPoint(clientX, clientY);

            // Remove all highlights first
            document.querySelectorAll('.conn-point').forEach(cp => cp.classList.remove('conn-hover'));
            document.querySelectorAll('.node, .task-node-card, .folder-node, .sticky-node, .image-node').forEach(n => n.classList.remove('drop-target-highlight'));

            if (hoveredElement) {
                // Check if hovering over conn-point
                if (hoveredElement.classList.contains('conn-point') &&
                    hoveredElement.dataset.id !== dragConnectionFrom) {
                    hoveredElement.classList.add('conn-hover');
                } else {
                    // Check if hovering over node, task-node-card, or special nodes (folder, sticky, image)
                    const hoveredNode = hoveredElement.closest('.node, .task-node-card, .folder-node, .sticky-node, .image-node');
                    if (hoveredNode) {
                        const nodeId = hoveredNode.id.replace('node-', '');
                        if (nodeId !== dragConnectionFrom) {
                            hoveredNode.classList.add('drop-target-highlight');
                        }
                    }
                }
            }
        }

        function endConnectionDrag(clientX, clientY) {
            if (!isDraggingConnection) return;

            // Remove temp line
            if (tempConnectionLine && tempConnectionLine.parentNode) {
                tempConnectionLine.parentNode.removeChild(tempConnectionLine);
            }

            // Remove all highlights
            document.querySelectorAll('.conn-point').forEach(cp => {
                cp.classList.remove('conn-target-highlight');
                cp.classList.remove('conn-hover');
            });
            document.querySelectorAll('.node, .task-node-card, .folder-node, .sticky-node, .image-node').forEach(n => {
                n.classList.remove('drop-target-highlight');
                n.classList.remove('connection-source');
            });

            // Find target - either conn-point or node itself
            const droppedElement = document.elementFromPoint(clientX, clientY);
            let targetNodeId = null;
            let targetPos = 'top'; // default

            if (droppedElement) {
                if (droppedElement.classList.contains('conn-point')) {
                    // Dropped on specific conn-point
                    targetNodeId = droppedElement.dataset.id;
                    targetPos = droppedElement.dataset.pos;
                } else {
                    // Check if dropped on node, task-node-card, or special nodes (folder, sticky, image)
                    const targetNode = droppedElement.closest('.node, .task-node-card, .folder-node, .sticky-node, .image-node');
                    if (targetNode) {
                        targetNodeId = targetNode.id.replace('node-', '');
                        // Auto-determine best connection point
                        const fromNode = nodes.find(n => n.id === dragConnectionFrom);
                        const toNode = nodes.find(n => n.id === targetNodeId);
                        if (fromNode && toNode) {
                            const dx = toNode.x - fromNode.x;
                            const dy = toNode.y - fromNode.y;
                            if (Math.abs(dy) > Math.abs(dx)) {
                                targetPos = dy > 0 ? 'top' : 'bottom';
                            } else {
                                targetPos = dx > 0 ? 'left' : 'right';
                            }
                        }
                    }
                }
            }

            // Create/remove hierarchy connection
            if (targetNodeId && targetNodeId !== dragConnectionFrom) {
                const draggedNode = nodes.find(n => n.id === dragConnectionFrom);
                const targetNode = nodes.find(n => n.id === targetNodeId);

                if (draggedNode && targetNode) {
                    saveUndoState('change connection');
                    // Check if nodes are task nodes
                    const isFromTask = draggedNode.isTaskNode || TASK_NODE_TYPES[draggedNode.type];
                    const isToTask = targetNode.isTaskNode || TASK_NODE_TYPES[targetNode.type];

                    // For task nodes: TARGET becomes child of SOURCE (dragged from)
                    // For regular nodes: SOURCE (dragged from) becomes child of TARGET
                    if (isFromTask && isToTask) {
                        // TASK NODES: Target becomes child of source
                        if (targetNode.parentId === dragConnectionFrom) {
                        // Remove parent relationship
                            targetNode.parentId = null;
                            targetNode.linkedNodeIds = [];
                            // Remove from connections
                            const connIdx = connections.findIndex(c => c.from === dragConnectionFrom && c.to === targetNodeId);
                            if (connIdx !== -1) connections.splice(connIdx, 1);
                        renderAll();
                        renderConnections();
                        renderOutline();
                            showToast('Baƒülantƒ± kaldƒ±rƒ±ldƒ±!');
                    } else {
                        // Check for circular reference
                            if (!isDescendantOf(dragConnectionFrom, targetNodeId)) {
                                // Make target a child of source (FROM -> TO hierarchy)
                                targetNode.parentId = dragConnectionFrom;
                                targetNode.linkedNodeIds = [dragConnectionFrom];

                            // Add to connections array if not exists
                                const connExists = connections.some(c => c.from === dragConnectionFrom && c.to === targetNodeId);
                            if (!connExists) {
                                    connections.push({ from: dragConnectionFrom, to: targetNodeId, fp: 'bottom', tp: 'top' });
                                }

                                // Create task dependency
                                if (!targetNode.taskDependencies) targetNode.taskDependencies = [];
                                const existingDep = targetNode.taskDependencies.find(d => d.taskId === dragConnectionFrom);
                                if (!existingDep) {
                                    targetNode.taskDependencies.push({
                                        taskId: dragConnectionFrom,
                                        type: 'FS',
                                        lag: 0,
                                        lagUnit: 'days'
                                    });
                                }

                                renderAll();
                                renderConnections();
                                renderOutline();
                                showToast('Baƒülandƒ±!');
                            } else {
                                showToast('D√∂ng√ºsel baƒülantƒ± olu≈üturulamaz!');
                            }
                        }
                    } else {
                        // REGULAR NODES: Source becomes child of target (original behavior)
                        if (draggedNode.parentId === targetNodeId) {
                            // Remove parent relationship
                            draggedNode.parentId = null;
                            renderAll();
                            renderConnections();
                            renderOutline();
                            showToast('Baƒülantƒ± kaldƒ±rƒ±ldƒ±!');
                        } else {
                            // Check for circular reference
                            if (!isDescendantOf(targetNodeId, dragConnectionFrom)) {
                                // Make dragged node a child of target
                                draggedNode.parentId = targetNodeId;

                                // Add to connections array if not exists
                                const connExists = connections.some(c => c.from === targetNodeId && c.to === dragConnectionFrom);
                                if (!connExists) {
                                    connections.push({ from: targetNodeId, to: dragConnectionFrom, fp: 'bottom', tp: 'top' });
                            }

                            renderAll();
                            renderConnections();
                            renderOutline();
                                showToast('Baƒülandƒ±!');
                        } else {
                                showToast('D√∂ng√ºsel baƒülantƒ± olu≈üturulamaz!');
                            }
                        }
                    }
                }
            } else if (!targetNodeId) {
                // Dropped on empty space - remove from parent (make root)
                const draggedNode = nodes.find(n => n.id === dragConnectionFrom);
                if (draggedNode && draggedNode.parentId) {
                    draggedNode.parentId = null;
                    renderAll();
                    renderConnections();
                    renderOutline();
                    showToast('Moved to root level!');
                }
            }

            isDraggingConnection = false;
            dragConnectionFrom = null;
            dragConnectionFromPos = null;
        }

        // Global mouse events for connection drag
        document.addEventListener('mousemove', e => {
            if (isDraggingConnection) {
                updateConnectionDrag(e.clientX, e.clientY);
            }
        });

        document.addEventListener('mouseup', e => {
            if (isDraggingConnection) {
                endConnectionDrag(e.clientX, e.clientY);
            }
        });

        // ============ INFINITE CANVAS PAN ============
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panScrollLeft = 0;
        let panScrollTop = 0;

        // Middle mouse button or Space + drag to pan
        canvasContainer.addEventListener('mousedown', (e) => {
            // Middle mouse button (button 1) or left click on empty canvas
            if (e.button === 1 || (e.button === 0 && e.target === canvas)) {
                if (e.button === 1) e.preventDefault();

                // Don't pan if clicking on a node
                if (e.target.closest('.node')) return;

                isPanning = true;
                canvas.classList.add('panning');
                panStartX = e.clientX;
                panStartY = e.clientY;
                panScrollLeft = canvasContainer.scrollLeft;
                panScrollTop = canvasContainer.scrollTop;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPanning) return;

            const dx = e.clientX - panStartX;
            const dy = e.clientY - panStartY;

            canvasContainer.scrollLeft = panScrollLeft - dx;
            canvasContainer.scrollTop = panScrollTop - dy;
        });

        document.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.classList.remove('panning');
            }
        });

        // Prevent middle click scroll behavior
        canvasContainer.addEventListener('auxclick', (e) => {
            if (e.button === 1) e.preventDefault();
        });

        // Space bar to enable pan mode
        let spacePressed = false;
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.target.closest('input, textarea, [contenteditable]')) {
                if (!spacePressed) {
                    spacePressed = true;
                    canvas.style.cursor = 'grab';
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
                canvas.style.cursor = '';
            }
        });

        // Mouse wheel zoom
        canvasContainer.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }
        }, { passive: false });

        // ============ FULL TEXT EDITOR - CLEAN VERSION ============
        let editorInitialized = false;

        // Initialize Editor
        function initQuillEditor() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;
            if (editorInitialized) return;

            // Setup contenteditable
            editor.contentEditable = 'true';
            editor.spellcheck = true;

            // Events
            editor.addEventListener('input', onEditorInput);
            editor.addEventListener('keydown', onEditorKeydown);
            editor.addEventListener('paste', onEditorPaste);

            editorInitialized = true;
        }

        function onEditorInput(e) {
            updateEditorStats();
            updateEditProgress();
            // Auto-save after 2 seconds
            clearTimeout(window.editorAutoSaveTimer);
            window.editorAutoSaveTimer = setTimeout(autoSaveCurrentEdit, 2000);
        }

        // Custom Undo/Redo Functions
        function saveEditorState() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            const currentContent = editor.innerHTML;
            if (currentContent !== lastEditorContent) {
                editorUndoStack.push(lastEditorContent);
                if (editorUndoStack.length > MAX_UNDO_STACK) {
                    editorUndoStack.shift(); // Remove oldest
                }
                editorRedoStack = []; // Clear redo stack on new change
                lastEditorContent = currentContent;
            }
        }

        function editorUndo() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor || editorUndoStack.length === 0) {
                showToast('‚Ü©Ô∏è Nothing to undo');
                return;
            }

            // Save current state to redo stack
            editorRedoStack.push(editor.innerHTML);

            // Restore previous state
            const previousState = editorUndoStack.pop();
            editor.innerHTML = previousState;
            lastEditorContent = previousState;

            showToast('‚Ü©Ô∏è Undo');
        }

        function editorRedo() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor || editorRedoStack.length === 0) {
                showToast('‚Ü™Ô∏è Nothing to redo');
                return;
            }

            // Save current state to undo stack
            editorUndoStack.push(editor.innerHTML);

            // Restore next state
            const nextState = editorRedoStack.pop();
            editor.innerHTML = nextState;
            lastEditorContent = nextState;

            showToast('‚Ü™Ô∏è Redo');
        }

        function initEditorUndoSystem() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            // Reset stacks
            editorUndoStack = [];
            editorRedoStack = [];
            lastEditorContent = editor.innerHTML;

            // Save state periodically and on significant changes
            let saveTimer = null;

            editor.addEventListener('input', function() {
                clearTimeout(saveTimer);
                saveTimer = setTimeout(saveEditorState, 500); // Save after 500ms of no input
            });

            // Also save before image operations
            editor.addEventListener('beforeinput', function(e) {
                if (e.inputType === 'insertFromPaste' || e.inputType === 'deleteContentBackward') {
                    saveEditorState();
                }
            });
        }

        function onEditorKeydown(e) {
            // Tab key - insert spaces
            if (e.key === 'Tab') {
                e.preventDefault();
                document.execCommand('insertText', false, '    ');
            }
            // Ctrl+Z - Custom Undo
            if (e.ctrlKey && !e.shiftKey && e.key === 'z') {
                e.preventDefault();
                editorUndo();
                return;
            }
            // Ctrl+Y or Ctrl+Shift+Z - Custom Redo
            if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z') || (e.ctrlKey && e.shiftKey && e.key === 'Z')) {
                e.preventDefault();
                editorRedo();
                return;
            }
            // Ctrl+B - Bold
            if (e.ctrlKey && e.key === 'b') {
                e.preventDefault();
                document.execCommand('bold');
            }
            // Ctrl+I - Italic
            if (e.ctrlKey && e.key === 'i') {
                e.preventDefault();
                document.execCommand('italic');
            }
            // Ctrl+U - Underline
            if (e.ctrlKey && e.key === 'u') {
                e.preventDefault();
                document.execCommand('underline');
            }
        }

        function onEditorPaste(e) {
            e.preventDefault();

            // Try to get HTML content first, fall back to plain text
            let html = e.clipboardData.getData('text/html');
            const plainText = e.clipboardData.getData('text/plain');

            if (html) {
                // Clean HTML - remove scripts, styles, and dangerous attributes
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;

                // Remove script and style tags
                tempDiv.querySelectorAll('script, style, meta, link').forEach(el => el.remove());

                // Remove dangerous attributes
                tempDiv.querySelectorAll('*').forEach(el => {
                    ['onclick', 'onerror', 'onload', 'onmouseover', 'onfocus', 'onblur'].forEach(attr => {
                        el.removeAttribute(attr);
                    });
                    // Remove style attribute to prevent weird formatting, keep basic structure
                    if (el.tagName !== 'SPAN' && el.tagName !== 'FONT') {
                        el.removeAttribute('style');
                    }
                });

                // Insert cleaned HTML
                document.execCommand('insertHTML', false, tempDiv.innerHTML);
            } else if (plainText) {
                // Convert plain text line breaks to HTML paragraphs
                const htmlContent = plainText
                    .split(/\n\n+/)  // Split by double line breaks (paragraphs)
                    .map(para => para.trim())
                    .filter(para => para.length > 0)
                    .map(para => `<p>${para.replace(/\n/g, '<br>')}</p>`)
                    .join('');

                if (htmlContent) {
                    document.execCommand('insertHTML', false, htmlContent);
                } else {
                    document.execCommand('insertText', false, plainText);
                }
            }
        }

        // Auto-save current edit
        function autoSaveCurrentEdit() {
            if (!editingNodeId) return;
            const node = nodes.find(n => n.id === editingNodeId);
            if (!node) return;

            const editor = document.getElementById('fullTextEditor');
            if (editor) node.fullText = editor.innerHTML;
            autoSave();
        }

        // ==========================================
        // TASK NODE EDITOR FUNCTIONS
        // ==========================================
        // Note: openTaskNodeEditor is defined later in the code

        function toggleTaskStatus(newStatus) {
            if (!selectedNode) return;
            hideAllMenus();

            const node = nodes.find(n => n.id === selectedNode);
            if (!node) return;

            saveUndoState('change task status');

            // Toggle: if already this status, set to 'todo', else set to newStatus
            if (node.taskStatus === newStatus) {
                node.taskStatus = 'todo';
            } else {
                node.taskStatus = newStatus;
            }

            // If complete, set progress to 100
            if (newStatus === 'complete' || newStatus === 'done') {
                node.taskProgress = 100;
            }

            renderNode(node);
            renderConnections();
            renderOutline();
            updateStatsPanel();
            autoSave();

            const statusNames = { complete: 'Tamamlandƒ±', working: '√áalƒ±≈üƒ±lƒ±yor', urgent: 'Acil', todo: 'Yapƒ±lacak' };
            showToast(`‚úì Task durumu: ${statusNames[node.taskStatus] || node.taskStatus}`);
        }

        function openFullEditor(id = null) {
            const nodeId = id !== null ? id : selectedNode;
            if (!nodeId && nodeId !== 0) {
                console.error('openFullEditor: No nodeId provided');
                return;
            }

            editingNodeId = nodeId;
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) {
                console.error('openFullEditor: Node not found:', nodeId);
                return;
            }

            document.getElementById('editorTitle').textContent = `‚úèÔ∏è ${node.title}`;
            document.getElementById('editType').value = node.type;
            document.getElementById('editStatus').value = node.sectionStatus || 'none';
            document.getElementById('editTitle').value = node.title;
            document.getElementById('editSummary').value = node.summary || '';
            document.getElementById('editPov').value = node.povId || '';
            document.getElementById('editTarget').value = node.target || '';
            document.getElementById('editNotes').value = node.notes || '';

            tempDescs = [...(node.descs || [])];
            renderEditDescs();
            renderRevisionLabels();

            hideAllMenus();
            const modal = document.getElementById('editorModal');
            modal.style.display = 'flex';
            modal.classList.add('active');

            // Initialize editor and set content
            setTimeout(() => {
                const editor = document.getElementById('fullTextEditor');
                if (!editor) return;

                // Initialize editor
                initQuillEditor();

                // Set content - normalize to ensure proper paragraph structure
                let content = node.fullText || '';

                // If content exists but doesn't have block elements, wrap in paragraphs
                if (content && !content.match(/<(p|div|h[1-6]|ul|ol|li|blockquote)/i)) {
                    // Convert plain text or text with only <br> to paragraphs
                    content = content
                        .split(/(<br\s*\/?>\s*){2,}/gi)  // Split by double line breaks
                        .map(para => para.trim())
                        .filter(para => para.length > 0 && para !== '<br>' && para !== '<br/>')
                        .map(para => `<p>${para}</p>`)
                        .join('');
                }

                editor.innerHTML = content;

                // Initialize custom undo/redo system
                initEditorUndoSystem();

                // Set placeholder
                if (!node.fullText) {
                    editor.setAttribute('data-placeholder', 'Start writing your text here...');
                }

                // Apply font settings from dropdowns
                const fontSizeSelect = document.getElementById('fontSize');
                const fontFamilySelect = document.getElementById('fontFamily');
                if (fontSizeSelect) editor.style.fontSize = fontSizeSelect.value;
                if (fontFamilySelect) editor.style.fontFamily = fontFamilySelect.value;

                // Focus editor
                editor.focus();

                // Selection listener ekle - edit√∂r a√ßƒ±ldƒ±ƒüƒ±nda
                editor.addEventListener('mouseup', function() {
                    const sel = window.getSelection();
                    if (sel.rangeCount > 0 && !sel.isCollapsed && sel.toString().length > 0) {
                        savedSelection = sel.getRangeAt(0).cloneRange();
                        savedSelectionText = sel.toString();
                        console.log('‚úÖ Selection saved:', savedSelectionText);
                    } else {
                        // Se√ßim yok veya bo≈ü - TEMƒ∞ZLE
                        savedSelection = null;
                        savedSelectionText = '';
                        console.log('üî¥ Selection cleared');
                    }
                });

                // Edit√∂re tƒ±klandƒ±ƒüƒ±nda se√ßim yoksa temizle + image click handling
                editor.addEventListener('click', function(e) {
                    // Image'a tƒ±klandƒ±ysa toolbar g√∂ster
                    const clickedImg = e.target.closest('.editor-image') || (e.target.tagName === 'IMG' ? e.target : null);
                    if (clickedImg) {
                        e.stopPropagation();
                        const wrapper = clickedImg.closest('.editor-image-wrapper') || clickedImg.parentElement;
                        showImageToolbar(clickedImg, wrapper);
                        return;
                    }

                    const sel = window.getSelection();
                    if (!sel || sel.isCollapsed || sel.toString().length === 0) {
                        savedSelection = null;
                        savedSelectionText = '';
                        console.log('üî¥ Selection cleared on click');
                    }
                });

                editor.addEventListener('keyup', function(e) {
                    const sel = window.getSelection();
                    // Shift ile se√ßim yapƒ±lƒ±yorsa kaydet
                    if (e.shiftKey && sel.rangeCount > 0 && !sel.isCollapsed && sel.toString().length > 0) {
                        savedSelection = sel.getRangeAt(0).cloneRange();
                        savedSelectionText = sel.toString();
                        console.log('‚úÖ Selection saved on keyup:', savedSelectionText);
                    } else if (!e.shiftKey) {
                        // Shift basƒ±lƒ± deƒüilse ve se√ßim yoksa temizle
                        if (!sel || sel.isCollapsed || sel.toString().length === 0) {
                            savedSelection = null;
                            savedSelectionText = '';
                        }
                    }
                });

                // Update stats
                updateEditorStats();
                updateEditProgress();
                renderEditorTree();
                renderEditorAttachments();
            }, 100);
        }

        function renderEditDescs() {
            const container = document.getElementById('editDescList');
            container.innerHTML = tempDescs.map((d, i) => {
                const dt = descTypes.find(t => t.id === d.tid);
                if (!dt) return '';
                return `<div class="desc-item">
                    <span>${dt.icon}</span>
                    <span>${d.val}</span>
                    <button onclick="removeEditDesc(${i})">√ó</button>
                </div>`;
            }).join('');
        }

        function addDescToEdit() {
            const tid = parseInt(document.getElementById('newDescType').value);
            const val = document.getElementById('newDescValue').value.trim();
            if (!tid || !val) return;

            tempDescs.push({ tid, val });
            renderEditDescs();
            document.getElementById('newDescValue').value = '';
        }

        function removeEditDesc(i) {
            tempDescs.splice(i, 1);
            renderEditDescs();
        }

        function saveFullEdit() {
            const node = nodes.find(n => n.id === editingNodeId);
            if (!node) return;

            // Get editor content - use contenteditable div, not Quill
            const editor = document.getElementById('fullTextEditor');
            const editorContent = editor ? editor.innerHTML : '';

            node.type = document.getElementById('editType').value;
            node.sectionStatus = document.getElementById('editStatus').value || 'none';
            node.title = document.getElementById('editTitle').value;
            node.fullText = editorContent;
            node.summary = document.getElementById('editSummary').value;
            node.povId = parseInt(document.getElementById('editPov').value) || null;
            node.target = parseInt(document.getElementById('editTarget').value) || 0;
            node.notes = document.getElementById('editNotes').value;
            node.descs = [...tempDescs];

            closeModal('editorModal');
            renderAll();
            updateAllStats();
            renderOutline();
            autoSave(); // Otomatik kaydet
            showToast('üíæ Kaydedildi');
        }

        // ============ EDITOR SIDEBAR - TREE & ATTACHMENTS ============
        function renderEditorTree() {
            const container = document.getElementById('editorTree');
            if (!container) return;

            let html = '';
            function renderTreeNode(parentId, level) {
                const children = nodes.filter(n => n.parentId === parentId);
                children.forEach(node => {
                    const indent = level * 12;
                    const isActive = node.id === editingNodeId ? 'active' : '';
                    const nt = nodeTypes.find(t => t.id === node.type);
                    const emoji = nt ? nt.emoji : 'üìÑ';
                    html += `<div class="sidebar-tree-item ${isActive}" style="padding-left:${indent + 8}px;" onclick="switchToNode('${node.id}')">
                        ${emoji} ${node.title}
                    </div>`;
                    renderTreeNode(node.id, level + 1);
                });
            }
            renderTreeNode(null, 0);
            container.innerHTML = html || '<div style="color:#666; padding:10px; font-size:0.8em;">No items</div>';
        }

        function switchToNode(nodeId) {
            if (nodeId === editingNodeId) return;

            // Save current node first
            const currentNode = nodes.find(n => n.id === editingNodeId);
            if (currentNode) {
                currentNode.type = document.getElementById('editType').value;
                currentNode.title = document.getElementById('editTitle').value;
                currentNode.fullText = document.getElementById('fullTextEditor').innerHTML;
                currentNode.summary = document.getElementById('editSummary').value;
                currentNode.povId = parseInt(document.getElementById('editPov').value) || null;
                currentNode.target = parseInt(document.getElementById('editTarget').value) || 0;
                currentNode.notes = document.getElementById('editNotes').value;
                currentNode.descs = [...tempDescs];
            }

            // Switch to new node
            editingNodeId = nodeId;
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            document.getElementById('editorTitle').textContent = `‚úèÔ∏è ${node.title}`;
            document.getElementById('editType').value = node.type;
            document.getElementById('editTitle').value = node.title;

            // Normalize content to ensure proper paragraph structure
            let switchContent = node.fullText || '';
            if (switchContent && !switchContent.match(/<(p|div|h[1-6]|ul|ol|li|blockquote)/i)) {
                switchContent = switchContent
                    .split(/(<br\s*\/?>\s*){2,}/gi)
                    .map(para => para.trim())
                    .filter(para => para.length > 0 && para !== '<br>' && para !== '<br/>')
                    .map(para => `<p>${para}</p>`)
                    .join('');
            }
            document.getElementById('fullTextEditor').innerHTML = switchContent;

            document.getElementById('editSummary').value = node.summary || '';
            document.getElementById('editPov').value = node.povId || '';
            document.getElementById('editTarget').value = node.target || '';
            document.getElementById('editNotes').value = node.notes || '';

            tempDescs = [...(node.descs || [])];
            renderEditDescs();
            updateEditorStats();
            updateEditProgress();
            renderEditorTree();
            renderEditorAttachments();
        }

        function renderEditorAttachments() {
            const container = document.getElementById('editorAttachments');
            if (!container) return;

            const node = nodes.find(n => n.id === editingNodeId);

            // Update count
            const countEl = document.getElementById('attCount');
            if (countEl) {
                countEl.textContent = node && node.attachments ? node.attachments.length : 0;
            }

            if (!node || !node.attachments || node.attachments.length === 0) {
                container.innerHTML = `
                    <div class="no-attachments">
                        <div class="empty-icon">üìÇ</div>
                        <p>No attachments yet</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = node.attachments.map((att, index) => {
                const icon = getFileIcon(att.type);
                const size = formatFileSize(att.size);

                // Show thumbnail for images
                let thumbHtml = `<span class="attachment-icon">${icon}</span>`;
                if (att.type && att.type.startsWith('image/') && (att.preview || att.data)) {
                    thumbHtml = `<img class="attachment-thumb" src="${att.preview || att.data}" alt="${att.name}">`;
                }

                return `
                    <div class="attachment-item" onclick="previewAttachment(${index})">
                        ${thumbHtml}
                        <div class="attachment-info">
                            <div class="attachment-name">${att.name}</div>
                            <div class="attachment-size">${size}</div>
                        </div>
                        <div class="attachment-actions">
                            <button onclick="event.stopPropagation(); previewAttachment(${index})" title="Preview">üëÅÔ∏è</button>
                            <button onclick="event.stopPropagation(); downloadAttachment(${index})" title="Download">‚¨áÔ∏è</button>
                            <button class="delete-btn" onclick="event.stopPropagation(); deleteAttachment(${index})" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return 'üñºÔ∏è';
            if (mimeType.startsWith('video/')) return 'üé¨';
            if (mimeType.startsWith('audio/')) return 'üéµ';
            if (mimeType.includes('pdf')) return 'üìï';
            if (mimeType.includes('word') || mimeType.includes('document')) return 'üìò';
            if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return 'üìó';
            if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'üìô';
            if (mimeType.includes('zip') || mimeType.includes('rar') || mimeType.includes('archive')) return 'üì¶';
            if (mimeType.includes('text')) return 'üìÑ';
            return 'üìé';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ============ ATTACHMENT PREVIEW ============
        let currentPreviewAttachment = null;

        function previewAttachment(index) {
            const node = nodes.find(n => n.id === editingNodeId);
            if (!node || !node.attachments || !node.attachments[index]) return;

            const att = node.attachments[index];
            currentPreviewAttachment = att;

            document.getElementById('previewFileName').textContent = att.name;
            const body = document.getElementById('previewBody');

            // Get the source URL - either cloud path or base64 data
            const src = att.cloudPath || att.data;

            if (!src) {
                body.innerHTML = `<div style="color:#fff; text-align:center;">
                    <div style="font-size:4em;">‚ö†Ô∏è</div>
                    <p>${att.name}</p>
                    <p style="color:#888;">File source not available</p>
                </div>`;
                document.getElementById('filePreviewModal').style.display = 'flex';
                return;
            }

            if (att.type.startsWith('image/')) {
                body.innerHTML = `<img src="${src}" alt="${att.name}" style="max-width:100%; max-height:70vh; object-fit:contain; border-radius:8px;">`;
            } else if (att.type.startsWith('video/')) {
                body.innerHTML = `<video controls src="${src}" style="max-width:100%; max-height:70vh;"></video>`;
            } else if (att.type.startsWith('audio/')) {
                body.innerHTML = `<div style="text-align:center; padding:40px;">
                    <div style="font-size:5em; margin-bottom:20px;">üéµ</div>
                    <p style="color:#fff; margin-bottom:20px;">${att.name}</p>
                    <audio controls src="${src}" style="width:100%; max-width:400px;"></audio>
                </div>`;
            } else if (att.type.includes('pdf')) {
                body.innerHTML = `<iframe src="${src}" style="width:80vw; height:70vh; border:none; border-radius:8px; background:#fff;"></iframe>`;
            } else if (att.type.includes('text') && att.data) {
                // Decode base64 text (only for local files)
                try {
                    const base64 = att.data.split(',')[1];
                    const text = atob(base64);
                    body.innerHTML = `<pre style="color:#fff; white-space:pre-wrap; max-width:80vw; padding:20px; background:rgba(0,0,0,0.3); border-radius:8px;">${escapeHtml(text)}</pre>`;
                } catch(e) {
                    body.innerHTML = `<div style="color:#fff;">Cannot preview this file type</div>`;
                }
            } else {
                body.innerHTML = `<div style="color:#fff; text-align:center; padding:40px;">
                    <div style="font-size:5em; margin-bottom:20px;">${getFileIcon(att.type)}</div>
                    <p style="font-size:1.2em; margin-bottom:10px;">${att.name}</p>
                    <p style="color:#888; margin-bottom:20px;">${formatFileSize(att.size)}</p>
                    <p style="color:#666;">Preview not available for this file type</p>
                </div>`;
            }

            document.getElementById('filePreviewModal').style.display = 'flex';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function closeFilePreview() {
            document.getElementById('filePreviewModal').style.display = 'none';
            currentPreviewAttachment = null;
        }

        function downloadCurrentPreview() {
            if (!currentPreviewAttachment) return;
            downloadAttachment(nodes.find(n => n.id === editingNodeId).attachments.indexOf(currentPreviewAttachment));
        }

        function downloadAttachment(index) {
            const node = nodes.find(n => n.id === editingNodeId);
            if (!node || !node.attachments || !node.attachments[index]) return;

            const att = node.attachments[index];
            const link = document.createElement('a');
            link.href = att.data;
            link.download = att.name;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showToast(`‚¨áÔ∏è Downloading ${att.name}`);
        }

        function deleteAttachment(index) {
            const node = nodes.find(n => n.id === editingNodeId);
            if (!node || !node.attachments || !node.attachments[index]) return;

            const name = node.attachments[index].name;
            if (confirm(`Delete "${name}"?`)) {
                node.attachments.splice(index, 1);
                renderEditorAttachments();
                renderAll();
                autoSave(); // Save after deleting
                showToast(`üóëÔ∏è ${name} deleted`);
            }
        }

        function updateEditorStats() {
            const editor = document.getElementById('fullTextEditor');
            const text = editor ? editor.innerText || editor.textContent : '';
            document.getElementById('editorWordCount').textContent = countWords(text);
            document.getElementById('editorCharCount').textContent = text.trim().length;
            const paragraphs = text.split(/\n\n+/).filter(p => p.trim()).length;
            document.getElementById('editorParaCount').textContent = paragraphs || 1;
            updateEditProgress();
        }

        function updateEditProgress() {
            const editor = document.getElementById('fullTextEditor');
            const text = editor ? editor.innerText || editor.textContent : '';
            const target = parseInt(document.getElementById('editTarget').value) || 0;
            const current = countWords(text);

            if (target > 0) {
                const percent = Math.min(Math.round((current / target) * 100), 100);
                document.getElementById('editProgress').textContent = `${percent}% (${current}/${target})`;
                document.getElementById('editProgress').style.color = percent >= 100 ? '#4CAF50' : percent >= 50 ? '#FF9800' : '#e94560';
            } else {
                document.getElementById('editProgress').textContent = 'Set target';
                document.getElementById('editProgress').style.color = '#888';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const editor = document.getElementById('fullTextEditor');
            if (editor) {
                editor.addEventListener('input', updateEditorStats);
            }
            const targetInput = document.getElementById('editTarget');
            if (targetInput) {
                targetInput.addEventListener('input', updateEditProgress);
            }

            // Attachment upload button - direct file picker
            const addAttBtn = document.getElementById('addAttachmentBtn');
            const attFileInput = document.getElementById('attachmentFileInput');
            if (addAttBtn && attFileInput) {
                addAttBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!editingNodeId) {
                        showToast('‚ö†Ô∏è Please open a document first');
                        return;
                    }
                    attFileInput.click();
                });

                attFileInput.addEventListener('change', async function(e) {
                    const files = e.target.files;
                    if (!files || files.length === 0) return;

                    const node = nodes.find(n => n.id === editingNodeId);
                    if (!node) {
                        showToast('‚ùå No document selected');
                        e.target.value = '';
                        return;
                    }

                    if (!node.attachments) node.attachments = [];

                    for (const file of Array.from(files)) {
                        // Check file size (10MB limit)
                        if (file.size > 10 * 1024 * 1024) {
                            showToast(`‚ö†Ô∏è ${file.name} is too large (max 10MB)`);
                            continue;
                        }

                        showToast(`üì§ Uploading ${file.name}...`);

                        // OFFLINE MODE: Always use local storage (base64)
                        await uploadFileLocally(file, node);
                        showToast(`üíæ ${file.name} saved locally`);
                    }

                    renderEditorAttachments();
                    renderAll();
                    autoSave(); // Save after adding attachments
                    e.target.value = '';
                });
            }
        });

        // Helper function for local file upload
        function uploadFileLocally(file, node) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    node.attachments.push({
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        data: e.target.result
                    });
                    showToast(`üìé ${file.name} added`);
                    resolve();
                };
                reader.readAsDataURL(file);
            });
        }

        // ============ FORMAT TEXT (WYSIWYG) ============
        function formatText(type) {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            // Apply format based on type using document.execCommand
            switch(type) {
                case 'bold':
                    document.execCommand('bold', false, null);
                    currentTypingBold = !currentTypingBold;
                    break;
                case 'italic':
                    document.execCommand('italic', false, null);
                    currentTypingItalic = !currentTypingItalic;
                    break;
                case 'underline':
                    document.execCommand('underline', false, null);
                    currentTypingUnderline = !currentTypingUnderline;
                    break;
                case 'strikethrough':
                    document.execCommand('strikeThrough', false, null);
                    break;
                case 'highlight':
                    applyHighlight('#ffeb3b');
                    currentTypingHighlight = currentTypingHighlight === 'yellow' ? null : 'yellow';
                    break;
                case 'highlight-green':
                    applyHighlight('#a5d6a7');
                    currentTypingHighlight = currentTypingHighlight === 'green' ? null : 'green';
                    break;
                case 'highlight-blue':
                    applyHighlight('#90caf9');
                    currentTypingHighlight = currentTypingHighlight === 'blue' ? null : 'blue';
                    break;
                case 'bullet':
                    document.execCommand('insertUnorderedList', false, null);
                    break;
                case 'number':
                    document.execCommand('insertOrderedList', false, null);
                    break;
            }
            updateFormatButtonStates();
            editor.focus();
        }

        function applyHighlight(color) {
            const selection = window.getSelection();
            if (!selection || selection.isCollapsed) return;

            const editor = document.getElementById('fullTextEditor');
            if (!editor || !editor.contains(selection.anchorNode)) return;

            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.style.backgroundColor = color;
            span.style.padding = '2px 0';
            span.style.borderRadius = '2px';

            span.appendChild(range.extractContents());
            range.insertNode(span);

            // Re-select the highlighted text
            selection.removeAllRanges();
            const newRange = document.createRange();
            newRange.selectNodeContents(span);
            selection.addRange(newRange);
        }

        function updateFormatButtonStates() {
            // Update button visual states using IDs
            const btnBold = document.getElementById('btnBold');
            const btnItalic = document.getElementById('btnItalic');
            const btnUnderline = document.getElementById('btnUnderline');
            const btnYellow = document.getElementById('btnHighlightYellow');
            const btnGreen = document.getElementById('btnHighlightGreen');
            const btnBlue = document.getElementById('btnHighlightBlue');
            const btnBullet = document.getElementById('btnBullet');
            const btnNumber = document.getElementById('btnNumber');

            // Remove all active states first
            [btnBold, btnItalic, btnUnderline, btnYellow, btnGreen, btnBlue, btnBullet, btnNumber].forEach(btn => {
                if (btn) btn.classList.remove('format-active');
            });

            // Add active state to enabled modes
            if (currentTypingBold && btnBold) btnBold.classList.add('format-active');
            if (currentTypingItalic && btnItalic) btnItalic.classList.add('format-active');
            if (currentTypingUnderline && btnUnderline) btnUnderline.classList.add('format-active');
            if (currentTypingHighlight === 'yellow' && btnYellow) btnYellow.classList.add('format-active');
            if (currentTypingHighlight === 'green' && btnGreen) btnGreen.classList.add('format-active');
            if (currentTypingHighlight === 'blue' && btnBlue) btnBlue.classList.add('format-active');
            if (currentTypingBullet && btnBullet) btnBullet.classList.add('format-active');
            if (currentTypingNumber && btnNumber) btnNumber.classList.add('format-active');
        }

        function insertListPrefix(prefix) {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const textNode = document.createTextNode(prefix);
                range.deleteContents();
                range.insertNode(textNode);
                range.setStartAfter(textNode);
                range.setEndAfter(textNode);
                selection.removeAllRanges();
                selection.addRange(range);
                updateEditorStats();
            }
        }

        // ============ REVISION LABELS ============
        function renderRevisionLabels() {
            const container = document.getElementById('revisionLabels');
            if (!container) return;

            // First the "Normal" (no revision) button - works same as other revision buttons
            let html = `
                <span class="revision-label ${currentTypingRevision === null ? 'active' : ''}"
                      style="background:#f5f5f5; color:#333; ${currentTypingRevision === null ? 'box-shadow: 0 0 0 2px #333;' : ''}"
                      onmousedown="event.preventDefault()"
                      onclick="setActiveTypingRevision(null)"
                      title="Switch to normal writing mode (default color and size)">
                    ${currentTypingRevision === null ? '‚úèÔ∏è ' : ''}Normal
                </span>
            `;

            // Revizyon etiketleri - all buttons work the same way (just switch mode)
            html += revisionLabels.map(r => `
                <span class="revision-label ${currentTypingRevision === r.id ? 'active' : ''}"
                      style="background:${r.bg}; color:${r.text}; ${currentTypingRevision === r.id ? 'box-shadow: 0 0 0 2px ' + r.text + ';' : ''}"
                      onmousedown="event.preventDefault()"
                      onclick="setActiveTypingRevision(${r.id})"
                      title="Click: switch to this writing mode">
                    ${currentTypingRevision === r.id ? '‚úèÔ∏è ' : ''}${r.name}
                    <button class="remove-label" onclick="event.stopPropagation(); removeRevisionLabel(${r.id})">√ó</button>
                </span>
            `).join('');

            container.innerHTML = html;
        }

        function applyRevisionColor(revId) {
            const rev = revisionLabels.find(r => r.id === revId);
            if (!rev) return;

            activeRevisionId = revId;
            renderRevisionLabels();

            // Apply to selected text if any using Quill
            if (quillEditor) {
                const range = quillEditor.getSelection();
                if (range && range.length > 0) {
                    quillEditor.format('color', rev.text);
                    showToast(`"${rev.name}" applied to selected text`);
                }
            }
        }

        function showAddRevisionForm() {
            document.getElementById('revisionForm').style.display = 'flex';
            document.getElementById('newRevisionName').focus();
        }

        function hideRevisionForm() {
            document.getElementById('revisionForm').style.display = 'none';
            document.getElementById('newRevisionName').value = '';
        }

        function addRevisionLabel() {
            const name = document.getElementById('newRevisionName').value.trim();
            const bg = document.getElementById('newRevisionBg').value;
            const text = document.getElementById('newRevisionText').value;

            if (!name) {
                showToast('Name required');
                return;
            }

            revisionLabels.push({ id: revisionIdCounter++, name, bg, text });
            renderRevisionLabels();
            hideRevisionForm();
            showToast(`"${name}" added`);
        }

        function removeRevisionLabel(id) {
            if (!confirm('Delete this revision?')) return;
            revisionLabels = revisionLabels.filter(r => r.id !== id);
            if (activeRevisionId === id) activeRevisionId = null;
            renderRevisionLabels();
        }

        function clearTextFormatting() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            const sel = window.getSelection();

            // Se√ßili metin varsa sadece onu temizle
            if (sel && !sel.isCollapsed && sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                const selectedText = sel.toString();

                // Se√ßili i√ßeriƒüi d√ºz metin olarak deƒüi≈ütir
                range.deleteContents();
                const textNode = document.createTextNode(selectedText);
                range.insertNode(textNode);

                // ƒ∞mleci sonuna ta≈üƒ±
                range.setStartAfter(textNode);
                range.setEndAfter(textNode);
                sel.removeAllRanges();
                sel.addRange(range);

                showToast('‚ú® Se√ßili metnin formatƒ± temizlendi');
            } else {
                // Se√ßim yoksa gelecek yazƒ±lar i√ßin temizle
                pendingStyles.fontSize = null;
                pendingStyles.color = null;
                pendingStyles.fontFamily = null;
                showToast('‚ú® Yeni metin i√ßin format sƒ±fƒ±rlandƒ±');
            }

            // Revision modunu da sƒ±fƒ±rla
            activeRevisionId = null;
            currentTypingRevision = null;
            renderRevisionLabels();

            editor.focus();
        }

        // Sadece highlight/marker'ƒ± temizle (arka plan rengi)
        function clearHighlight() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            const sel = window.getSelection();

            // Se√ßili metin varsa sadece onun highlight'ƒ±nƒ± temizle
            if (sel && !sel.isCollapsed && sel.rangeCount > 0) {
                // execCommand ile arka plan rengini kaldƒ±r
                document.execCommand('hiliteColor', false, 'transparent');
                document.execCommand('backColor', false, 'transparent');

                // Ayrƒ±ca span'lardaki background-color'ƒ± da temizle
                const range = sel.getRangeAt(0);
                const container = range.commonAncestorContainer;
                const parent = container.nodeType === Node.TEXT_NODE ? container.parentNode : container;

                // Se√ßili alandaki t√ºm elementleri bul
                if (parent && parent !== editor) {
                    const walker = document.createTreeWalker(
                        range.commonAncestorContainer.nodeType === Node.TEXT_NODE
                            ? range.commonAncestorContainer.parentNode
                            : range.commonAncestorContainer,
                        NodeFilter.SHOW_ELEMENT,
                        null,
                        false
                    );

                    let node;
                    while (node = walker.nextNode()) {
                        if (node.style && node.style.backgroundColor) {
                            node.style.backgroundColor = '';
                        }
                    }
                }

                showToast('üö´ Highlight kaldƒ±rƒ±ldƒ±');
            } else {
                // Se√ßim yoksa - typing highlight modunu kapat
                currentTypingHighlight = null;
                showToast('üö´ Highlight modu kapatƒ±ldƒ±');
            }

            editor.focus();
        }

        // ============ LIST, TABLE, IMAGE FUNCTIONS ============
        function insertBulletList() {
            if (quillEditor) {
                const range = quillEditor.getSelection();
                if (range) {
                    const format = quillEditor.getFormat(range);
                    quillEditor.format('list', format.list === 'bullet' ? false : 'bullet');
                }
                quillEditor.focus();
            }
            showToast('‚Ä¢ Bullet list added');
        }

        function insertNumberList() {
            if (quillEditor) {
                const range = quillEditor.getSelection();
                if (range) {
                    const format = quillEditor.getFormat(range);
                    quillEditor.format('list', format.list === 'ordered' ? false : 'ordered');
                }
                quillEditor.focus();
            }
            showToast('1. Numbered list added');
        }

        function insertImage() {
            document.getElementById('editorImageInput').click();
        }

        function handleEditorImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showToast('Please select an image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const editor = document.getElementById('fullTextEditor');
                if (editor) {
                    // SAVE STATE BEFORE IMAGE INSERT FOR UNDO
                    saveEditorState();

                    // Restore selection or insert at end
                    restoreSelection();
                    const selection = window.getSelection();

                    // Image wrapper - sadece img elementi, wrapper yok
                    const img = document.createElement('img');
                    img.src = e.target.result;
                    img.className = 'editor-image';
                    img.style.maxWidth = '50%';
                    img.style.height = 'auto';
                    img.style.cursor = 'pointer';
                    img.style.display = 'inline';
                    img.style.verticalAlign = 'middle';
                    img.setAttribute('contenteditable', 'false');

                    // Resme tƒ±klayƒ±nca boyut toolbar'ƒ± g√∂ster
                    img.addEventListener('click', function(e) {
                        e.stopPropagation();
                        showImageToolbar(img, img);
                    });

                    if (selection.rangeCount > 0 && editor.contains(selection.anchorNode)) {
                        const range = selection.getRangeAt(0);
                        range.deleteContents();
                        range.insertNode(img);
                        // Move cursor after image
                        range.setStartAfter(img);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    } else {
                        editor.appendChild(img);
                    }

                    editor.focus();
                }
                showToast('üñºÔ∏è Image inserted - click to resize');
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        // Image Toolbar - boyut deƒüi≈ütirme
        function showImageToolbar(img, wrapper) {
            // Eski toolbar varsa kaldƒ±r
            const oldToolbar = document.querySelector('.image-toolbar');
            if (oldToolbar) oldToolbar.remove();

            // T√ºm resimlerin se√ßimini kaldƒ±r
            document.querySelectorAll('.editor-image.selected').forEach(w => w.classList.remove('selected'));
            img.classList.add('selected');

            // Image pozisyonunu al
            const rect = img.getBoundingClientRect();

            const toolbar = document.createElement('div');
            toolbar.className = 'image-toolbar';
            toolbar.style.position = 'fixed';
            toolbar.style.top = (rect.top - 45) + 'px';
            toolbar.style.left = rect.left + 'px';
            toolbar.style.zIndex = '10000';
            // En-boy oranƒ±nƒ± hesapla
            const aspectRatio = img.naturalWidth / img.naturalHeight;
            window.currentImageAspectRatio = aspectRatio;
            window.aspectRatioLocked = true;

            toolbar.innerHTML = `
                <div class="img-size-group">
                    <button onclick="resizeImage('25%')" title="25%">S</button>
                    <button onclick="resizeImage('50%')" title="50%">M</button>
                    <button onclick="resizeImage('75%')" title="75%">L</button>
                    <button onclick="resizeImage('100%')" title="100%">XL</button>
                </div>
                <span class="toolbar-sep"></span>
                <div class="img-custom-size">
                    <input type="number" id="imgWidthInput" placeholder="W" value="${parseInt(img.width) || ''}" min="50" max="2000" title="Geni≈ülik (px)" onchange="onImageWidthChange()">
                    <span>√ó</span>
                    <input type="number" id="imgHeightInput" placeholder="H" value="${parseInt(img.height) || ''}" min="50" max="2000" title="Y√ºkseklik (px)" onchange="onImageHeightChange()">
                    <button id="lockAspectBtn" onclick="toggleAspectLock()" title="En-boy oranƒ±nƒ± kilitle/a√ß" style="font-size:14px;">üîó</button>
                    <button onclick="applyCustomImageSize()" title="Uygula">‚úì</button>
                </div>
                <span class="toolbar-sep"></span>
                <div class="img-align-group">
                    <button onclick="alignImage('left')" title="Sol">‚¨Ö</button>
                    <button onclick="alignImage('center')" title="Orta">‚¨å</button>
                    <button onclick="alignImage('right')" title="Saƒü">‚û°</button>
                </div>
                <span class="toolbar-sep"></span>
                <button onclick="deleteImage()" title="Sil" class="danger">üóëÔ∏è</button>
            `;

            document.body.appendChild(toolbar);
            window.currentEditingImage = img;

            // Dƒ±≈üarƒ± tƒ±klayƒ±nca toolbar'ƒ± kapat
            setTimeout(() => {
                document.addEventListener('click', closeImageToolbar);
            }, 100);
        }

        function closeImageToolbar(e) {
            if (e && e.target.closest('.image-toolbar')) return;
            if (e && e.target.closest('.editor-image')) return;

            const toolbar = document.querySelector('.image-toolbar');
            if (toolbar) toolbar.remove();

            document.querySelectorAll('.editor-image.selected').forEach(w => w.classList.remove('selected'));
            document.removeEventListener('click', closeImageToolbar);
        }

        function resizeImage(size) {
            if (window.currentEditingImage) {
                window.currentEditingImage.style.width = size;
                window.currentEditingImage.style.maxWidth = size;
                window.currentEditingImage.style.height = 'auto';
                showToast(`üìê Image: ${size}`);
            }
        }

        function applyCustomImageSize() {
            const width = document.getElementById('imgWidthInput').value;
            const height = document.getElementById('imgHeightInput').value;

            if (window.currentEditingImage) {
                if (width) {
                    window.currentEditingImage.style.width = width + 'px';
                    window.currentEditingImage.style.maxWidth = width + 'px';
                }
                if (height) {
                    window.currentEditingImage.style.height = height + 'px';
                } else {
                    window.currentEditingImage.style.height = 'auto';
                }
                showToast(`üìê Image: ${width || 'auto'}√ó${height || 'auto'}px`);
            }
        }

        function toggleAspectLock() {
            window.aspectRatioLocked = !window.aspectRatioLocked;
            const btn = document.getElementById('lockAspectBtn');
            if (btn) {
                btn.textContent = window.aspectRatioLocked ? 'üîó' : 'üîì';
                btn.title = window.aspectRatioLocked ? 'En-boy oranƒ± kilitli (tƒ±kla: a√ß)' : 'En-boy oranƒ± serbest (tƒ±kla: kilitle)';
            }
            showToast(window.aspectRatioLocked ? 'üîó Oran kilitli' : 'üîì Oran serbest');
        }

        function onImageWidthChange() {
            if (!window.aspectRatioLocked || !window.currentImageAspectRatio) return;
            const widthInput = document.getElementById('imgWidthInput');
            const heightInput = document.getElementById('imgHeightInput');
            if (widthInput && heightInput && widthInput.value) {
                const newHeight = Math.round(parseInt(widthInput.value) / window.currentImageAspectRatio);
                heightInput.value = newHeight;
            }
        }

        function onImageHeightChange() {
            if (!window.aspectRatioLocked || !window.currentImageAspectRatio) return;
            const widthInput = document.getElementById('imgWidthInput');
            const heightInput = document.getElementById('imgHeightInput');
            if (widthInput && heightInput && heightInput.value) {
                const newWidth = Math.round(parseInt(heightInput.value) * window.currentImageAspectRatio);
                widthInput.value = newWidth;
            }
        }

        function alignImage(align) {
            if (window.currentEditingImage) {
                // √ñnce t√ºm stilleri temizle
                window.currentEditingImage.style.float = 'none';
                window.currentEditingImage.style.marginLeft = '0';
                window.currentEditingImage.style.marginRight = '0';

                if (align === 'center') {
                    window.currentEditingImage.style.display = 'block';
                    window.currentEditingImage.style.marginLeft = 'auto';
                    window.currentEditingImage.style.marginRight = 'auto';
                } else if (align === 'left') {
                    window.currentEditingImage.style.display = 'inline';
                    window.currentEditingImage.style.float = 'left';
                    window.currentEditingImage.style.marginRight = '10px';
                } else if (align === 'right') {
                    window.currentEditingImage.style.display = 'inline';
                    window.currentEditingImage.style.float = 'right';
                    window.currentEditingImage.style.marginLeft = '10px';
                }
                showToast(`üìê Align: ${align}`);
            }
        }

        function deleteImage() {
            if (window.currentEditingImage) {
                // SAVE STATE BEFORE DELETE FOR UNDO
                saveEditorState();

                window.currentEditingImage.remove();
                showToast('üóëÔ∏è Image deleted');
                closeImageToolbar();

                // Update lastEditorContent after delete
                const editor = document.getElementById('fullTextEditor');
                if (editor) lastEditorContent = editor.innerHTML;
            }
        }

        function insertTable() {
            const rows = prompt('Number of rows:', '3');
            const cols = prompt('Number of columns:', '3');

            if (!rows || !cols) return;

            const numRows = parseInt(rows) || 3;
            const numCols = parseInt(cols) || 3;

            let tableHTML = '<table style="border-collapse: collapse; width: 100%; margin: 10px 0;">';

            // Header row
            tableHTML += '<tr>';
            for (let c = 0; c < numCols; c++) {
                tableHTML += `<th style="border: 1px solid #555; padding: 8px; background: #2d2d2d;">Header ${c + 1}</th>`;
            }
            tableHTML += '</tr>';

            // Data rows
            for (let r = 0; r < numRows - 1; r++) {
                tableHTML += '<tr>';
                for (let c = 0; c < numCols; c++) {
                    tableHTML += '<td style="border: 1px solid #555; padding: 8px;">&nbsp;</td>';
                }
                tableHTML += '</tr>';
            }

            tableHTML += '</table><p><br></p>';

            const editor = document.getElementById('fullTextEditor');
            if (editor) {
                restoreSelection();
                const selection = window.getSelection();

                const tableContainer = document.createElement('div');
                tableContainer.innerHTML = tableHTML;

                if (selection.rangeCount > 0 && editor.contains(selection.anchorNode)) {
                    const range = selection.getRangeAt(0);
                    range.deleteContents();
                    range.insertNode(tableContainer.firstChild);
                } else {
                    editor.appendChild(tableContainer.firstChild);
                }
                editor.focus();
            }
            showToast(`‚äû Table ${numRows}x${numCols} inserted`);
        }

        // ============ RULER FUNCTIONALITY - MS Word Style ============
        let rulerDragging = null;
        let rulerStartX = 0;
        let rulerStartPos = 0;

        function initRuler() {
            const rulerNumbers = document.getElementById('rulerNumbers');
            if (!rulerNumbers) return;

            // Generate ruler markings (cm style like MS Word)
            rulerNumbers.innerHTML = '';
            for (let i = 0; i <= 20; i++) {
                const cm = document.createElement('div');
                cm.className = 'ruler-cm';
                cm.setAttribute('data-num', i);
                cm.innerHTML = '<div class="tick-half"></div><div class="tick-quarter" style="left:25%"></div><div class="tick-quarter" style="left:75%"></div>';
                rulerNumbers.appendChild(cm);
            }

            const indentLeft = document.getElementById('rulerIndentLeft');
            const indentHanging = document.getElementById('rulerIndentHanging');
            const indentRight = document.getElementById('rulerIndentRight');

            // First line indent (top triangle)
            if (indentLeft) {
                indentLeft.addEventListener('mousedown', (e) => {
                    rulerDragging = 'firstLine';
                    rulerStartX = e.clientX;
                    rulerStartPos = indentLeft.offsetLeft;
                    e.preventDefault();
                });
            }

            // Left margin (bottom triangle)
            if (indentHanging) {
                indentHanging.addEventListener('mousedown', (e) => {
                    rulerDragging = 'leftMargin';
                    rulerStartX = e.clientX;
                    rulerStartPos = indentHanging.offsetLeft;
                    e.preventDefault();
                });
            }

            // Right margin
            if (indentRight) {
                indentRight.addEventListener('mousedown', (e) => {
                    rulerDragging = 'rightMargin';
                    rulerStartX = e.clientX;
                    rulerStartPos = parseFloat(indentRight.style.right) || 0;
                    e.preventDefault();
                });
            }

            document.addEventListener('mousemove', (e) => {
                if (!rulerDragging) return;

                const delta = e.clientX - rulerStartX;
                const editor = document.getElementById('fullTextEditor');

                if (rulerDragging === 'firstLine') {
                    const newPos = Math.max(0, rulerStartPos + delta);
                    indentLeft.style.left = newPos + 'px';
                    editor.style.textIndent = newPos + 'px';
                } else if (rulerDragging === 'leftMargin') {
                    const newPos = Math.max(0, rulerStartPos + delta);
                    indentHanging.style.left = newPos + 'px';
                    indentLeft.style.left = newPos + 'px';
                    editor.style.paddingLeft = (20 + newPos) + 'px';
                } else if (rulerDragging === 'rightMargin') {
                    const newPos = Math.max(0, rulerStartPos - delta);
                    indentRight.style.right = newPos + 'px';
                    editor.style.paddingRight = (20 + newPos) + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                rulerDragging = null;
            });
        }

        // Initialize ruler when editor opens
        document.addEventListener('DOMContentLoaded', initRuler);

        // ============ RESIZABLE IMAGE ============
        let resizingImage = null;
        let resizeHandle = null;
        let resizeStartX = 0;
        let resizeStartY = 0;
        let resizeStartWidth = 0;
        let resizeStartHeight = 0;

        function makeImageResizable(img) {
            // Remove any existing wrapper
            if (img.parentElement.classList.contains('image-resize-wrapper')) {
                return;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'image-resize-wrapper';
            wrapper.contentEditable = 'false';

            img.parentNode.insertBefore(wrapper, img);
            wrapper.appendChild(img);

            // Add resize handles
            const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'e', 'w'];
            handles.forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `image-resize-handle ${pos}`;
                handle.addEventListener('mousedown', (e) => startImageResize(e, img, pos));
                wrapper.appendChild(handle);
            });

            // Add size tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'image-size-tooltip';
            tooltip.textContent = `${img.naturalWidth} √ó ${img.naturalHeight}`;
            wrapper.appendChild(tooltip);

            // Click to select
            wrapper.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.image-resize-wrapper').forEach(w => w.classList.remove('selected'));
                wrapper.classList.add('selected');
            });
        }

        function startImageResize(e, img, handlePos) {
            e.preventDefault();
            e.stopPropagation();

            resizingImage = img;
            resizeHandle = handlePos;
            resizeStartX = e.clientX;
            resizeStartY = e.clientY;
            resizeStartWidth = img.offsetWidth;
            resizeStartHeight = img.offsetHeight;

            document.addEventListener('mousemove', doImageResize);
            document.addEventListener('mouseup', stopImageResize);
        }

        function doImageResize(e) {
            if (!resizingImage) return;

            const deltaX = e.clientX - resizeStartX;
            const deltaY = e.clientY - resizeStartY;
            const aspectRatio = resizeStartWidth / resizeStartHeight;

            let newWidth = resizeStartWidth;
            let newHeight = resizeStartHeight;

            // Corner handles maintain aspect ratio
            if (resizeHandle === 'se') {
                newWidth = Math.max(50, resizeStartWidth + deltaX);
                newHeight = newWidth / aspectRatio;
            } else if (resizeHandle === 'sw') {
                newWidth = Math.max(50, resizeStartWidth - deltaX);
                newHeight = newWidth / aspectRatio;
            } else if (resizeHandle === 'ne') {
                newWidth = Math.max(50, resizeStartWidth + deltaX);
                newHeight = newWidth / aspectRatio;
            } else if (resizeHandle === 'nw') {
                newWidth = Math.max(50, resizeStartWidth - deltaX);
                newHeight = newWidth / aspectRatio;
            } else if (resizeHandle === 'e') {
                newWidth = Math.max(50, resizeStartWidth + deltaX);
            } else if (resizeHandle === 'w') {
                newWidth = Math.max(50, resizeStartWidth - deltaX);
            } else if (resizeHandle === 's') {
                newHeight = Math.max(50, resizeStartHeight + deltaY);
            } else if (resizeHandle === 'n') {
                newHeight = Math.max(50, resizeStartHeight - deltaY);
            }

            resizingImage.style.width = newWidth + 'px';
            resizingImage.style.height = newHeight + 'px';

            // Update tooltip
            const tooltip = resizingImage.parentElement.querySelector('.image-size-tooltip');
            if (tooltip) {
                tooltip.textContent = `${Math.round(newWidth)} √ó ${Math.round(newHeight)}`;
            }
        }

        function stopImageResize() {
            resizingImage = null;
            resizeHandle = null;
            document.removeEventListener('mousemove', doImageResize);
            document.removeEventListener('mouseup', stopImageResize);
        }

        // ============ TABLE EDITING ============
        let currentTableCell = null;

        function initTableEditing() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            // Right-click on table cells
            editor.addEventListener('contextmenu', (e) => {
                const cell = e.target.closest('td, th');
                if (cell) {
                    e.preventDefault();
                    currentTableCell = cell;
                    showTableContextMenu(e.clientX, e.clientY);
                }
            });
        }

        function showTableContextMenu(x, y) {
            // Remove existing menu
            const existing = document.getElementById('tableContextMenu');
            if (existing) existing.remove();

            const menu = document.createElement('div');
            menu.id = 'tableContextMenu';
            menu.className = 'table-context-menu';
            menu.innerHTML = `
                <div class="table-context-menu-item" onclick="tableAddRowAbove()">‚ûï Add Row Above</div>
                <div class="table-context-menu-item" onclick="tableAddRowBelow()">‚ûï Add Row Below</div>
                <div class="table-context-menu-divider"></div>
                <div class="table-context-menu-item" onclick="tableAddColLeft()">‚ûï Add Column Left</div>
                <div class="table-context-menu-item" onclick="tableAddColRight()">‚ûï Add Column Right</div>
                <div class="table-context-menu-divider"></div>
                <div class="table-context-menu-item" onclick="tableDeleteRow()">üóëÔ∏è Delete Row</div>
                <div class="table-context-menu-item" onclick="tableDeleteCol()">üóëÔ∏è Delete Column</div>
                <div class="table-context-menu-divider"></div>
                <div class="table-context-menu-item" onclick="tableDeleteTable()">üóëÔ∏è Delete Table</div>
            `;
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            document.body.appendChild(menu);

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', closeTableContextMenu);
            }, 10);
        }

        function closeTableContextMenu() {
            const menu = document.getElementById('tableContextMenu');
            if (menu) menu.remove();
            document.removeEventListener('click', closeTableContextMenu);
        }

        function tableAddRowAbove() {
            if (!currentTableCell) return;
            const row = currentTableCell.parentElement;
            const newRow = row.cloneNode(true);
            Array.from(newRow.cells).forEach(cell => cell.textContent = '');
            row.parentElement.insertBefore(newRow, row);
            closeTableContextMenu();
            showToast('Row added above');
        }

        function tableAddRowBelow() {
            if (!currentTableCell) return;
            const row = currentTableCell.parentElement;
            const newRow = row.cloneNode(true);
            Array.from(newRow.cells).forEach(cell => cell.textContent = '');
            row.parentElement.insertBefore(newRow, row.nextSibling);
            closeTableContextMenu();
            showToast('Row added below');
        }

        function tableAddColLeft() {
            if (!currentTableCell) return;
            const table = currentTableCell.closest('table');
            const colIndex = currentTableCell.cellIndex;
            Array.from(table.rows).forEach(row => {
                const cell = row.cells[colIndex].cloneNode(true);
                cell.textContent = '';
                row.insertBefore(cell, row.cells[colIndex]);
            });
            closeTableContextMenu();
            showToast('Column added left');
        }

        function tableAddColRight() {
            if (!currentTableCell) return;
            const table = currentTableCell.closest('table');
            const colIndex = currentTableCell.cellIndex;
            Array.from(table.rows).forEach(row => {
                const cell = row.cells[colIndex].cloneNode(true);
                cell.textContent = '';
                row.insertBefore(cell, row.cells[colIndex + 1]);
            });
            closeTableContextMenu();
            showToast('Column added right');
        }

        function tableDeleteRow() {
            if (!currentTableCell) return;
            const row = currentTableCell.parentElement;
            const table = row.closest('table');
            if (table.rows.length > 1) {
                row.remove();
                showToast('Row deleted');
            } else {
                showToast('Cannot delete the only row');
            }
            closeTableContextMenu();
        }

        function tableDeleteCol() {
            if (!currentTableCell) return;
            const table = currentTableCell.closest('table');
            const colIndex = currentTableCell.cellIndex;
            if (table.rows[0].cells.length > 1) {
                Array.from(table.rows).forEach(row => {
                    if (row.cells[colIndex]) row.cells[colIndex].remove();
                });
                showToast('Column deleted');
            } else {
                showToast('Cannot delete the only column');
            }
            closeTableContextMenu();
        }

        function tableDeleteTable() {
            if (!currentTableCell) return;
            const table = currentTableCell.closest('table');
            table.remove();
            closeTableContextMenu();
            showToast('Table deleted');
        }

        // Initialize table editing
        document.addEventListener('DOMContentLoaded', initTableEditing);

        // ============ FIND & REPLACE ============
        let findMatches = [];
        let currentMatchIndex = -1;

        function toggleFindReplace() {
            const bar = document.getElementById('findReplaceBar');
            bar.classList.toggle('active');
            if (bar.classList.contains('active')) {
                document.getElementById('findInput').focus();
            } else {
                // Clear highlights when closing
                clearFindHighlights();
                document.getElementById('findInput').value = '';
                document.getElementById('replaceInput').value = '';
                document.getElementById('findCount').textContent = '';
            }
        }

        function findText() {
            const editor = document.getElementById('fullTextEditor');
            const searchTerm = document.getElementById('findInput').value;

            // Get search options
            const matchCase = document.getElementById('findMatchCase').checked;
            const wholeWord = document.getElementById('findWholeWord').checked;
            const useRegex = document.getElementById('findRegex').checked;

            // Clear previous highlights
            clearFindHighlights();
            closeFindResults();

            if (!searchTerm) {
                document.getElementById('findCount').textContent = '';
                return;
            }

            const text = editor.innerText || editor.textContent;
            findMatches = [];

            try {
                // Create regex pattern
                let pattern;
                if (useRegex) {
                    pattern = searchTerm;
                } else {
                    // Escape special characters
                    pattern = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                }

                // Whole word option
                if (wholeWord) {
                    pattern = `\\b${pattern}\\b`;
                }

                // Regex flags
                const flags = matchCase ? 'g' : 'gi';
                const regex = new RegExp(pattern, flags);

                let match;
                while ((match = regex.exec(text)) !== null) {
                    findMatches.push({
                        index: match.index,
                        length: match[0].length,
                        text: match[0]
                    });
                    // Prevent infinite loop
                    if (match.index === regex.lastIndex) {
                        regex.lastIndex++;
                    }
                }
            } catch (e) {
                // Invalid regex
                document.getElementById('findCount').textContent = 'Error!';
                return;
            }

            if (findMatches.length > 0) {
                currentMatchIndex = 0;
                highlightAllMatchesAdvanced(searchTerm, matchCase, wholeWord, useRegex);
                scrollToMatch(0);
                updateFindCount();
                showFindResults(searchTerm, text);
            } else {
                document.getElementById('findCount').textContent = '0 results';
            }
        }

        function updateFindCount() {
            const total = findMatches.length;
            const current = currentMatchIndex + 1;
            document.getElementById('findCount').textContent = `${current}/${total}`;
        }

        function findNext() {
            if (findMatches.length === 0) return;
            currentMatchIndex = (currentMatchIndex + 1) % findMatches.length;
            scrollToMatch(currentMatchIndex);
            updateFindCount();
            updateResultsList();
        }

        function findPrevious() {
            if (findMatches.length === 0) return;
            currentMatchIndex = (currentMatchIndex - 1 + findMatches.length) % findMatches.length;
            scrollToMatch(currentMatchIndex);
            updateFindCount();
            updateResultsList();
        }

        function showFindResults(searchTerm, fullText) {
            const panel = document.getElementById('findResultsPanel');
            const list = document.getElementById('findResultsList');
            const matchCase = document.getElementById('findMatchCase').checked;

            if (findMatches.length === 0) {
                panel.classList.remove('active');
                return;
            }

            let html = '';
            findMatches.forEach((match, index) => {
                // match is now in {index, length, text} format
                const pos = match.index;
                const matchLength = match.length;
                const matchText = match.text;

                // Get surrounding text (context)
                const start = Math.max(0, pos - 30);
                const end = Math.min(fullText.length, pos + matchLength + 30);
                let context = fullText.substring(start, end);

                // Add ... if truncated at start or end
                if (start > 0) context = '...' + context;
                if (end < fullText.length) context = context + '...';

                // Highlight found words - matchText'i kullan
                const escapedMatch = matchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const flags = matchCase ? 'g' : 'gi';
                const regex = new RegExp(`(${escapedMatch})`, flags);
                context = context.replace(regex, '<mark>$1</mark>');

                const isCurrent = index === currentMatchIndex ? 'current' : '';
                html += `<div class="find-result-item ${isCurrent}" onclick="goToResult(${index})">
                    <span class="result-num">${index + 1}</span>
                    <span class="result-context">${context}</span>
                </div>`;
            });

            list.innerHTML = html;
            panel.classList.add('active');
        }

        function updateResultsList() {
            const items = document.querySelectorAll('.find-result-item');
            items.forEach((item, index) => {
                if (index === currentMatchIndex) {
                    item.classList.add('current');
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else {
                    item.classList.remove('current');
                }
            });
        }

        function goToResult(index) {
            currentMatchIndex = index;
            scrollToMatch(index);
            updateFindCount();
            updateResultsList();
        }

        function closeFindResults() {
            document.getElementById('findResultsPanel').classList.remove('active');
        }

        function clearFindHighlights() {
            const editor = document.getElementById('fullTextEditor');
            const highlights = editor.querySelectorAll('.find-highlight');
            highlights.forEach(h => {
                const text = h.textContent;
                h.replaceWith(document.createTextNode(text));
            });
        }

        function highlightAllMatches(searchTerm) {
            highlightAllMatchesAdvanced(searchTerm, false, false, false);
        }

        function highlightAllMatchesAdvanced(searchTerm, matchCase, wholeWord, useRegex) {
            const editor = document.getElementById('fullTextEditor');

            // Find text nodes with TreeWalker
            const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }

            // Create pattern
            let innerPattern;
            if (useRegex) {
                innerPattern = searchTerm;
            } else {
                innerPattern = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            let pattern;
            if (wholeWord) {
                pattern = `(\\b${innerPattern}\\b)`;
            } else {
                pattern = `(${innerPattern})`;
            }

            const flags = matchCase ? 'g' : 'gi';

            try {
                const regex = new RegExp(pattern, flags);

                textNodes.forEach(textNode => {
                    const text = textNode.nodeValue;
                    if (regex.test(text)) {
                        regex.lastIndex = 0;
                        const fragment = document.createDocumentFragment();
                        let lastIndex = 0;
                        let match;

                        while ((match = regex.exec(text)) !== null) {
                            if (match.index > lastIndex) {
                                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                            }
                            const span = document.createElement('span');
                            span.className = 'find-highlight';
                            span.style.background = '#ffeb3b';
                            span.style.color = '#333';
                            span.style.padding = '0 2px';
                            span.style.borderRadius = '2px';
                            span.textContent = match[0];
                            fragment.appendChild(span);
                            lastIndex = regex.lastIndex;
                        }

                        if (lastIndex < text.length) {
                            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                        }

                        textNode.parentNode.replaceChild(fragment, textNode);
                    }
                });
            } catch(e) {
                console.error('Regex error:', e);
            }
        }

        function scrollToMatch(index) {
            const editor = document.getElementById('fullTextEditor');
            const highlights = editor.querySelectorAll('.find-highlight');

            highlights.forEach(h => {
                h.style.background = '#ffeb3b';
                h.style.color = 'inherit';
            });

            if (highlights[index]) {
                highlights[index].style.background = '#e94560';
                highlights[index].style.color = 'white';
                highlights[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function highlightMatch() {
            scrollToMatch(currentMatchIndex);
        }

        function replaceText() {
            const editor = document.getElementById('fullTextEditor');
            const highlights = editor.querySelectorAll('.find-highlight');

            if (highlights.length === 0 || currentMatchIndex < 0) return;

            const searchTerm = document.getElementById('findInput').value;
            const replaceTerm = document.getElementById('replaceInput').value;

            if (highlights[currentMatchIndex]) {
                highlights[currentMatchIndex].replaceWith(document.createTextNode(replaceTerm));
                showToast('Replaceildi');
                updateEditorStats();
                findText();
            }
        }

        function replaceAllText() {
            const editor = document.getElementById('fullTextEditor');
            const searchTerm = document.getElementById('findInput').value;
            const replaceTerm = document.getElementById('replaceInput').value;

            if (!searchTerm) return;

            // First find all highlights
            const highlights = editor.querySelectorAll('.find-highlight');
            const count = highlights.length;

            if (count === 0) {
                showToast('No matches found');
                return;
            }

            // Replace all
            highlights.forEach(h => {
                h.replaceWith(document.createTextNode(replaceTerm));
            });

            updateEditorStats();
            findText();
            showToast(`${count} changes made`);
        }

        // Keyboard shortcuts in editor
        document.addEventListener('keydown', function(e) {
            if (!document.getElementById('editorModal').classList.contains('active')) return;

            // F3 = Next, Shift+F3 = Previous
            if (e.key === 'F3') {
                e.preventDefault();
                if (e.shiftKey) {
                    findPrevious();
                } else {
                    findNext();
                }
                return;
            }

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'b') { e.preventDefault(); formatText('bold'); }
                else if (e.key === 'i') { e.preventDefault(); formatText('italic'); }
                else if (e.key === 'u') { e.preventDefault(); formatText('underline'); }
                else if (e.key === 'h') { e.preventDefault(); toggleFindReplace(); }
                else if (e.key === 'f') { e.preventDefault(); toggleFindReplace(); document.getElementById('findInput').focus(); }
                else if (e.key === 'g') { e.preventDefault(); findNext(); } // Ctrl+G = Next
            }
        });

        // ============ STATS ============
        function countWords(text) {
            if (!text) return 0;
            // HTML tag'lerini temizle
            const cleanText = text.replace(/<[^>]*>/g, ' ').replace(/&nbsp;/g, ' ');
            return cleanText.trim().split(/\s+/).filter(w => w.length > 0).length;
        }

        function updateAllStats() {
            let totalWords = 0;
            let sectionCount = 0;
            let groupCount = 0;

            nodes.forEach(n => {
                totalWords += countWords(n.fullText);
                if (n.type === 'section' || n.type === 'introduction' || n.type === 'draft' || n.type === 'conclusion') sectionCount++;
                if (n.type === 'group') groupCount++;
            });

            document.getElementById('totalWords').textContent = totalWords.toLocaleString();
            document.getElementById('chapterCount').textContent = sectionCount;
            document.getElementById('actCount').textContent = groupCount;
            document.getElementById('pageCount').textContent = Math.ceil(totalWords / 250);

            // Stats panel
            updateStatsPanel();
        }

        function updateStatsPanel() {
            const container = document.getElementById('statsContent');

            // ============ CONTENT NODES (Regular sections, not tasks/special) ============
            const contentNodes = nodes.filter(n => !n.isTaskNode && !TASK_NODE_TYPES[n.type] && !SPECIAL_NODE_TYPES[n.type]);
            const taskNodesList = nodes.filter(n => n.isTaskNode || TASK_NODE_TYPES[n.type]);
            const specialNodes = nodes.filter(n => SPECIAL_NODE_TYPES[n.type]);
            
            // Special node breakdown
            const folderNodes = nodes.filter(n => n.type === 'folder' || n.nodeType === 'folder');
            const stickyNodes = nodes.filter(n => n.type === 'sticky' || n.nodeType === 'sticky');
            const imageNodes = nodes.filter(n => n.type === 'image' || n.nodeType === 'image');

            // ============ WORD COUNTS ============
            let totalWords = 0;
            let totalChars = 0;
            let totalWithTarget = 0;
            let totalTargetWords = 0;
            let achievedTargetWords = 0;
            
            contentNodes.forEach(n => {
                const text = (n.fullText || '').replace(/<[^>]*>/g, ' ');
                const words = text.split(/\s+/).filter(w => w.length > 0).length;
                const chars = text.length;
                totalWords += words;
                totalChars += chars;
                
                if (n.target && n.target > 0) {
                    totalWithTarget++;
                    totalTargetWords += n.target;
                    achievedTargetWords += Math.min(words, n.target);
                }
            });
            
            // Estimated pages (assuming ~250 words/page)
            const estimatedPages = Math.ceil(totalWords / 250);
            
            // Target progress
            const targetProgress = totalTargetWords > 0 ? Math.round((achievedTargetWords / totalTargetWords) * 100) : 0;

            // ============ SECTION STATUS COUNTS ============
            const statusCounts = {};
            SECTION_STATUSES.forEach(s => { statusCounts[s.id] = 0; });
            contentNodes.forEach(n => {
                const status = n.sectionStatus || 'none';
                if (statusCounts[status] !== undefined) statusCounts[status]++;
            });
            
            // Calculate section progress (done + final = complete)
            const completeSections = statusCounts['done'] + statusCounts['final'];
            const sectionProgress = contentNodes.length > 0 ? Math.round((completeSections / contentNodes.length) * 100) : 0;

            // ============ TASK STATS ============
            const allTaskItems = [
                ...tasks,
                ...taskNodesList.map(n => ({ status: n.taskStatus || 'todo', isNode: true }))
            ];
            const totalTasks = allTaskItems.length;
            const completedTasks = allTaskItems.filter(t => t.status === 'complete' || t.status === 'done').length;
            const todoTasks = allTaskItems.filter(t => t.status === 'todo').length;
            const workingTasks = allTaskItems.filter(t => t.status === 'working' || t.status === 'ongoing').length;
            const urgentTasks = allTaskItems.filter(t => t.status === 'urgent').length;
            const taskProgress = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

            // ============ POV / AUTHOR STATS ============
            const povCounts = {};
            contentNodes.forEach(n => {
                if (n.povId) {
                    const pov = povList.find(p => p.id === n.povId);
                    const povName = pov ? pov.name : 'Unknown';
                    if (!povCounts[povName]) povCounts[povName] = { count: 0, words: 0, color: pov?.color || '#888' };
                    povCounts[povName].count++;
                    const text = (n.fullText || '').replace(/<[^>]*>/g, ' ');
                    povCounts[povName].words += text.split(/\s+/).filter(w => w.length > 0).length;
                }
            });

            // ============ NODE TYPE BREAKDOWN ============
            const typeGroups = {};
            contentNodes.forEach(n => {
                const key = n.type || 'section';
                if (!typeGroups[key]) typeGroups[key] = { count: 0, words: 0 };
                typeGroups[key].count++;
                const text = (n.fullText || '').replace(/<[^>]*>/g, ' ');
                typeGroups[key].words += text.split(/\s+/).filter(w => w.length > 0).length;
            });

            let html = `
                <!-- ======== WRITING STATS OVERVIEW ======== -->
                <div class="stats-hero">
                    <div class="stats-hero-main">
                        <div class="stats-hero-number">${totalWords.toLocaleString()}</div>
                        <div class="stats-hero-label">Toplam Kelime</div>
                    </div>
                    <div class="stats-hero-grid">
                        <div class="stats-hero-item">
                            <span class="hero-value">${totalChars.toLocaleString()}</span>
                            <span class="hero-label">Karakter</span>
                    </div>
                        <div class="stats-hero-item">
                            <span class="hero-value">${estimatedPages}</span>
                            <span class="hero-label">Sayfa</span>
                        </div>
                        <div class="stats-hero-item">
                            <span class="hero-value">${contentNodes.length}</span>
                            <span class="hero-label">B√∂l√ºm</span>
                        </div>
                        <div class="stats-hero-item">
                            <span class="hero-value">${nodes.length}</span>
                            <span class="hero-label">Toplam Node</span>
                        </div>
                    </div>
                </div>

                <!-- ======== SECTION STATUS (Writing Progress) ======== -->
                <div class="stats-section">
                    <div class="stats-section-header">
                        <span class="stats-section-title">‚úçÔ∏è Yazƒ±m Durumu</span>
                        <span class="stats-section-value">${sectionProgress}%</span>
                    </div>
                    <div class="stats-progress-bar">
                        <div class="stats-progress-fill" style="width: ${sectionProgress}%; background: linear-gradient(90deg, #22c55e, #10b981);"></div>
                        </div>
                    <div class="stats-status-grid">
                        ${SECTION_STATUSES.map(s => `
                            <div class="stats-status-item" style="border-left: 3px solid ${s.color};">
                                <span class="status-icon">${s.icon}</span>
                                <span class="status-name">${s.name}</span>
                                <span class="status-count">${statusCounts[s.id] || 0}</span>
                        </div>
                        `).join('')}
                    </div>
                </div>

                <!-- ======== WORD TARGET PROGRESS ======== -->
                ${totalWithTarget > 0 ? `
                <div class="stats-section">
                    <div class="stats-section-header">
                        <span class="stats-section-title">üéØ Kelime Hedefi</span>
                        <span class="stats-section-value">${targetProgress}%</span>
                    </div>
                    <div class="stats-progress-bar">
                        <div class="stats-progress-fill" style="width: ${targetProgress}%; background: linear-gradient(90deg, #6366f1, #8b5cf6);"></div>
                    </div>
                    <div class="stats-progress-labels">
                        <span>${achievedTargetWords.toLocaleString()} / ${totalTargetWords.toLocaleString()} kelime</span>
                        <span>${totalWithTarget} hedefli b√∂l√ºm</span>
                    </div>
                </div>
                ` : ''}

                <!-- ======== SPECIAL NODES ======== -->
                <div class="stats-section">
                    <div class="stats-section-header">
                        <span class="stats-section-title">üìé √ñzel Nodelar</span>
                    </div>
                    <div class="stats-special-grid">
                        <div class="stats-special-card" style="background: linear-gradient(135deg, #3b82f6, #1d4ed8);">
                            <div class="special-icon">üìÅ</div>
                            <div class="special-value">${folderNodes.length}</div>
                            <div class="special-label">Klas√∂r</div>
                        </div>
                        <div class="stats-special-card" style="background: linear-gradient(135deg, #f59e0b, #d97706);">
                            <div class="special-icon">üìù</div>
                            <div class="special-value">${stickyNodes.length}</div>
                            <div class="special-label">Not</div>
                        </div>
                        <div class="stats-special-card" style="background: linear-gradient(135deg, #ec4899, #be185d);">
                            <div class="special-icon">üñºÔ∏è</div>
                            <div class="special-value">${imageNodes.length}</div>
                            <div class="special-label">Resim</div>
                        </div>
                        <div class="stats-special-card" style="background: linear-gradient(135deg, #8b5cf6, #6d28d9);">
                            <div class="special-icon">üìã</div>
                            <div class="special-value">${taskNodesList.length}</div>
                            <div class="special-label">G√∂rev</div>
                        </div>
                        </div>
                    </div>

                <!-- ======== TASK PROGRESS ======== -->
                ${totalTasks > 0 ? `
                <div class="stats-section">
                    <div class="stats-section-header">
                        <span class="stats-section-title">üìã G√∂rev ƒ∞lerlemesi</span>
                        <span class="stats-section-value">${taskProgress}%</span>
                </div>
                    <div class="stats-progress-bar">
                        <div class="stats-progress-fill" style="width: ${taskProgress}%; background: linear-gradient(90deg, #f59e0b, #22c55e);"></div>
                    </div>
                    <div class="stats-task-mini">
                        <div class="task-mini-item" onclick="openTaskManager('todo')" style="cursor:pointer;">
                            <span class="mini-dot" style="background:#3b82f6;"></span>
                            <span>Yapƒ±lacak: ${todoTasks}</span>
                        </div>
                        <div class="task-mini-item" onclick="openTaskManager('working')" style="cursor:pointer;">
                            <span class="mini-dot" style="background:#f59e0b;"></span>
                            <span>Devam Eden: ${workingTasks}</span>
                        </div>
                        <div class="task-mini-item" onclick="openTaskManager('complete')" style="cursor:pointer;">
                            <span class="mini-dot" style="background:#22c55e;"></span>
                            <span>Tamamlanan: ${completedTasks}</span>
                        </div>
                        ${urgentTasks > 0 ? `
                        <div class="task-mini-item" onclick="openTaskManager('urgent')" style="cursor:pointer;">
                            <span class="mini-dot" style="background:#ef4444;"></span>
                            <span>Acil: ${urgentTasks}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>
                ` : ''}

                <!-- ======== AUTHORS / POV ======== -->
                ${Object.keys(povCounts).length > 0 ? `
                <div class="stats-section">
                    <div class="stats-section-header">
                        <span class="stats-section-title">üë§ Yazarlar / POV</span>
                    </div>
                    <div class="stats-list">
                        ${Object.entries(povCounts).sort((a, b) => b[1].words - a[1].words).map(([name, data]) => `
                            <div class="stats-list-item">
                                <span class="list-type">
                                    <span class="pov-dot" style="background:${data.color}; width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:8px;"></span>
                                    ${name}
                                </span>
                                <span class="list-count">${data.count} b√∂l√ºm ‚Ä¢ ${data.words.toLocaleString()} kelime</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                <!-- ======== NODE TYPES ======== -->
                <div class="stats-section">
                    <div class="stats-section-header">
                        <span class="stats-section-title">üìÑ B√∂l√ºm T√ºrleri</span>
                    </div>
                    <div class="stats-list">
                        ${Object.entries(typeGroups).sort((a, b) => b[1].count - a[1].count).map(([type, data]) => {
                            const typeIcons = { section: 'üìÑ', chapter: 'üìñ', act: 'üé≠', plotpoint: 'üìç', midpoint: '‚ö°', climax: 'üî•', resolution: '‚ú®', prologue: 'üåÖ', ending: 'üåô', group: 'üìÅ', note: 'üìù', draft: '‚úèÔ∏è', research: 'üî¨', reference: 'üìö', abstract: 'üìã', introduction: 'üé¨', conclusion: 'üèÅ', appendix: 'üìé' };
                            const icon = typeIcons[type] || 'üìÑ';
                            const typeName = { section: 'B√∂l√ºm', chapter: 'Chapter', act: 'Act', plotpoint: 'Plot Point', midpoint: 'Midpoint', climax: 'Climax', resolution: 'Resolution', prologue: 'Prologue', ending: 'Ending', group: 'Grup', note: 'Not', draft: 'Taslak', research: 'Ara≈ütƒ±rma', reference: 'Referans', abstract: '√ñzet', introduction: 'Giri≈ü', conclusion: 'Sonu√ß', appendix: 'Ek' }[type] || type.charAt(0).toUpperCase() + type.slice(1);
                                return `<div class="stats-list-item">
                                <span class="list-type">${icon} ${typeName}</span>
                                <span class="list-count">${data.count} ‚Ä¢ ${data.words.toLocaleString()} kelime</span>
                                </div>`;
                        }).join('')}
                    </div>
                </div>

                <!-- ======== CONNECTIONS ======== -->
                <div class="stats-section">
                    <div class="stats-section-header">
                        <span class="stats-section-title">üîó Baƒülantƒ±lar</span>
                    </div>
                    <div class="stats-connections">
                        <div class="conn-stat">
                            <span class="conn-value">${connections.length}</span>
                            <span class="conn-label">Baƒülantƒ±</span>
                        </div>
                        <div class="conn-stat">
                            <span class="conn-value">${nodes.filter(n => n.parentId).length}</span>
                            <span class="conn-label">√úst-Alt ƒ∞li≈ükisi</span>
                        </div>
                        <div class="conn-stat">
                            <span class="conn-value">${nodes.filter(n => getChildren(n.id).length > 0).length}</span>
                            <span class="conn-label">Ana Node</span>
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // ============ TIMELINE BAR (Final Draft Style) ============
        let timelineBarVisible = false;
        let timelineBarScale = 'day';
        let timelineBarZoomLevel = 100;
        let timelineBarHeight = 300;
        
        function timelineBarZoom(direction) {
            if (direction === 0) {
                timelineBarZoomLevel = 100;
            } else {
                timelineBarZoomLevel = Math.max(50, Math.min(300, timelineBarZoomLevel + direction * 25));
            }
            document.getElementById('timelineBarZoomLabel').textContent = timelineBarZoomLevel + '%';
            renderTimelineBar();
        }
        
        // Resize handle for timeline height
        (function() {
            let isResizing = false;
            let startY = 0;
            let startHeight = 0;
            
            document.addEventListener('mousedown', (e) => {
                if (e.target.closest('.timeline-resize-handle')) {
                    isResizing = true;
                    startY = e.clientY;
                    const bar = document.getElementById('timelineBar');
                    startHeight = bar ? bar.offsetHeight : 250;
                    e.preventDefault();
                    document.body.style.cursor = 'ns-resize';
                    document.body.style.userSelect = 'none';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isResizing) {
                    const diff = e.clientY - startY;
                    const newHeight = Math.max(150, Math.min(600, startHeight + diff));
                    const bar = document.getElementById('timelineBar');
                    if (bar) {
                        bar.style.height = newHeight + 'px';
                        // Update canvas padding
                        document.querySelector('.canvas-container').style.paddingTop = (newHeight + 10) + 'px';
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        })();
        
        let timelineBarCollapsed = false;
        
        function toggleTimelineBar() {
            timelineBarVisible = !timelineBarVisible;
            const bar = document.getElementById('timelineBar');
            const menuLabel = document.getElementById('timelineBarMenuLabel');
            const toggleBtn = document.getElementById('timelineToggleBtn');
            const toggleBtnLabel = document.getElementById('timelineToggleBtnLabel');
            
            if (timelineBarVisible) {
                bar.style.display = 'flex';
                document.body.classList.add('timeline-open');
                if (menuLabel) menuLabel.textContent = 'Hide Timeline';
                if (toggleBtn) toggleBtn.classList.add('open');
                if (toggleBtnLabel) toggleBtnLabel.textContent = 'Hide Timeline';
                renderTimelineBar();
                syncTimelineScroll();
            } else {
                bar.style.display = 'none';
                document.body.classList.remove('timeline-open');
                if (menuLabel) menuLabel.textContent = 'Show Timeline';
                if (toggleBtn) toggleBtn.classList.remove('open');
                if (toggleBtnLabel) toggleBtnLabel.textContent = 'Timeline';
            }
        }
        
        // Sync vertical scrolling between timeline columns
        function syncTimelineScroll() {
            const labelsCol = document.querySelector('.timeline-labels-column');
            const tracksCol = document.querySelector('.timeline-tracks-column');
            
            if (labelsCol && tracksCol) {
                let isSyncing = false;
                
                labelsCol.onscroll = function() {
                    if (!isSyncing) {
                        isSyncing = true;
                        tracksCol.scrollTop = labelsCol.scrollTop;
                        setTimeout(() => { isSyncing = false; }, 10);
                    }
                };
                tracksCol.onscroll = function() {
                    if (!isSyncing) {
                        isSyncing = true;
                        labelsCol.scrollTop = tracksCol.scrollTop;
                        setTimeout(() => { isSyncing = false; }, 10);
                    }
                };
            }
        }
        
        function collapseTimelineBar() {
            timelineBarCollapsed = !timelineBarCollapsed;
            const bar = document.getElementById('timelineBar');
            const btn = document.getElementById('timelineCollapseBtn');
            const scaleButtons = document.getElementById('timelineScaleButtons');
            const zoomButtons = document.getElementById('timelineZoomButtons');
            
            if (timelineBarCollapsed) {
                bar.classList.add('collapsed');
                btn.textContent = '‚ñ∂';
                btn.title = 'Geni≈ület';
                if (scaleButtons) scaleButtons.style.display = 'none';
                if (zoomButtons) zoomButtons.style.display = 'none';
            } else {
                bar.classList.remove('collapsed');
                btn.textContent = '‚ñº';
                btn.title = 'Daralt';
                if (scaleButtons) scaleButtons.style.display = 'flex';
                if (zoomButtons) zoomButtons.style.display = 'flex';
            }
        }
        
        function setTimelineBarScale(scale) {
            timelineBarScale = scale;
            document.querySelectorAll('.tl-scale-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.scale === scale);
            });
            renderTimelineBar();
        }
        
        // Timeline dependency collapse state
        let timelineDependencyCollapsed = new Set();
        let taskManagerDependencyCollapsed = new Set();
        
        function toggleTimelineDependency(taskId) {
            if (timelineDependencyCollapsed.has(String(taskId))) {
                timelineDependencyCollapsed.delete(String(taskId));
            } else {
                timelineDependencyCollapsed.add(String(taskId));
            }
            renderTimelineBar();
        }
        
        function toggleTaskManagerDependency(taskId) {
            if (taskManagerDependencyCollapsed.has(String(taskId))) {
                taskManagerDependencyCollapsed.delete(String(taskId));
            } else {
                taskManagerDependencyCollapsed.add(String(taskId));
            }
            renderTaskTimeline();
        }
        
        function renderTimelineBar() {
            const content = document.getElementById('timelineBarContent');
            const ruler = document.getElementById('timelineBarRuler');
            if (!content || !ruler) return;
            
            content.style.maxHeight = timelineBarHeight + 'px';
            
            // ONLY show task nodes in timeline (isTaskNode must be true)
            const taskNodes = nodes.filter(n => n.isTaskNode === true);
            
            if (taskNodes.length === 0) {
                content.innerHTML = '<div style="padding:40px; text-align:center; color:#888; font-size:14px;">üì≠ Hen√ºz task yok. Task ekleyin!</div>';
                ruler.innerHTML = '';
                return;
            }
            
            // Calculate cell width based on zoom
            const baseCellWidth = 120;
            const cellWidth = Math.round(baseCellWidth * (timelineBarZoomLevel / 100));
            
            // Calculate date range based on tasks
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let minDate = new Date(today);
            let maxDate = new Date(today);
            
            // Set range based on scale
            switch (timelineBarScale) {
                case 'hour':
                    minDate.setHours(minDate.getHours() - 6);
                    maxDate.setHours(maxDate.getHours() + 18);
                    break;
                case 'day':
                    minDate.setDate(minDate.getDate() - 7);
                    maxDate.setDate(maxDate.getDate() + 30);
                    break;
                case 'week':
                    minDate.setDate(minDate.getDate() - 14);
                    maxDate.setDate(maxDate.getDate() + 60);
                    break;
                case 'month':
                    minDate.setMonth(minDate.getMonth() - 1);
                    maxDate.setMonth(maxDate.getMonth() + 6);
                    break;
                case 'year':
                    minDate.setFullYear(minDate.getFullYear() - 1);
                    maxDate.setFullYear(maxDate.getFullYear() + 2);
                    break;
            }
            
            // Extend range based on task dates
            taskNodes.forEach(task => {
                if (task.taskDateStart) {
                    const start = new Date(task.taskDateStart);
                    if (start < minDate) minDate = new Date(start.getTime() - 86400000);
                }
                if (task.taskDateDue) {
                    const due = new Date(task.taskDateDue);
                    if (due > maxDate) maxDate = new Date(due.getTime() + 86400000);
                }
            });
            
            // Generate time units
            const timeUnits = [];
            let current = new Date(minDate);
            
            while (current <= maxDate) {
                const unitDate = new Date(current);
                let label = '';
                
                switch (timelineBarScale) {
                    case 'hour':
                        label = unitDate.toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' });
                        current.setHours(current.getHours() + 1);
                        break;
                    case 'day':
                        label = unitDate.toLocaleDateString('tr-TR', { day: 'numeric', month: 'short' });
                        current.setDate(current.getDate() + 1);
                        break;
                    case 'week':
                        const weekNum = getWeekNumber(unitDate);
                        label = `H${weekNum} - ${unitDate.toLocaleDateString('tr-TR', { day: 'numeric', month: 'short' })}`;
                        current.setDate(current.getDate() + 7);
                        break;
                    case 'month':
                        label = unitDate.toLocaleDateString('tr-TR', { month: 'long', year: 'numeric' });
                        current.setMonth(current.getMonth() + 1);
                        break;
                    case 'year':
                        label = unitDate.getFullYear().toString();
                        current.setFullYear(current.getFullYear() + 1);
                        break;
                }
                
                timeUnits.push({ date: unitDate, label: label });
            }
            
            const totalWidth = timeUnits.length * cellWidth;
            const totalMs = maxDate.getTime() - minDate.getTime();
            
            // Build separate HTML for labels (left) and tracks (right)
            let labelsHtml = '';
            let tracksHtml = '';
            
            if (taskNodes.length === 0) {
                content.innerHTML = '<div style="padding:30px; text-align:center; color:#888; width:100%;">üì≠ Hen√ºz g√∂rev yok. Task ekleyin!</div>';
                ruler.innerHTML = '';
                return;
            }
            
            // Helper function to find tasks that depend on a given task
            function getDependentTasks(taskId) {
                return taskNodes.filter(t => 
                    t.taskDependencies && t.taskDependencies.some(dep => String(dep.taskId) === String(taskId))
                );
            }
            
            // Helper function to check if a task is a root (no dependencies or dependency is not a task)
            function isRootTask(task) {
                if (!task.taskDependencies || task.taskDependencies.length === 0) return true;
                // Check if all dependencies are non-task nodes
                return task.taskDependencies.every(dep => {
                    const depNode = nodes.find(n => String(n.id) === String(dep.taskId));
                    return !depNode || !depNode.isTaskNode;
                });
            }
            
            // Helper function to render a task and its dependencies recursively
            // FIX: Improved breakdown handling - ensure tasks and definitions are on same row
            function renderTaskWithDependencies(task, level = 0, renderedIds = new Set()) {
                const taskIdStr = String(task.id);
                if (renderedIds.has(taskIdStr)) return { labels: '', tracks: '' };
                renderedIds.add(taskIdStr);
                
                // FIX: Clean up duplicate task names - remove redundant "(kopya)" markers
                let cleanTitle = task.title || '';
                if (cleanTitle.includes('(kopya) (kopya)')) {
                    cleanTitle = cleanTitle.replace('(kopya) (kopya)', '(kopya)');
                }
                
                const taskStatus = task.taskStatus || 'todo';
                const statusInfo = TASK_STATUSES.find(s => s.id === taskStatus) || TASK_STATUSES[0];
                const statusColor = statusInfo.color || '#3b82f6';
                
                // Find parent - could be section or another task
                let parentName = cleanTitle;
                let parentColor = statusColor;
                
                // Check parentId first
                if (task.parentId) {
                    const parentNode = nodes.find(n => n.id === task.parentId);
                    if (parentNode) {
                        parentName = parentNode.title;
                        parentColor = parentNode.color || (parentNode.isTaskNode ? statusColor : '#8b5cf6');
                    }
                }
                // Check linkedNodeIds if no parentId
                else if (task.linkedNodeIds && task.linkedNodeIds.length > 0) {
                    const linkedNode = nodes.find(n => n.id === task.linkedNodeIds[0]);
                    if (linkedNode) {
                        parentName = linkedNode.title;
                        parentColor = linkedNode.color || (linkedNode.isTaskNode ? statusColor : '#8b5cf6');
                    }
                }
                // Check taskDependencies
                else if (task.taskDependencies && task.taskDependencies.length > 0) {
                    const depNode = nodes.find(n => String(n.id) === String(task.taskDependencies[0].taskId));
                    if (depNode) {
                        parentName = depNode.title;
                        parentColor = depNode.color || (depNode.isTaskNode ? statusColor : '#8b5cf6');
                    }
                }
                
                // Get dependent tasks
                const dependentTasks = getDependentTasks(task.id);
                const hasDependencies = dependentTasks.length > 0;
                const isCollapsed = timelineDependencyCollapsed.has(taskIdStr);
                
                // Calculate task bar position
                const taskStart = task.taskDateStart ? new Date(task.taskDateStart) : new Date(today);
                const duration = task.taskDuration || 1;
                const durationType = task.taskDurationType || 'days';
                
                let durationMs = duration * 24 * 60 * 60 * 1000;
                if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                
                const startOffset = Math.max(0, (taskStart.getTime() - minDate.getTime()) / totalMs);
                const barWidthRatio = Math.max(0.02, durationMs / totalMs);
                const barLeft = startOffset * totalWidth;
                const barWidth = Math.max(cellWidth * 0.5, barWidthRatio * totalWidth);
                
                // Indentation for dependent tasks
                const indent = level * 20;
                const indentStyle = indent > 0 ? `padding-left:${indent}px;` : '';
                
                // Expand/collapse button
                let toggleBtn = '';
                if (hasDependencies) {
                    const arrow = isCollapsed ? '‚ñ∂' : '‚ñº';
                    toggleBtn = `<span class="timeline-toggle-btn" onclick="event.stopPropagation(); toggleTimelineDependency('${task.id}')" style="margin-right:4px; cursor:pointer; font-size:10px; color:#8b5cf6;" title="Baƒüƒ±mlƒ±lƒ±klarƒ± ${isCollapsed ? 'a√ß' : 'kapat'}">${arrow}</span>`;
                }
                
                // Label (left column - fixed) - FIX: Use cleaned title
                let taskLabels = `<div class="timeline-lane-label" style="border-left:4px solid ${parentColor}; height:28px; min-height:28px; max-height:28px; cursor:pointer; display:flex; align-items:center; box-sizing:border-box; ${indentStyle}" 
                    onclick="if(typeof focusNode === 'function') { focusNode('${task.id}'); }"
                    title="${parentName} - Canvas'ta g√∂rmek i√ßin tƒ±klayƒ±n">
                    ${toggleBtn}
                    <span class="tl-parent-name" title="${parentName}" style="max-width:none; flex:1; display:flex; align-items:center;">${parentName}</span>
                </div>`;
                
                // Track (right column - scrollable)
                // Make bar darker and add progress indicator
                const darkColor = adjustColor(statusColor, -40); // Much darker
                const darkerColor = adjustColor(statusColor, -60);
                const progress = task.taskProgress || 0;
                const progressWidth = (progress / 100) * barWidth;
                
                let taskTracks = `<div class="timeline-track-row" style="min-width:${totalWidth}px; height:28px; min-height:28px; max-height:28px; position:relative; border-bottom:1px solid #333; box-sizing:border-box; display:flex; align-items:center; ${indentStyle}" data-task-id="${task.id}">
                    <div class="timeline-node-bar draggable-bar main-timeline-bar" 
                        data-task-id="${task.id}"
                        style="left:${barLeft}px; width:${barWidth}px; background:linear-gradient(135deg, ${darkColor} 0%, ${darkerColor} 100%); height:24px; cursor:pointer; position:absolute; overflow:hidden;"
                        onclick="if(typeof focusNode === 'function') { focusNode('${task.id}'); }"
                        title="${cleanTitle} - ${statusInfo.name} (${duration} ${durationType}) - Progress: ${progress}% - Canvas'ta g√∂rmek i√ßin tƒ±klayƒ±n">
                        ${progress > 0 ? `<div class="timeline-bar-progress" style="position:absolute; left:0; top:0; height:100%; width:${progressWidth}px; background:linear-gradient(135deg, ${statusColor} 0%, ${adjustColor(statusColor, -10)} 100%); opacity:0.8; z-index:1;"></div>` : ''}
                        <span class="bar-text" style="position:relative; z-index:2; color:#fff; text-shadow:0 1px 2px rgba(0,0,0,0.5);">${cleanTitle}${progress > 0 ? ` (${progress}%)` : ''}</span>
                    </div>
                </div>`;
                
                let depLabels = '';
                let depTracks = '';
                
                // Render dependent tasks if not collapsed
                if (hasDependencies && !isCollapsed) {
                    dependentTasks.forEach(depTask => {
                        const depResult = renderTaskWithDependencies(depTask, level + 1, renderedIds);
                        depLabels += depResult.labels;
                        depTracks += depResult.tracks;
                    });
                }
                
                return { labels: taskLabels + depLabels, tracks: taskTracks + depTracks };
            }
            
            // Find root tasks (tasks without dependencies or with non-task dependencies)
            const rootTasks = taskNodes.filter(t => isRootTask(t));
            
            // Reset HTML
            labelsHtml = '';
            tracksHtml = '';
            
            // Render all root tasks and their dependencies
            const renderedIds = new Set();
            rootTasks.forEach(rootTask => {
                const result = renderTaskWithDependencies(rootTask, 0, renderedIds);
                labelsHtml += result.labels;
                tracksHtml += result.tracks;
            });
            
            // Also render tasks that are not root and haven't been rendered yet
            taskNodes.forEach(task => {
                if (!renderedIds.has(String(task.id))) {
                    const result = renderTaskWithDependencies(task, 0, renderedIds);
                    labelsHtml += result.labels;
                    tracksHtml += result.tracks;
                }
            });
            
            // Today line in tracks
            const todayOffset = (today.getTime() - minDate.getTime()) / totalMs;
            const todayLeft = todayOffset * totalWidth;
            tracksHtml += `<div class="timeline-now-line" style="left:${todayLeft}px; top:0; bottom:0;" title="Bug√ºn"></div>`;
            
            content.innerHTML = `
                <div class="timeline-labels-column">${labelsHtml}</div>
                <div class="timeline-tracks-column" id="timelineTracksScroll">${tracksHtml}</div>
            `;
            
            // Build ruler
            let rulerHtml = '';
            timeUnits.forEach((unit, i) => {
                const isToday = isSameDay(unit.date, today);
                rulerHtml += `<div class="timeline-ruler-cell ${isToday ? 'today' : ''}" style="min-width:${cellWidth}px;">${unit.label}</div>`;
            });
            ruler.innerHTML = rulerHtml;
            
            // Sync scroll between tracks column and ruler - use direct onscroll to avoid duplicate listeners
            const tracksCol = document.getElementById('timelineTracksScroll');
            const labelsCol = content.querySelector('.timeline-labels-column');
            
            if (tracksCol && labelsCol && ruler) {
                let syncingScroll = false;
                
                // Sync horizontal scroll between tracks and ruler
                tracksCol.onscroll = function() {
                    if (syncingScroll) return;
                    syncingScroll = true;
                    ruler.scrollLeft = tracksCol.scrollLeft;
                    labelsCol.scrollTop = tracksCol.scrollTop;
                    syncingScroll = false;
                };
                
                // Sync vertical scroll from labels to tracks
                labelsCol.onscroll = function() {
                    if (syncingScroll) return;
                    syncingScroll = true;
                    tracksCol.scrollTop = labelsCol.scrollTop;
                    syncingScroll = false;
                };
            }
            
            // Scroll to today
            setTimeout(() => {
                const scrollContainer = document.getElementById('timelineTracksScroll');
                if (scrollContainer) {
                    const todayPos = Math.max(0, todayOffset * totalWidth - 100);
                    scrollContainer.scrollLeft = todayPos;
                    ruler.scrollLeft = todayPos;
                }
            }, 100);
            
            // Add click-to-focus functionality for main page timeline bars (same as outline)
            // NOTE: This is ONLY for the main page timeline, NOT for Task Manager timeline
            setTimeout(() => {
                const timelineBars = content.querySelectorAll('.timeline-node-bar.main-timeline-bar[data-task-id]');
                let clickTimer = null;
                
                timelineBars.forEach(bar => {
                    const taskId = bar.getAttribute('data-task-id');
                    if (!taskId) return;
                    
                    // Remove existing onclick to avoid conflicts
                    bar.removeAttribute('onclick');
                    
                    // Single click to focus on task node (same behavior as outline click)
                    bar.addEventListener('click', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        
                        // Clear any existing timer
                        if (clickTimer) {
                            clearTimeout(clickTimer);
                            clickTimer = null;
                        }
                        
                        // Wait a bit to see if it's a double click
                        clickTimer = setTimeout(() => {
                            // Use focusNode for same behavior as outline (zoom, center, highlight, open properties)
                            if (typeof focusNode === 'function') {
                                focusNode(taskId);
                            } else if (typeof zoomToTaskOnCanvas === 'function') {
                                // Fallback to old function if focusNode doesn't exist
                                zoomToTaskOnCanvas(taskId);
                            }
                            clickTimer = null;
                        }, 300);
                    });
                    
                    // Double click to open editor
                    bar.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        if (clickTimer) {
                            clearTimeout(clickTimer);
                            clickTimer = null;
                        }
                        if (typeof openTaskNodeEditor === 'function') {
                            openTaskNodeEditor(taskId);
                        }
                    });
                    
                    // Add cursor pointer to indicate clickability
                    bar.style.cursor = 'pointer';
                });
            }, 200);
        }
        
        function adjustColor(color, amount) {
            // Simple color adjustment
            if (color.startsWith('#')) {
                let r = parseInt(color.slice(1, 3), 16);
                let g = parseInt(color.slice(3, 5), 16);
                let b = parseInt(color.slice(5, 7), 16);
                r = Math.max(0, Math.min(255, r + amount));
                g = Math.max(0, Math.min(255, g + amount));
                b = Math.max(0, Math.min(255, b + amount));
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            return color;
        }

        // ============ TASK TIMELINE FUNCTIONS ============
        let currentTimelineScale = 'day';
        let timelineZoomPercent = 100;
        let currentTaskViewMode = 'list'; // 'list' or 'timeline'
        
        function toggleTaskView(mode) {
            currentTaskViewMode = mode;
            const listContainer = document.getElementById('taskListContainer');
            const timelineContainer = document.getElementById('taskTimelineContainer');
            const scaleBar = document.getElementById('taskTimelineScaleBar');
            
            // Hide apply button and clear pending changes when switching views
            if (typeof hideApplyButton === 'function') hideApplyButton();
            
            document.querySelectorAll('.task-view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === mode);
            });
            
            if (mode === 'timeline') {
                listContainer.style.display = 'none';
                timelineContainer.style.display = 'flex';
                if (scaleBar) scaleBar.style.display = 'flex';
                renderTaskTimeline();
            } else {
                listContainer.style.display = 'block';
                timelineContainer.style.display = 'none';
                if (scaleBar) scaleBar.style.display = 'none';
            }
        }
        
        function setTimelineScale(scale) {
            currentTimelineScale = scale;
            document.querySelectorAll('.timeline-scale-btn, .tl-scale-btn-white').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.scale === scale);
            });
            renderTaskTimeline();
        }
        
        function timelineZoom(direction) {
            timelineZoomPercent = Math.max(50, Math.min(200, timelineZoomPercent + direction * 25));
            document.getElementById('timelineZoomLevel').textContent = timelineZoomPercent + '%';
            renderTaskTimeline();
        }
        
        // Zoom to fit all tasks in view
        function timelineZoomFit() {
            const taskNodes = nodes.filter(n => n.isTaskNode === true);
            if (taskNodes.length === 0) return;
            
            // Find date range of all tasks
            let minDate = new Date();
            let maxDate = new Date();
            
            taskNodes.forEach(task => {
                if (task.taskDateStart) {
                    const start = new Date(task.taskDateStart);
                    if (start < minDate) minDate = new Date(start);
                }
                if (task.taskDateDue) {
                    const due = new Date(task.taskDateDue);
                    if (due > maxDate) maxDate = new Date(due);
                }
            });
            
            // Calculate optimal zoom level based on date range and container width
            const container = document.getElementById('taskTimelineContent');
            if (!container) return;
            
            // Subtract left columns (labels + dates) - use correct widths
            const labelsColWidth = 280;
            const dateColWidth = 300;
            const containerWidth = container.clientWidth - labelsColWidth - dateColWidth - 20; // Subtract columns + padding
            
            const dateRange = maxDate.getTime() - minDate.getTime();
            const daysInRange = dateRange / (24 * 60 * 60 * 1000);
            
            // Estimate cell width needed to show all tasks
            const baseCellWidth = 80;
            const optimalZoom = Math.min(200, Math.max(50, Math.round((containerWidth / (daysInRange * baseCellWidth / 100)) * 100)));
            
            timelineZoomPercent = optimalZoom;
            document.getElementById('timelineZoomLevel').textContent = timelineZoomPercent + '%';
            
            // Force re-render to ensure task names are visible
            setTimeout(() => {
                renderTaskTimeline();
            }, 50);
            
            showToast('üìê Zoom Fit uygulandƒ±');
        }
        
        // Pending timeline changes storage
        let pendingTimelineChanges = [];
        
        // Show/hide apply button
        function showApplyButton() {
            const btn = document.getElementById('applyTimelineChangesBtn');
            if (btn) btn.style.display = 'inline-block';
        }
        
        function hideApplyButton() {
            const btn = document.getElementById('applyTimelineChangesBtn');
            if (btn) btn.style.display = 'none';
            pendingTimelineChanges = [];
        }
        
        // Apply all pending timeline changes
        function applyTimelineChanges() {
            if (pendingTimelineChanges.length === 0) {
                showToast('Deƒüi≈üiklik yok');
                return;
            }
            
            // Apply all pending changes
            pendingTimelineChanges.forEach(change => {
                const task = nodes.find(n => n.id === change.taskId);
                if (task) {
                    task.taskDateStart = change.newStartDate;
                    task.taskDateDue = change.newDueDate;
                    
                    // Cascade update dependent tasks
                    if (typeof cascadeUpdateDependentTasks === 'function') {
                        cascadeUpdateDependentTasks(change.taskId);
                    }
                }
            });
            
            // Save and refresh
            saveToLocalStorage();
            renderTaskTimeline();
            renderTaskList();
            
            const count = pendingTimelineChanges.length;
            pendingTimelineChanges = [];
            hideApplyButton();
            
            showToast(`‚úì ${count} task g√ºncellendi`);
        }
        
        // Sort tasks by dependencies (topological) and start date
        // Tasks that are depended on come first, then sorted by start date
        function sortTasksByDependencyAndDate(tasks) {
            if (!tasks || tasks.length === 0) return tasks;
            
            // Build dependency graph
            const taskMap = new Map(tasks.map(t => [t.id, t]));
            const dependsOn = new Map(); // taskId -> [taskIds it depends on]
            const dependedBy = new Map(); // taskId -> [taskIds that depend on it]
            
            tasks.forEach(task => {
                dependsOn.set(task.id, []);
                dependedBy.set(task.id, []);
            });
            
            tasks.forEach(task => {
                if (task.taskDependencies && task.taskDependencies.length > 0) {
                    task.taskDependencies.forEach(dep => {
                        if (taskMap.has(dep.taskId)) {
                            dependsOn.get(task.id).push(dep.taskId);
                            dependedBy.get(dep.taskId).push(task.id);
                        }
                    });
                }
            });
            
            // Topological sort with date ordering
            const sorted = [];
            const visited = new Set();
            const inProgress = new Set();
            
            // Get start date for sorting
            const getStartTime = (task) => {
                if (task.taskDateStart) {
                    return new Date(task.taskDateStart).getTime();
                }
                return Date.now();
            };
            
            // Sort tasks by: 1) number of dependents (more = earlier), 2) start date
            const tasksSorted = [...tasks].sort((a, b) => {
                const aDeps = dependedBy.get(a.id)?.length || 0;
                const bDeps = dependedBy.get(b.id)?.length || 0;
                if (aDeps !== bDeps) return bDeps - aDeps; // More dependents first
                return getStartTime(a) - getStartTime(b); // Earlier start date first
            });
            
            function visit(taskId) {
                if (visited.has(taskId)) return;
                if (inProgress.has(taskId)) return; // Circular dependency
                
                inProgress.add(taskId);
                
                // Visit dependencies first
                const deps = dependsOn.get(taskId) || [];
                deps.forEach(depId => visit(depId));
                
                inProgress.delete(taskId);
                visited.add(taskId);
                
                const task = taskMap.get(taskId);
                if (task) sorted.push(task);
            }
            
            tasksSorted.forEach(task => visit(task.id));
            
            return sorted;
        }
        
        function renderTaskTimeline() {
            const container = document.getElementById('taskTimelineContent');
            if (!container) {
                console.warn('‚ö†Ô∏è taskTimelineContent container not found');
                return;
            }
            
            // Get ONLY task nodes (isTaskNode must be true)
            let taskNodes = nodes.filter(n => n.isTaskNode === true);
            
            // Apply sidebar node filter if active (null or undefined means show all tasks)
            if (typeof currentSidebarNodeFilter !== 'undefined' && currentSidebarNodeFilter !== null && currentSidebarNodeFilter !== '') {
                if (currentSidebarNodeFilter === 'orphan') {
                    taskNodes = taskNodes.filter(t => !t.parentId && (!t.linkedNodeIds || t.linkedNodeIds.length === 0));
                } else {
                    taskNodes = taskNodes.filter(t => {
                        const isLinked = t.parentId === currentSidebarNodeFilter || 
                                        (t.linkedNodeIds && t.linkedNodeIds.includes(currentSidebarNodeFilter));
                        const isConnected = connections.some(c => 
                            (c.from === t.id && c.to === currentSidebarNodeFilter) || 
                            (c.from === currentSidebarNodeFilter && c.to === t.id)
                        );
                        return isLinked || isConnected;
                    });
                }
            }
            // If currentSidebarNodeFilter is null/undefined/empty, show ALL tasks (no filtering)
            
            // Apply status filter if active
            if (typeof currentTaskFilter !== 'undefined' && currentTaskFilter && currentTaskFilter !== 'all') {
                taskNodes = taskNodes.filter(t => t.taskStatus === currentTaskFilter);
            }
            
            // Sort tasks by dependencies and start date (topological sort with date ordering)
            taskNodes = sortTasksByDependencyAndDate(taskNodes);
            
            // Get parent section nodes (sections that have tasks connected to them)
            const parentIds = [...new Set(taskNodes.map(t => t.parentId).filter(id => id))];
            const sectionNodes = nodes.filter(n => parentIds.includes(n.id) && !n.isTaskNode);
            
            if (taskNodes.length === 0) {
                container.innerHTML = '<div style="padding:40px; text-align:center; color:#888;">üì≠ Hen√ºz g√∂rev yok. Task ekleyin!</div>';
                return;
            }
            
            // Calculate cell width based on zoom
            const baseCellWidth = 80;
            const cellWidth = Math.round(baseCellWidth * (timelineZoomPercent / 100));
            
            // Calculate date range based on scale
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            let minDate = new Date(today);
            let maxDate = new Date(today);
            
            // First, find the date range from all tasks
            let earliestTask = new Date(today);
            let latestTask = new Date(today);
            
            taskNodes.forEach(task => {
                if (task.taskDateStart) {
                    const start = new Date(task.taskDateStart);
                    if (start < earliestTask) earliestTask = new Date(start);
                }
                if (task.taskDateDue) {
                    const due = new Date(task.taskDateDue);
                    if (due > latestTask) latestTask = new Date(due);
                }
            });
            
            // Set min/max based on tasks first, then extend based on scale
            minDate = new Date(earliestTask);
            maxDate = new Date(latestTask);
            
            switch (currentTimelineScale) {
                case 'hour':
                    minDate.setHours(minDate.getHours() - 6);
                    maxDate.setHours(maxDate.getHours() + 24);
                    break;
                case 'day':
                    minDate.setDate(minDate.getDate() - 3);
                    maxDate.setDate(maxDate.getDate() + 14);
                    break;
                case 'week':
                    minDate.setDate(minDate.getDate() - 7);
                    maxDate.setDate(maxDate.getDate() + 30);
                    break;
                case 'month':
                    minDate.setMonth(minDate.getMonth() - 1);
                    maxDate.setMonth(maxDate.getMonth() + 6);
                    break;
                case 'year':
                    minDate.setFullYear(minDate.getFullYear() - 1);
                    maxDate.setFullYear(maxDate.getFullYear() + 2);
                    break;
            }
            
            // Generate time units
            const timeUnits = [];
            let current = new Date(minDate);
            
            while (current <= maxDate) {
                const unitDate = new Date(current);
                let label = '';
                
                switch (currentTimelineScale) {
                    case 'hour':
                        label = unitDate.toLocaleTimeString('tr-TR', { hour: '2-digit', minute: '2-digit' });
                        current.setHours(current.getHours() + 1);
                        break;
                    case 'day':
                        label = unitDate.toLocaleDateString('tr-TR', { day: 'numeric', month: 'short' });
                        current.setDate(current.getDate() + 1);
                        break;
                    case 'week':
                        label = `H${getWeekNumber(unitDate)}`;
                        current.setDate(current.getDate() + 7);
                        break;
                    case 'month':
                        label = unitDate.toLocaleDateString('tr-TR', { month: 'short', year: '2-digit' });
                        current.setMonth(current.getMonth() + 1);
                        break;
                    case 'year':
                        label = unitDate.getFullYear().toString();
                        current.setFullYear(current.getFullYear() + 1);
                        break;
                }
                
                timeUnits.push({ date: unitDate, label: label });
            }
            
            const totalWidth = timeUnits.length * cellWidth;
            const totalMs = maxDate.getTime() - minDate.getTime();
            
            // Build rows - ONLY sections that have tasks connected
            const rows = [];
            
            // Add section nodes ONLY if they have connected tasks
            sectionNodes.forEach(section => {
                const connectedTasks = taskNodes.filter(t => t.parentId === section.id);
                if (connectedTasks.length > 0) { // Only add if has tasks
                    rows.push({
                        type: 'section',
                        node: section,
                        tasks: connectedTasks,
                        color: section.color || '#8b5cf6'
                    });
                }
            });
            
            // Add orphan tasks (not connected to any section)
            const orphanTasks = taskNodes.filter(t => !t.parentId || !sectionNodes.find(s => s.id === t.parentId));
            if (orphanTasks.length > 0) {
                rows.push({
                    type: 'orphan',
                    node: { title: 'Baƒüƒ±msƒ±z G√∂revler', id: 'orphan' },
                    tasks: orphanTasks,
                    color: '#666'
                });
            }
            
            // If no rows with tasks, show message
            if (rows.length === 0) {
                container.innerHTML = '<div style="padding:40px; text-align:center; color:#888;">üì≠ Hen√ºz g√∂rev yok. G√∂rev ekleyin veya b√∂l√ºmlere baƒülayƒ±n.</div>';
                return;
            }
            
            // Build HTML - Task names + Date columns on left, bars on right
            let labelsHtml = '';
            let tracksHtml = '';
            let dateColumnsHtml = '';
            
            // Header row for columns
            // FIX: All header rows must have same height (28px) to prevent column shifts
            const headerHeight = '28px';
            labelsHtml += `<div class="timeline-lane-label timeline-header-row" style="height:${headerHeight}; min-height:${headerHeight}; max-height:${headerHeight}; background:#252538; font-weight:600; color:#8b5cf6; box-sizing:border-box; display:flex; align-items:center;">
                <span style="flex:1;">G√ñREV ADI</span>
            </div>`;
            
            dateColumnsHtml += `<div class="timeline-date-row timeline-header-row" style="display:flex; height:${headerHeight}; min-height:${headerHeight}; max-height:${headerHeight}; background:#252538; border-bottom:1px solid #444; align-items:center; box-sizing:border-box;">
                <div class="tl-date-col" style="background:#3b82f6; color:#fff;">START DATE</div>
                <div class="tl-date-col" style="background:#ef4444; color:#fff;">END DATE</div>
                <div class="tl-date-col" style="background:#8b5cf6; color:#fff;">DURATION</div>
            </div>`;
            
            tracksHtml += `<div class="timeline-track-row timeline-header-row" style="min-width:${totalWidth}px; height:${headerHeight}; min-height:${headerHeight}; max-height:${headerHeight}; background:#252538; border-bottom:1px solid #444; box-sizing:border-box;"></div>`;
            
            // Debug: Check task count
            console.log('üìä Timeline render - Task count:', taskNodes.length);
            
            // Helper function to find tasks that depend on a given task
            function getDependentTasks(taskId) {
                return taskNodes.filter(t => 
                    t.taskDependencies && t.taskDependencies.some(dep => String(dep.taskId) === String(taskId))
                );
            }
            
            // Helper function to check if a task is a root (no dependencies or dependency is not a task)
            function isRootTask(task) {
                if (!task.taskDependencies || task.taskDependencies.length === 0) return true;
                // Check if all dependencies are non-task nodes
                return task.taskDependencies.every(dep => {
                    const depNode = nodes.find(n => String(n.id) === String(dep.taskId));
                    return !depNode || !depNode.isTaskNode;
                });
            }
            
            // Helper function to render a task and its dependencies recursively
            // FIX: Improved breakdown handling - ensure tasks and definitions are on same row
            function renderTaskWithDependencies(task, level = 0, renderedIds = new Set()) {
                const taskIdStr = String(task.id);
                if (renderedIds.has(taskIdStr)) return { labels: '', dates: '', tracks: '' };
                renderedIds.add(taskIdStr);
                
                if (!task || !task.title) {
                    console.warn('‚ö†Ô∏è Invalid task:', task);
                    return { labels: '', dates: '', tracks: '' };
                }
                
                // FIX: Clean up duplicate task names - remove redundant "(kopya)" markers
                let cleanTitle = task.title;
                if (cleanTitle.includes('(kopya) (kopya)')) {
                    cleanTitle = cleanTitle.replace('(kopya) (kopya)', '(kopya)');
                }
                
                const taskStatus = task.taskStatus || 'todo';
                const statusInfo = TASK_STATUSES.find(s => s.id === taskStatus) || TASK_STATUSES[0];
                const statusColor = statusInfo.color || '#3b82f6';
                const progress = task.taskProgress || 0;
                const duration = task.taskDuration || 1;
                const durationType = task.taskDurationType || 'days';
                
                // Dependency info removed from bar display per user request - no SS/FF labels
                let depInfo = '';
                
                // Calculate dates
                const taskStart = task.taskDateStart ? new Date(task.taskDateStart) : new Date(today);
                let durationMs = duration * 24 * 60 * 60 * 1000;
                if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                
                const taskEnd = task.taskDateDue ? new Date(task.taskDateDue) : new Date(taskStart.getTime() + durationMs);
                
                // Format dates
                const startDateStr = taskStart.toLocaleDateString('tr-TR', { day: '2-digit', month: 'short', year: '2-digit' });
                const endDateStr = taskEnd.toLocaleDateString('tr-TR', { day: '2-digit', month: 'short', year: '2-digit' });
                const durationStr = `${duration} ${durationType === 'days' ? 'g√ºn' : durationType === 'hours' ? 'saat' : durationType === 'weeks' ? 'hafta' : 'ay'}`;
                
                // Get dependent tasks
                const dependentTasks = getDependentTasks(task.id);
                const hasDependencies = dependentTasks.length > 0;
                const isCollapsed = taskManagerDependencyCollapsed.has(taskIdStr);
                
                // Indentation for dependent tasks
                const indent = level * 20;
                const indentStyle = indent > 0 ? `padding-left:${indent}px;` : '';
                
                // Expand/collapse button
                let toggleBtn = '';
                if (hasDependencies) {
                    const arrow = isCollapsed ? '‚ñ∂' : '‚ñº';
                    toggleBtn = `<span class="timeline-toggle-btn" onclick="event.stopPropagation(); toggleTaskManagerDependency('${task.id}')" style="margin-right:4px; cursor:pointer; font-size:10px; color:#8b5cf6;" title="Baƒüƒ±mlƒ±lƒ±klarƒ± ${isCollapsed ? 'a√ß' : 'kapat'}">${arrow}</span>`;
                }
                
                // Label (left column) - Task name
                // FIX: Use cleaned title to avoid redundant "(kopya)" markers
                const taskTitle = sanitizeText(cleanTitle) || 'ƒ∞simsiz Task';
                // FIX: Use consistent height for all rows (28px to match main timeline)
                const rowHeight = 28;
                const rowHeightPx = `${rowHeight}px`;
                
                let taskLabels = `<div class="timeline-lane-label" style="border-left:4px solid ${statusColor}; height:${rowHeightPx}; min-height:${rowHeightPx}; max-height:${rowHeightPx}; display:flex !important; align-items:center; padding:0 12px; visibility:visible !important; opacity:1 !important; box-sizing:border-box; line-height:${rowHeightPx}; ${indentStyle}">
                    ${toggleBtn}
                    <span class="tl-task-name" title="${taskTitle}" style="display:flex !important; align-items:center !important; width:100%; visibility:visible !important; opacity:1 !important; color:#fff !important; font-size:12px !important; font-weight:600 !important; height:100%;">${taskTitle}</span>
                </div>`;
                
                // Date columns (middle) - FIX: Match height exactly and ensure alignment
                let taskDates = `<div class="timeline-date-row" style="display:flex; height:${rowHeightPx}; min-height:${rowHeightPx}; max-height:${rowHeightPx}; border-bottom:1px solid #333; box-sizing:border-box; align-items:center; ${indentStyle}">
                    <div class="tl-date-col tl-start-date" style="display:flex; align-items:center; justify-content:center; height:100%;">${startDateStr}</div>
                    <div class="tl-date-col tl-end-date" style="display:flex; align-items:center; justify-content:center; height:100%;">${endDateStr}</div>
                    <div class="tl-date-col tl-duration" style="display:flex; align-items:center; justify-content:center; height:100%;">${durationStr}</div>
                </div>`;
                
                // Track (right column)
                const startOffset = Math.max(0, (taskStart.getTime() - minDate.getTime()) / totalMs);
                const barWidthRatio = Math.max(0.02, durationMs / totalMs);
                const barLeft = startOffset * totalWidth;
                const barWidth = Math.max(cellWidth * 0.8, barWidthRatio * totalWidth);
                
                // Bar text - show progress if > 0, else show title
                // FIX: Use cleaned title for consistency
                let barText = sanitizeText(cleanTitle);
                if (progress > 0) {
                    barText = `PROGRESS %${progress}`;
                }
                
                // Make bar darker and add progress indicator
                const darkColor = adjustColor(statusColor, -40); // Much darker
                const darkerColor = adjustColor(statusColor, -60);
                const progressWidth = (progress / 100) * barWidth;
                
                // FIX: Match height exactly with label and date rows - bar should fill row height for alignment
                let taskTracks = `<div class="timeline-track-row" style="min-width:${totalWidth}px; height:${rowHeightPx}; min-height:${rowHeightPx}; max-height:${rowHeightPx}; position:relative; border-bottom:1px solid #333; box-sizing:border-box; display:flex; align-items:center; ${indentStyle}" data-task-id="${task.id}">
                    <div class="timeline-node-bar draggable-bar task-manager-bar" 
                        data-task-id="${task.id}"
                        style="left:${barLeft}px; width:${barWidth}px; background:linear-gradient(135deg, ${darkColor} 0%, ${darkerColor} 100%); height:24px; cursor:pointer; position:absolute; overflow:hidden;"
                        title="${sanitizeText(task.title)} - ${sanitizeText(statusInfo.name)} (${duration} ${durationType}) - Progress: ${progress}% - Canvas'ta g√∂rmek i√ßin tƒ±klayƒ±n, d√ºzenlemek i√ßin √ßift tƒ±klayƒ±n">
                        ${progress > 0 ? `<div class="timeline-bar-progress" style="position:absolute; left:0; top:0; height:100%; width:${progressWidth}px; background:linear-gradient(135deg, ${statusColor} 0%, ${adjustColor(statusColor, -10)} 100%); opacity:0.8; z-index:1;"></div>` : ''}
                        <span class="bar-text" style="font-weight:600; position:relative; z-index:2; color:#fff; text-shadow:0 1px 2px rgba(0,0,0,0.5);">${barText}${progress > 0 ? ` (${progress}%)` : ''}</span>
                        <!-- SS/FF dependency labels removed per user request -->
                    </div>
                </div>`;
                
                let depLabels = '';
                let depDates = '';
                let depTracks = '';
                
                // Render dependent tasks if not collapsed
                if (hasDependencies && !isCollapsed) {
                    dependentTasks.forEach(depTask => {
                        const depResult = renderTaskWithDependencies(depTask, level + 1, renderedIds);
                        depLabels += depResult.labels;
                        depDates += depResult.dates;
                        depTracks += depResult.tracks;
                    });
                }
                
                return { labels: taskLabels + depLabels, dates: taskDates + depDates, tracks: taskTracks + depTracks };
            }
            
            // Find root tasks (tasks without dependencies or with non-task dependencies)
            const rootTasks = taskNodes.filter(t => isRootTask(t));
            
            // Reset HTML
            labelsHtml = '';
            tracksHtml = '';
            dateColumnsHtml = '';
            
            // Render all root tasks and their dependencies
            const renderedIds = new Set();
            rootTasks.forEach(rootTask => {
                const result = renderTaskWithDependencies(rootTask, 0, renderedIds);
                labelsHtml += result.labels;
                dateColumnsHtml += result.dates;
                tracksHtml += result.tracks;
            });
            
            // FIX: Also render orphaned tasks (tasks that depend on non-task nodes or have circular dependencies)
            // But filter out duplicate tasks (tasks with "kopya" in name should be handled separately)
            taskNodes.forEach(task => {
                if (!renderedIds.has(String(task.id))) {
                    // Skip tasks that are clearly duplicates unless they're part of a breakdown
                    const taskTitle = (task.title || '').toLowerCase();
                    const isDuplicate = taskTitle.includes('kopya') && taskTitle.includes('(kopya)');
                    
                    // Only render if it's not a duplicate or if it has a valid parent relationship
                    if (!isDuplicate || (task.parentId && nodes.find(n => n.id === task.parentId))) {
                        const result = renderTaskWithDependencies(task, 0, renderedIds);
                        labelsHtml += result.labels;
                        dateColumnsHtml += result.dates;
                        tracksHtml += result.tracks;
                    }
                }
            });
            
            // Today line
            const todayOffset = (today.getTime() - minDate.getTime()) / totalMs;
            const todayLeft = todayOffset * totalWidth;
            const todayDateStr = today.toLocaleDateString('tr-TR', { day: '2-digit', month: 'short', year: 'numeric' });
            
            // Today indicator on tracks
            tracksHtml += `<div class="timeline-now-line" style="left:${todayLeft}px; top:0; bottom:0;" title="Bug√ºn - ${todayDateStr}"></div>`;
            
            // Build ruler
            let rulerHtml = '';
            timeUnits.forEach((unit, i) => {
                const isToday = isSameDay(unit.date, today);
                rulerHtml += `<div class="timeline-ruler-cell ${isToday ? 'today' : ''}" style="min-width:${cellWidth}px;">${unit.label}</div>`;
            });
            
            // Today/Selected Date header - positioned above task bars to avoid conflict
            const todayHeaderHtml = `
                <div class="timeline-today-header" style="position:absolute; left:${todayLeft}px; top:-32px; transform:translateX(-50%); z-index:100;">
                    <div style="background:linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color:#fff; padding:4px 12px; border-radius:8px 8px 0 0; font-size:11px; font-weight:600; white-space:nowrap; box-shadow:0 2px 8px rgba(239,68,68,0.4);">
                        üìÖ BUG√úN: ${todayDateStr}
                    </div>
                </div>
            `;
            
            // Ensure labelsHtml has content - always show header even if no tasks
            if (!labelsHtml || labelsHtml.trim() === '' || labelsHtml.trim() === '<div class="timeline-lane-label timeline-header-row" style="height:32px; min-height:32px; background:#252538; font-weight:600; color:#8b5cf6;"><span style="flex:1;">G√ñREV ADI</span></div>') {
                console.warn('‚ö†Ô∏è labelsHtml is empty or only has header! Task count:', taskNodes.length);
                labelsHtml += '<div style="padding:20px; color:#888; text-align:center; font-size:12px;">G√∂rev bulunamadƒ±</div>';
            }
            
            // Debug: Log labelsHtml length
            console.log('üìã Timeline labelsHtml length:', labelsHtml.length, 'Task count:', taskNodes.length);
            
            // Final HTML structure with date columns
            const dateColWidth = 300; // 3 columns x 100px
            const labelsColWidth = 280; // Task names column width - FIXED to prevent disappearing
            let html = `
                <div class="timeline-bar-content" style="flex:1; display:flex; overflow:hidden; background:#1e1e2e;">
                    <div class="timeline-labels-column" style="width:${labelsColWidth}px !important; min-width:${labelsColWidth}px !important; max-width:${labelsColWidth}px !important; overflow-y:auto; overflow-x:hidden; background:#1e1e2e; border-right:1px solid #444; display:block !important; visibility:visible !important; flex-shrink:0 !important; position:relative; z-index:5;">${labelsHtml}</div>
                    <div class="timeline-dates-column" style="width:${dateColWidth}px; min-width:${dateColWidth}px; overflow-y:auto; overflow-x:hidden; background:#1a1a2e; border-right:2px solid #444;">${dateColumnsHtml}</div>
                    <div class="timeline-tracks-column" id="taskManagerTracksScroll" style="flex:1; overflow-x:auto; overflow-y:auto; background:#1a1a2a; position:relative; padding-top:36px; padding-bottom:12px; padding-right:8px; margin-bottom:4px;">
                        ${todayHeaderHtml}
                        ${tracksHtml}
                    </div>
                </div>
                <div class="timeline-bar-ruler" id="taskManagerRuler" style="display:flex; height:22px; background:#1a1a2a; border-top:1px solid #333; margin-left:${labelsColWidth + dateColWidth + 2}px; margin-top:4px; overflow-x:auto;">${rulerHtml}</div>
            `;
            
            container.innerHTML = html;
            
            // Sync scroll - all columns
            const tracksCol = document.getElementById('taskManagerTracksScroll');
            const labelsCol = container.querySelector('.timeline-labels-column');
            const datesCol = container.querySelector('.timeline-dates-column');
            const ruler = document.getElementById('taskManagerRuler');
            
            if (tracksCol && labelsCol && datesCol && ruler) {
                let syncingScroll = false;
                
                tracksCol.onscroll = function() {
                    if (syncingScroll) return;
                    syncingScroll = true;
                    ruler.scrollLeft = tracksCol.scrollLeft;
                    labelsCol.scrollTop = tracksCol.scrollTop;
                    datesCol.scrollTop = tracksCol.scrollTop;
                    // Update dependency lines position
                    updateTimelineDependencyLines();
                    syncingScroll = false;
                };
                
                labelsCol.onscroll = function() {
                    if (syncingScroll) return;
                    syncingScroll = true;
                    tracksCol.scrollTop = labelsCol.scrollTop;
                    datesCol.scrollTop = labelsCol.scrollTop;
                    syncingScroll = false;
                };
                
                datesCol.onscroll = function() {
                    if (syncingScroll) return;
                    syncingScroll = true;
                    tracksCol.scrollTop = datesCol.scrollTop;
                    labelsCol.scrollTop = datesCol.scrollTop;
                    syncingScroll = false;
                };
                
                // Scroll to today
                setTimeout(() => {
                    const scrollTo = Math.max(0, todayOffset * totalWidth - 100);
                    tracksCol.scrollLeft = scrollTo;
                    ruler.scrollLeft = scrollTo;
                }, 100);
            }
            
            // Dependency lines and labels removed per user request
            // drawTimelineDependencies call removed - no lines, no SS/FF labels
            
            // Initialize drag handlers
            setTimeout(() => {
                initTimelineDragHandlers();
            }, 150);
            
            // Add click-to-focus functionality for task manager timeline bars (same as outline)
            setTimeout(() => {
                const taskManagerBars = tracksCol.querySelectorAll('.timeline-node-bar.task-manager-bar[data-task-id]');
                let clickTimer = null;
                
                taskManagerBars.forEach(bar => {
                    const taskId = bar.getAttribute('data-task-id');
                    if (!taskId) return;
                    
                    // Single click to focus on task node (same behavior as outline click)
                    bar.addEventListener('click', (e) => {
                        e.stopPropagation();
                        
                        // Clear any existing timer
                        if (clickTimer) {
                            clearTimeout(clickTimer);
                            clickTimer = null;
                        }
                        
                        // Wait a bit to see if it's a double click
                        clickTimer = setTimeout(() => {
                            if (typeof focusNode === 'function') {
                                focusNode(taskId);
                            }
                            clickTimer = null;
                        }, 300);
                    });
                    
                    // Double click to open editor
                    bar.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        if (clickTimer) {
                            clearTimeout(clickTimer);
                            clickTimer = null;
                        }
                        if (typeof openTaskNodeEditor === 'function') {
                            openTaskNodeEditor(taskId);
                        }
                    });
                    
                    // Ensure cursor pointer
                    bar.style.cursor = 'pointer';
                });
            }, 200);
        }
        
        // Refresh Task Manager Timeline
        function refreshTaskManagerTimeline() {
            if (typeof renderTaskTimeline === 'function') {
                renderTaskTimeline();
                showToast('‚úì Timeline yenilendi');
            }
        }
        
        // Refresh Main Page Timeline
        function refreshMainTimeline() {
            if (typeof renderTimelineBar === 'function') {
                renderTimelineBar();
                showToast('‚úì Timeline yenilendi');
            }
        }
        
        // Draw dependency lines on timeline (Gantt-style)
        // DISABLED: User requested removal of dependency lines and SS/FF labels
        function drawTimelineDependencies(taskNodes, minDate, totalMs, totalWidth) {
            // Function disabled - no dependency lines or labels should be shown
            return;
            
            const tracksCol = document.getElementById('taskManagerTracksScroll');
            if (!tracksCol) return;
            
            // Remove existing SVG
            const existingSvg = tracksCol.querySelector('.timeline-dependencies-svg');
            if (existingSvg) existingSvg.remove();
            
            // Create SVG for dependency lines - always on top
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('timeline-dependencies-svg');
            svg.style.cssText = `position:absolute; top:0; left:0; width:${totalWidth}px; height:100%; pointer-events:none; z-index:1000;`;
            
            // Store task bar positions - FIX: Use consistent positioning relative to container
            const taskPositions = {};
            const containerRect = tracksCol.getBoundingClientRect();
            
            tracksCol.querySelectorAll('.timeline-node-bar').forEach(bar => {
                const taskId = bar.dataset.taskId;
                const row = bar.closest('.timeline-track-row');
                if (row && taskId) {
                    // Get actual positions relative to container
                    const barRect = bar.getBoundingClientRect();
                    const rowRect = row.getBoundingClientRect();
                    
                    // Calculate positions relative to tracksCol container
                    const left = parseFloat(bar.style.left) || 0;
                    const width = parseFloat(bar.style.width) || barRect.width;
                    const top = row.offsetTop; // Relative to tracksCol
                    const centerY = top + (rowRect.height / 2);
                    
                    taskPositions[taskId] = {
                        left: left,
                        width: width,
                        top: top,
                        height: rowRect.height || 28,
                        centerY: centerY
                    };
                }
            });
            
            // Draw dependency lines for each task
            taskNodes.forEach(task => {
                if (!task.taskDependencies || task.taskDependencies.length === 0) return;
                
                const toPos = taskPositions[task.id];
                if (!toPos) return;
                
                task.taskDependencies.forEach(dep => {
                    const fromPos = taskPositions[dep.taskId];
                    if (!fromPos) return;
                    
                    const depType = dep.type || 'FS';
                    let startX, startY, endX, endY;
                    
                    // Calculate start/end points based on dependency type
                    switch (depType) {
                        case 'FS': // Finish to Start
                            startX = fromPos.left + fromPos.width;
                            startY = fromPos.centerY;
                            endX = toPos.left;
                            endY = toPos.centerY;
                            break;
                        case 'SS': // Start to Start
                            startX = fromPos.left;
                            startY = fromPos.centerY;
                            endX = toPos.left;
                            endY = toPos.centerY;
                            break;
                        case 'FF': // Finish to Finish
                            startX = fromPos.left + fromPos.width;
                            startY = fromPos.centerY;
                            endX = toPos.left + toPos.width;
                            endY = toPos.centerY;
                            break;
                        case 'SF': // Start to Finish
                            startX = fromPos.left;
                            startY = fromPos.centerY;
                            endX = toPos.left + toPos.width;
                            endY = toPos.centerY;
                            break;
                        default:
                            startX = fromPos.left + fromPos.width;
                            startY = fromPos.centerY;
                            endX = toPos.left;
                            endY = toPos.centerY;
                    }
                    
                    // Create path with angled (cornered) line instead of curve
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    
                    // Angled line (cornered) - horizontal then vertical then horizontal
                    let d;
                    if (Math.abs(startY - endY) < 5) {
                        // Same row - simple horizontal line
                        d = `M ${startX} ${startY} L ${endX} ${endY}`;
                    } else {
                        // Different rows - angled path (cornered)
                        const cornerX = startX + Math.min(50, Math.abs(endX - startX) / 2);
                        d = `M ${startX} ${startY} L ${cornerX} ${startY} L ${cornerX} ${endY} L ${endX} ${endY}`;
                    }
                    
                    path.setAttribute('d', d);
                    path.setAttribute('stroke', '#8b5cf6');
                    path.setAttribute('stroke-width', '1.5'); // Thin line
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-dasharray', depType === 'FS' ? 'none' : '3,2');
                    svg.appendChild(path);
                    
                    // Add arrowhead at the end (angled arrow)
                    const arrowSize = 6;
                    const angle = Math.atan2(endY - startY, endX - startX);
                    const arrowX = endX;
                    const arrowY = endY;
                    
                    // Create arrow marker
                    const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                    marker.setAttribute('id', `arrow-${depType}-${task.id}-${dep.taskId}`);
                    marker.setAttribute('markerWidth', '10');
                    marker.setAttribute('markerHeight', '10');
                    marker.setAttribute('refX', '9');
                    marker.setAttribute('refY', '3');
                    marker.setAttribute('orient', 'auto');
                    marker.setAttribute('markerUnits', 'strokeWidth');
                    
                    const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    arrowPath.setAttribute('d', 'M 0,0 L 0,6 L 9,3 Z');
                    arrowPath.setAttribute('fill', '#8b5cf6');
                    marker.appendChild(arrowPath);
                    
                    // Check if marker already exists
                    const existingMarker = svg.querySelector(`#arrow-${depType}-${task.id}-${dep.taskId}`);
                    if (!existingMarker) {
                        const defs = svg.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        if (!svg.querySelector('defs')) {
                            svg.insertBefore(defs, svg.firstChild);
                        }
                        defs.appendChild(marker);
                        path.setAttribute('marker-end', `url(#arrow-${depType}-${task.id}-${dep.taskId})`);
                    }
                    
                    // SS/FF/FS labels removed per user request - no dependency labels should be shown
                });
            });
            
            // Ensure SVG is appended last so it's always on top
            tracksCol.style.position = 'relative';
            // Append SVG to ensure it's always on top (after all task bars)
            tracksCol.appendChild(svg);
        }
        
        // Update dependency lines on scroll
        function updateTimelineDependencyLines() {
            // Lines are positioned absolutely, no update needed on scroll
            // This function can be extended for dynamic updates if needed
        }
        
        // Cascade update all dependent tasks when a task changes
        // This updates START/END dates for all tasks that depend on the changed task
        function cascadeUpdateDependentTasks(changedTaskId, visitedIds = new Set()) {
            // Prevent infinite loops
            if (visitedIds.has(changedTaskId)) return;
            visitedIds.add(changedTaskId);
            
            const changedTask = nodes.find(n => n.id === changedTaskId);
            if (!changedTask) return;
            
            const changedStart = changedTask.taskDateStart ? new Date(changedTask.taskDateStart) : null;
            const changedEnd = changedTask.taskDateDue ? new Date(changedTask.taskDateDue) : null;
            
            if (!changedStart) return;
            
            // Find all tasks that depend on this task
            const allTaskTypes = getAllTaskTypes();
            const taskNodes = nodes.filter(n => n.isTaskNode || allTaskTypes[n.type]);
            
            taskNodes.forEach(task => {
                if (task.id === changedTaskId) return;
                if (!task.taskDependencies || task.taskDependencies.length === 0) return;
                
                // Check if this task depends on the changed task
                const dep = task.taskDependencies.find(d => d.taskId === changedTaskId);
                if (!dep) return;
                
                const depType = dep.type || 'FS';
                const lagValue = dep.lag || 0;
                const lagUnit = dep.lagUnit || 'days';
                
                // Convert lag to milliseconds based on unit
                let lagMs = 0;
                switch(lagUnit) {
                    case 'hours': lagMs = lagValue * 60 * 60 * 1000; break;
                    case 'days': lagMs = lagValue * 24 * 60 * 60 * 1000; break;
                    case 'weeks': lagMs = lagValue * 7 * 24 * 60 * 60 * 1000; break;
                    case 'months': lagMs = lagValue * 30 * 24 * 60 * 60 * 1000; break;
                    default: lagMs = lagValue * 24 * 60 * 60 * 1000; break;
                }
                
                let newStartDate = null;
                
                // Calculate new start date based on dependency type
                switch (depType) {
                    case 'FS': // Finish-to-Start: This task starts after changed task finishes
                        if (changedEnd) {
                            newStartDate = new Date(changedEnd.getTime() + lagMs);
                        }
                        break;
                    case 'SS': // Start-to-Start: This task starts when changed task starts
                        newStartDate = new Date(changedStart.getTime() + lagMs);
                        break;
                    case 'FF': // Finish-to-Finish: This task finishes when changed task finishes
                        if (changedEnd) {
                            const duration = task.taskDuration || 1;
                            const durationType = task.taskDurationType || 'days';
                            let durationMs = duration * 24 * 60 * 60 * 1000;
                            if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                            else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                            else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                            
                            const newEndDate = new Date(changedEnd.getTime() + lagMs);
                            newStartDate = new Date(newEndDate.getTime() - durationMs);
                        }
                        break;
                    case 'SF': // Start-to-Finish: This task finishes when changed task starts
                        const duration = task.taskDuration || 1;
                        const durationType = task.taskDurationType || 'days';
                        let durationMs = duration * 24 * 60 * 60 * 1000;
                        if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                        else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                        else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                        
                        const newEndDateSF = new Date(changedStart.getTime() + lagMs);
                        newStartDate = new Date(newEndDateSF.getTime() - durationMs);
                        break;
                }
                
                if (newStartDate) {
                    // Update this task's dates
                    task.taskDateStart = newStartDate.toISOString().split('T')[0] + 'T09:00';
                    
                    // Calculate new due date
                    const duration = task.taskDuration || 1;
                    const durationType = task.taskDurationType || 'days';
                    let dueDate = new Date(newStartDate);
                    
                    switch(durationType) {
                        case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                        case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                        case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                        case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                    }
                    task.taskDateDue = dueDate.toISOString().split('T')[0] + 'T18:00';
                    
                    // Recursively update tasks that depend on this task
                    cascadeUpdateDependentTasks(task.id, visitedIds);
                }
            });
        }
        
        // Initialize drag handlers for timeline bars
        function initTimelineDragHandlers() {
            const bars = document.querySelectorAll('.timeline-node-bar.draggable-bar');
            
            bars.forEach(bar => {
                let isDragging = false;
                let startX = 0;
                let originalLeft = 0;
                const taskId = bar.dataset.taskId;
                
                bar.style.cursor = 'grab';
                
                bar.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return; // Only left click
                    isDragging = true;
                    startX = e.clientX;
                    originalLeft = parseFloat(bar.style.left) || 0;
                    bar.style.cursor = 'grabbing';
                    bar.style.opacity = '0.8';
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const deltaX = e.clientX - startX;
                    const newLeft = Math.max(0, originalLeft + deltaX);
                    bar.style.left = newLeft + 'px';
                });
                
                document.addEventListener('mouseup', (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    bar.style.cursor = 'grab';
                    bar.style.opacity = '1';
                    
                    // Check if position actually changed
                    const newLeft = parseFloat(bar.style.left) || 0;
                    if (Math.abs(newLeft - originalLeft) < 5) return; // No significant change
                    
                    const task = nodes.find(n => n.id === taskId);
                    if (task) {
                        // Get timeline info
                        const tracksCol = document.getElementById('taskManagerTracksScroll');
                        if (tracksCol) {
                            const totalWidth = tracksCol.scrollWidth;
                            const ratio = newLeft / totalWidth;
                            
                            // Get date range from current view
                            const today = new Date();
                            const allTaskNodes = nodes.filter(n => n.isTaskNode === true);
                            let minDate = new Date(today);
                            let maxDate = new Date(today);
                            
                            allTaskNodes.forEach(t => {
                                if (t.taskDateStart) {
                                    const start = new Date(t.taskDateStart);
                                    if (start < minDate) minDate = new Date(start);
                                }
                                if (t.taskDateDue) {
                                    const due = new Date(t.taskDateDue);
                                    if (due > maxDate) maxDate = new Date(due);
                                }
                            });
                            
                            // Extend range based on scale
                            minDate.setDate(minDate.getDate() - 7);
                            maxDate.setDate(maxDate.getDate() + 30);
                            
                            const totalMs = maxDate.getTime() - minDate.getTime();
                            const newDateMs = minDate.getTime() + (ratio * totalMs);
                            const newDate = new Date(newDateMs);
                            
                            // MS PROJECT LOGIC: If task has dependencies, dates should be calculated from parent task
                            // Dependent tasks cannot have their dates manually changed - they must follow parent task
                            const hasDependencies = task.taskDependencies && task.taskDependencies.length > 0;
                            
                            if (hasDependencies) {
                                // Task has dependencies - calculate dates from parent task based on dependency type
                                // This prevents dependent tasks from being manually dragged away from their parent
                                const primaryDep = task.taskDependencies[0];
                                const parentTask = nodes.find(n => String(n.id) === String(primaryDep.taskId));
                                
                                if (parentTask) {
                                    const depType = primaryDep.type || 'FS';
                                    const lag = primaryDep.lag || 0;
                                    const lagUnit = primaryDep.lagUnit || 'days';
                                    
                                    // Calculate lag in milliseconds
                                    let lagMs = 0;
                                    switch(lagUnit) {
                                        case 'minutes': lagMs = lag * 60 * 1000; break;
                                        case 'hours': lagMs = lag * 60 * 60 * 1000; break;
                                        case 'days': lagMs = lag * 24 * 60 * 60 * 1000; break;
                                        case 'weeks': lagMs = lag * 7 * 24 * 60 * 60 * 1000; break;
                                        case 'months': lagMs = lag * 30 * 24 * 60 * 60 * 1000; break;
                                    }
                                    
                                    const parentStart = parentTask.taskDateStart ? new Date(parentTask.taskDateStart) : null;
                                    const parentEnd = parentTask.taskDateDue ? new Date(parentTask.taskDateDue) : null;
                                    
                                    // Calculate dates based on dependency type (MS Project logic)
                                    switch(depType) {
                                        case 'SS': // Start-to-Start: This task starts when parent starts
                                            if (parentStart) {
                                                const newStart = new Date(parentStart.getTime() + lagMs);
                                                task.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                                // Calculate end date based on duration
                                                const duration = task.taskDuration || 1;
                                                const durationType = task.taskDurationType || 'days';
                                                let dueDate = new Date(newStart);
                                                switch(durationType) {
                                                    case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                                    case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                                    case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                                    case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                                }
                                                task.taskDateDue = dueDate.toISOString().split('T')[0] + 'T18:00';
                                            }
                                            break;
                                        case 'FF': // Finish-to-Finish: This task finishes when parent finishes
                                            if (parentEnd) {
                                                const newEnd = new Date(parentEnd.getTime() + lagMs);
                                                task.taskDateDue = newEnd.toISOString().split('T')[0] + 'T18:00';
                                                // Calculate start date based on duration (backwards from end)
                                                const duration = task.taskDuration || 1;
                                                const durationType = task.taskDurationType || 'days';
                                                let durationMs = duration * 24 * 60 * 60 * 1000;
                                                if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                                const newStart = new Date(newEnd.getTime() - durationMs);
                                                task.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                            }
                                            break;
                                        case 'FS': // Finish-to-Start: This task starts after parent finishes
                                            if (parentEnd) {
                                                const newStart = new Date(parentEnd.getTime() + lagMs);
                                                task.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                                // Calculate end date based on duration
                                                const duration = task.taskDuration || 1;
                                                const durationType = task.taskDurationType || 'days';
                                                let dueDate = new Date(newStart);
                                                switch(durationType) {
                                                    case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                                    case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                                    case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                                    case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                                }
                                                task.taskDateDue = dueDate.toISOString().split('T')[0] + 'T18:00';
                                            }
                                            break;
                                        case 'SF': // Start-to-Finish: This task finishes when parent starts
                                            if (parentStart) {
                                                const newEnd = new Date(parentStart.getTime() + lagMs);
                                                task.taskDateDue = newEnd.toISOString().split('T')[0] + 'T18:00';
                                                // Calculate start date based on duration (backwards from end)
                                                const duration = task.taskDuration || 1;
                                                const durationType = task.taskDurationType || 'days';
                                                let durationMs = duration * 24 * 60 * 60 * 1000;
                                                if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                                const newStart = new Date(newEnd.getTime() - durationMs);
                                                task.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                            }
                                            break;
                                    }
                                    
                                    // Show warning that dependent task dates are calculated from parent
                                    showToast(`‚ö†Ô∏è Bu task baƒüƒ±mlƒ±lƒ±ƒüa sahip - tarihler parent task'a g√∂re otomatik hesaplandƒ±`, 'warning');
                                } else {
                                    // Parent task not found, allow manual drag
                                    const newStartDate = newDate.toISOString().split('T')[0] + 'T09:00';
                                    const duration = task.taskDuration || 1;
                                    const durationType = task.taskDurationType || 'days';
                                    let dueDate = new Date(newDate);
                                    switch(durationType) {
                                        case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                        case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                        case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                        case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                    }
                                    const newDueDate = dueDate.toISOString().split('T')[0] + 'T18:00';
                                    task.taskDateStart = newStartDate;
                                    task.taskDateDue = newDueDate;
                                }
                            } else {
                                // No dependencies - allow manual drag (independent task)
                                const newStartDate = newDate.toISOString().split('T')[0] + 'T09:00';
                                
                                // Calculate new due date based on duration
                                const duration = task.taskDuration || 1;
                                const durationType = task.taskDurationType || 'days';
                                let dueDate = new Date(newDate);
                                
                                switch(durationType) {
                                    case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                    case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                    case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                    case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                }
                                const newDueDate = dueDate.toISOString().split('T')[0] + 'T18:00';
                                
                                // Apply changes immediately (no pending state)
                                task.taskDateStart = newStartDate;
                                task.taskDateDue = newDueDate;
                            }
                            
                            // MS PROJECT LOGIC: Only cascade update dependent tasks if this task has NO dependencies
                            // If this task has dependencies, it's a dependent task and should not cascade update
                            // Only independent tasks or parent tasks should cascade update their dependents
                            if (!hasDependencies && typeof cascadeUpdateDependentTasks === 'function') {
                                cascadeUpdateDependentTasks(taskId);
                            }
                            
                            // Save immediately
                            saveToLocalStorage();
                            
                            // Refresh all timelines immediately
                            refreshAllTaskViews();
                            // Also refresh main page timeline if visible
                            if (timelineBarVisible && typeof renderTimelineBar === 'function') {
                                renderTimelineBar();
                            }
                            
                            // Update properties panel if it's showing this task or any dependent task
                            if (propEditingNodeId && typeof updatePropertiesPanel === 'function') {
                                const propNode = nodes.find(n => n.id === propEditingNodeId);
                                if (propNode) {
                                    // Check if properties panel is showing the dragged task or a dependent task
                                    if (String(propEditingNodeId) === String(taskId)) {
                                        // Update properties panel for the dragged task
                                        updatePropertiesPanel(taskId);
                                    } else if (propNode.taskDependencies && propNode.taskDependencies.some(dep => String(dep.taskId) === String(taskId))) {
                                        // Update properties panel if it's showing a task that depends on the dragged task
                                        updatePropertiesPanel(propEditingNodeId);
                                    }
                                }
                            }
                            
                            // Also update properties panel if selectedNode matches
                            if (selectedNode && typeof updatePropertiesPanel === 'function') {
                                const selectedNodeObj = nodes.find(n => n.id === selectedNode);
                                if (selectedNodeObj) {
                                    if (String(selectedNode) === String(taskId)) {
                                        updatePropertiesPanel(taskId);
                                    } else if (selectedNodeObj.taskDependencies && selectedNodeObj.taskDependencies.some(dep => String(dep.taskId) === String(taskId))) {
                                        updatePropertiesPanel(selectedNode);
                                    }
                                }
                            }
                            
                            showToast(`‚úì ${task.title} tarihleri g√ºncellendi`);
                        }
                    }
                });
                
                // NOTE: Zoom on click is disabled for Task Manager timeline
                // Zoom functionality is only available on the main page timeline
                // Single click opens task editor instead (if needed, can be re-enabled)
                // bar.addEventListener('click', (e) => {
                //     if (Math.abs(e.clientX - startX) < 5) {
                //         zoomToTaskOnCanvas(taskId);
                //     }
                // });
            });
        }
        
        // Zoom to task on canvas when clicked in timeline
        function zoomToTaskOnCanvas(taskId) {
            // Use focusNode for consistent behavior (same as outline click)
            if (typeof focusNode === 'function') {
                focusNode(taskId);
                return;
            }
            
            // Fallback to old behavior if focusNode doesn't exist
            const task = nodes.find(n => n.id === taskId);
            if (!task) return;
            
            // Close task manager modal
            closeModal('taskManagerModal');
            
            // Zoom to task position on canvas
            setTimeout(() => {
                const nodeEl = document.querySelector(`.canvas-node[data-id="${taskId}"]`);
                if (nodeEl) {
                    // Get node position
                    const x = task.x || 100;
                    const y = task.y || 100;
                    
                    // Center the canvas on this node
                    const canvas = document.getElementById('canvas');
                    const container = document.getElementById('canvasContainer');
                    if (canvas && container) {
                        const containerRect = container.getBoundingClientRect();
                        const centerX = containerRect.width / 2;
                        const centerY = containerRect.height / 2;
                        
                        // Calculate offset to center node
                        canvasOffset.x = centerX - (x * zoomLevel);
                        canvasOffset.y = centerY - (y * zoomLevel);
                        
                        // Set zoom to 100% if too zoomed out
                        if (zoomLevel < 0.8) {
                            zoomLevel = 1;
                            updateZoomDisplay();
                        }
                        
                        applyTransform();
                        
                        // Highlight the node
                        selectNode(taskId);
                        nodeEl.style.animation = 'pulse 0.5s ease-in-out 3';
                        setTimeout(() => { nodeEl.style.animation = ''; }, 1500);
                    }
                }
                showToast(`üéØ ${task.title} konumuna gidildi`);
            }, 300);
        }
        
        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }
        
        function isSameDay(d1, d2) {
            return d1.getFullYear() === d2.getFullYear() &&
                   d1.getMonth() === d2.getMonth() &&
                   d1.getDate() === d2.getDate();
        }

        // ============ TASK MANAGEMENT FUNCTIONS ============
        function openTaskManager(filterStatus = null) {
            currentTaskFilter = filterStatus;
            currentTaskViewMode = 'list'; // Reset to list view
            toggleTaskView('list');
            renderTaskList();
            renderTaskManagerSidebar();
            updateTaskFilterButtons();
            openModal('taskManagerModal');
        }
        
        // Render the left sidebar with nodes that have tasks
        function renderTaskManagerSidebar() {
            const container = document.getElementById('taskManagerNodeList');
            if (!container) return;
            
            const allTaskTypes = getAllTaskTypes();
            
            // Get all task nodes
            const taskNodes = nodes.filter(n => n.isTaskNode || allTaskTypes[n.type]);
            
            // Get all content nodes that have tasks linked to them
            const contentNodes = nodes.filter(n => !n.isTaskNode && !allTaskTypes[n.type]);
            
            // Build node list with their connected tasks
            const nodeTaskMap = new Map();
            
            // Group tasks by their parent/linked node
            taskNodes.forEach(task => {
                const parentId = task.parentId || task.linkedNodeIds?.[0];
                if (parentId) {
                    if (!nodeTaskMap.has(parentId)) {
                        nodeTaskMap.set(parentId, []);
                    }
                    nodeTaskMap.get(parentId).push(task);
                }
            });
            
            let html = '';
            
            // Show "All Tasks" option
            html += `
                <div class="tm-sidebar-item ${!currentSidebarNodeFilter ? 'active' : ''}" onclick="filterTasksByNode(null)" style="margin-bottom:10px;">
                    <div class="tm-sidebar-icon" style="background:#8b5cf6;">üìã</div>
                    <div class="tm-sidebar-info">
                        <div class="tm-sidebar-title">T√ºm G√∂revler</div>
                        <div class="tm-sidebar-count">${taskNodes.length} g√∂rev</div>
                    </div>
                </div>
            `;
            
            // Divider
            html += '<div style="border-bottom:1px solid #333; margin:10px 0;"></div>';
            html += '<div style="font-size:10px; color:#666; text-transform:uppercase; padding:5px 0; margin-bottom:5px;">Baƒülƒ± Node\'lar</div>';
            
            // Show content nodes with task counts
            contentNodes.forEach(node => {
                const linkedTasks = nodeTaskMap.get(node.id) || [];
                const taskCount = linkedTasks.length;
                
                // Also count tasks that are connected via connections
                const connectedTasks = taskNodes.filter(t => {
                    return connections.some(c => 
                        (c.from === t.id && c.to === node.id) || 
                        (c.from === node.id && c.to === t.id)
                    );
                });
                
                const totalTasks = new Set([...linkedTasks.map(t => t.id), ...connectedTasks.map(t => t.id)]).size;
                
                if (totalTasks > 0) {
                    const nodeIcon = getNodeTypeIcon(node.type);
                    html += `
                        <div class="tm-sidebar-item ${currentSidebarNodeFilter === node.id ? 'active' : ''}" 
                             onclick="filterTasksByNode('${node.id}'); if(typeof focusNode === 'function') { focusNode('${node.id}'); }"
                             ondblclick="if(typeof openFullEditor === 'function') { openFullEditor('${node.id}'); } else if(typeof openTaskNodeEditor === 'function' && nodes.find(n => n.id === '${node.id}')?.isTaskNode) { openTaskNodeEditor('${node.id}'); }"
                             style="cursor:pointer;"
                             title="Filtrelemek i√ßin tƒ±klayƒ±n, d√ºzenlemek i√ßin √ßift tƒ±klayƒ±n">
                            <div class="tm-sidebar-icon" style="background:${node.color || '#3b82f6'};">${nodeIcon}</div>
                            <div class="tm-sidebar-info">
                                <div class="tm-sidebar-title">${sanitizeText(node.title)}</div>
                                <div class="tm-sidebar-count">${totalTasks} g√∂rev</div>
                            </div>
                        </div>
                    `;
                }
            });
            
            // Show orphan tasks section
            const orphanTasks = taskNodes.filter(t => !t.parentId && (!t.linkedNodeIds || t.linkedNodeIds.length === 0));
            if (orphanTasks.length > 0) {
                html += `
                    <div style="border-top:1px solid #333; margin-top:10px; padding-top:10px;">
                        <div class="tm-sidebar-item ${currentSidebarNodeFilter === 'orphan' ? 'active' : ''}" onclick="filterTasksByNode('orphan')">
                            <div class="tm-sidebar-icon" style="background:#666;">üìå</div>
                            <div class="tm-sidebar-info">
                                <div class="tm-sidebar-title">Baƒüƒ±msƒ±z G√∂revler</div>
                                <div class="tm-sidebar-count">${orphanTasks.length} g√∂rev</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        let currentSidebarNodeFilter = null;
        
        // Filter tasks by selected node in sidebar
        function filterTasksByNode(nodeId) {
            currentSidebarNodeFilter = nodeId;
            renderTaskManagerSidebar();
            renderTaskList();
            refreshTimelineIfVisible();
        }

        function toggleNewTaskDropdown() {
            const dropdown = document.getElementById('newTaskDropdown');
            if (dropdown.style.display === 'none') {
                populateNewTaskDropdown();
                dropdown.style.display = 'block';
            } else {
                dropdown.style.display = 'none';
            }
        }

        function hideNewTaskDropdown() {
            document.getElementById('newTaskDropdown').style.display = 'none';
        }

        function populateNewTaskDropdown() {
            const dropdown = document.getElementById('newTaskDropdown');
            const allTypes = getAllTaskTypes();

            let html = '';
            Object.entries(allTypes).forEach(([typeId, typeInfo]) => {
                html += `<div onclick="addTaskNode('${typeId}'); hideNewTaskDropdown();" style="padding:10px 15px; cursor:pointer; border-bottom:1px solid #333; color:#fff; display:flex; align-items:center; gap:8px;">
                    <span>${typeInfo.icon}</span> ${typeInfo.name}
                </div>`;
            });

            // Add separator and manage option
            html += `<div style="border-top:2px solid #8b5cf6; margin-top:5px;"></div>`;
            html += `<div onclick="openTaskTypeManager(); hideNewTaskDropdown();" style="padding:10px 15px; cursor:pointer; color:#8b5cf6; display:flex; align-items:center; gap:8px;">
                <span>‚öô</span> Tipleri Yonet...
            </div>`;

            dropdown.innerHTML = html;
        }

        function openTaskEditor(taskId = null, preselectedNodeId = null) {
            document.getElementById('editingTaskId').value = taskId || '';
            document.getElementById('taskEditorTitle').textContent = taskId ? '‚úèÔ∏è Edit Task' : '‚ûï New Task';

            // Populate node select dropdown
            populateTaskNodeSelect();

            if (taskId) {
                const task = tasks.find(t => t.id === taskId);
                if (task) {
                    document.getElementById('taskTitle').value = task.title || '';
                    document.getElementById('taskDescription').value = task.description || '';
                    document.getElementById('taskStatus').value = task.status || 'todo';
                    document.getElementById('taskImportance').value = task.importance || 'medium';
                    document.getElementById('taskAssignedBy').value = task.assignedBy || '';
                    document.getElementById('taskProgress').value = task.progress || 0;
                    document.getElementById('taskDuration').value = task.duration || 1;
                    document.getElementById('taskDurationType').value = task.durationType || 'hours';
                    document.getElementById('taskDateStart').value = task.dateStart || '';
                    document.getElementById('taskDateEstimated').value = task.dateEstimated || '';
                    document.getElementById('taskAssignedNode').value = task.assignedNodeId || '';
                }
            } else {
                // Reset form for new task
                document.getElementById('taskTitle').value = '';
                document.getElementById('taskDescription').value = '';
                document.getElementById('taskStatus').value = 'todo';
                document.getElementById('taskImportance').value = 'medium';
                document.getElementById('taskAssignedBy').value = '';
                document.getElementById('taskProgress').value = 0;
                document.getElementById('taskDuration').value = 1;
                document.getElementById('taskDurationType').value = 'hours';
                document.getElementById('taskDateStart').value = new Date().toISOString().slice(0, 16);
                document.getElementById('taskDateEstimated').value = '';
                document.getElementById('taskAssignedNode').value = preselectedNodeId || '';
            }

            openModal('taskEditorModal');
        }

        function populateTaskNodeSelect() {
            const select = document.getElementById('taskAssignedNode');
            select.innerHTML = '<option value="">‚Äî Node Yok (Baƒüƒ±msƒ±z Task) ‚Äî</option>';
            
            const allTaskTypes = getAllTaskTypes();

            // Add regular content nodes first
            const regularNodes = nodes.filter(n => !n.isTaskNode && !TASK_NODE_TYPES[n.type]);
            if (regularNodes.length > 0) {
                const contentGroup = document.createElement('optgroup');
                contentGroup.label = 'üìÑ ƒ∞√ßerik Node\'larƒ±';
                regularNodes.forEach(node => {
                    const option = document.createElement('option');
                    option.value = node.id;
                    option.textContent = `${getNodeTypeIcon(node.type)} ${node.title}`;
                    contentGroup.appendChild(option);
                });
                select.appendChild(contentGroup);
            }
            
            // Add task nodes
            const taskNodes = nodes.filter(n => n.isTaskNode || TASK_NODE_TYPES[n.type]);
            if (taskNodes.length > 0) {
                const taskGroup = document.createElement('optgroup');
                taskGroup.label = 'üìã Task Node\'larƒ±';
                taskNodes.forEach(node => {
                    const typeInfo = allTaskTypes[node.type] || { icon: '‚ñ¢', name: 'Task' };
                    const option = document.createElement('option');
                    option.value = node.id;
                    option.textContent = `${typeInfo.icon} ${node.title}`;
                    taskGroup.appendChild(option);
                });
                select.appendChild(taskGroup);
            }
        }

        // ============ TASK DEPENDENCY FUNCTIONS ============
        // Dependency Types: FS (Finish-to-Start), SS (Start-to-Start), FF (Finish-to-Finish), SF (Start-to-Finish)
        const DEPENDENCY_TYPES = {
            'FS': { name: 'Finish-to-Start', desc: 'Task B ba≈ülamadan √∂nce Task A bitmeli', icon: '‚Üí' },
            'SS': { name: 'Start-to-Start', desc: 'Task A ba≈üladƒ±ƒüƒ±nda Task B de ba≈ülayabilir', icon: '‚áí' },
            'FF': { name: 'Finish-to-Finish', desc: 'Task A bittiƒüinde Task B de bitmeli', icon: '‚áî' },
            'SF': { name: 'Start-to-Finish', desc: 'Task A ba≈üladƒ±ƒüƒ±nda Task B bitmeli', icon: '‚Üê' }
        };

        const LAG_UNITS = [
            { id: 'hours', name: 'Saat', multiplier: 1 },
            { id: 'days', name: 'G√ºn', multiplier: 24 },
            { id: 'weeks', name: 'Hafta', multiplier: 168 },
            { id: 'months', name: 'Ay', multiplier: 720 },
            { id: 'years', name: 'Yƒ±l', multiplier: 8760 }
        ];

        // Temporary storage for dependencies being edited
        let tempTaskDependencies = [];

        function renderTaskDependencies(nodeId) {
            const container = document.getElementById('taskDependenciesList');
            if (!container) {
                console.warn('taskDependenciesList container not found');
                return;
            }

            const nId = String(nodeId);
            const node = nodes.find(n => String(n.id) === nId);
            if (!node) {
                console.warn('Node not found for ID:', nodeId);
                return;
            }

            // Initialize temp dependencies from node
            // Make sure taskDependencies exists and is an array
            if (node.taskDependencies && Array.isArray(node.taskDependencies)) {
                tempTaskDependencies = [...node.taskDependencies];
            } else {
                tempTaskDependencies = [];
            }
            
            console.log('Rendering dependencies for node:', nId, 'Found dependencies:', tempTaskDependencies.length);

            // Get successors (tasks that depend on this node)
            const successors = [];
            nodes.forEach(n => {
                if (n.taskDependencies) {
                    const dep = n.taskDependencies.find(d => String(d.taskId) === String(nodeId));
                    if (dep) {
                        successors.push({
                            node: n,
                            type: dep.type || 'FS',
                            lag: dep.lag || 0,
                            lagUnit: dep.lagUnit || 'days'
                        });
                    }
                }
            });

            if (tempTaskDependencies.length === 0 && successors.length === 0) {
                container.innerHTML = '<p style="color:#666; font-size:12px; text-align:center; padding:15px;">Hen√ºz baƒüƒ±mlƒ±lƒ±k yok</p>';
                return;
            }

            // Get all task nodes for dropdown
            const allTaskTypes = getAllTaskTypes();
            const taskNodes = nodes.filter(n => (n.isTaskNode || allTaskTypes[n.type]) && n.id !== nodeId);

            let html = '';

            // √úST BAƒûIMLILAR (Predecessors)
            if (tempTaskDependencies.length > 0) {
                html += '<div style="font-size:11px; color:#22c55e; margin-bottom:8px; font-weight:bold; display:flex; align-items:center; gap:5px;"><span style="font-size:14px;">‚Üë</span> √úST BAƒûIMLILAR (Bu task\'ƒ±n beklediƒüi)</div>';

                tempTaskDependencies.forEach((dep, index) => {
                    const depTask = nodes.find(n => String(n.id) === String(dep.taskId));
                    if (!depTask) return;

                    const typeInfo = allTaskTypes[depTask.type] || { icon: 'üìã' };
                    const currentLag = dep.lag || 0;
                    const currentLagUnit = dep.lagUnit || 'days';

                    html += `
                        <div style="display:flex; align-items:center; gap:8px; padding:8px 10px; background:rgba(34,197,94,0.1); border:1px solid rgba(34,197,94,0.3); border-radius:6px; margin-bottom:6px;">
                            <span style="font-size:16px;">${typeInfo.icon}</span>
                            <div style="flex:1; min-width:0; overflow:hidden;">
                                <div style="font-size:12px; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${depTask.title}</div>
                            </div>
                            <span style="font-size:10px; color:#888;">Gecikme:</span>
                            <input type="number" value="${currentLag}" onchange="updateDependencyLag(${index}, this.value)" style="width:45px; padding:4px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:11px; text-align:center;">
                            <select onchange="updateDependencyLagUnit(${index}, this.value)" style="width:60px; padding:4px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:10px;">
                                <option value="hours" ${currentLagUnit === 'hours' ? 'selected' : ''}>Saat</option>
                                <option value="days" ${currentLagUnit === 'days' ? 'selected' : ''}>G√ºn</option>
                                <option value="weeks" ${currentLagUnit === 'weeks' ? 'selected' : ''}>Hafta</option>
                                <option value="months" ${currentLagUnit === 'months' ? 'selected' : ''}>Ay</option>
                            </select>
                            <select onchange="updateDependencyType(${index}, this.value)" style="width:50px; padding:4px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:11px; font-weight:bold;">
                                ${Object.keys(DEPENDENCY_TYPES).map(key => `<option value="${key}" ${key === dep.type ? 'selected' : ''}>${key}</option>`).join('')}
                            </select>
                            <button onclick="removeDependency(${index})" style="background:#ef4444; color:#fff; border:none; width:24px; height:24px; border-radius:4px; cursor:pointer; font-size:11px;">√ó</button>
                        </div>
                    `;
                });
            }

            // ALT BAƒûIMLILAR (Successors)
            if (successors.length > 0) {
                html += '<div style="font-size:11px; color:#f59e0b; margin-top:15px; margin-bottom:8px; font-weight:bold; display:flex; align-items:center; gap:5px;"><span style="font-size:14px;">‚Üì</span> ALT BAƒûIMLILAR (Bu task\'ƒ± bekleyen)</div>';

                successors.forEach((succ) => {
                    const typeInfo = allTaskTypes[succ.node.type] || { icon: 'üìã' };
                    const currentLag = succ.lag || 0;
                    const currentLagUnit = succ.lagUnit || 'days';
                    html += `
                        <div style="display:flex; align-items:center; gap:8px; padding:8px 10px; background:rgba(245,158,11,0.1); border:1px solid rgba(245,158,11,0.3); border-radius:6px; margin-bottom:6px;">
                            <span style="font-size:16px;">${typeInfo.icon}</span>
                            <div style="flex:1; min-width:0; overflow:hidden;">
                                <div style="font-size:12px; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${succ.node.title}</div>
                            </div>
                            <span style="font-size:10px; color:#888;">Gecikme:</span>
                            <input type="number" value="${currentLag}" onchange="updateSuccessorLag('${succ.node.id}', '${nId}', this.value)" style="width:45px; padding:4px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:11px; text-align:center;">
                            <select onchange="updateSuccessorLagUnit('${succ.node.id}', '${nId}', this.value)" style="width:60px; padding:4px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:10px;">
                                <option value="hours" ${currentLagUnit === 'hours' ? 'selected' : ''}>Saat</option>
                                <option value="days" ${currentLagUnit === 'days' ? 'selected' : ''}>G√ºn</option>
                                <option value="weeks" ${currentLagUnit === 'weeks' ? 'selected' : ''}>Hafta</option>
                                <option value="months" ${currentLagUnit === 'months' ? 'selected' : ''}>Ay</option>
                            </select>
                            <select onchange="updateSuccessorDependencyType('${succ.node.id}', '${nId}', this.value)" style="width:50px; padding:4px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:11px; font-weight:bold;">
                                ${Object.keys(DEPENDENCY_TYPES).map(key => `<option value="${key}" ${key === succ.type ? 'selected' : ''}>${key}</option>`).join('')}
                            </select>
                            <button onclick="removeSuccessorDependency('${succ.node.id}', '${nId}')" style="background:#ef4444; color:#fff; border:none; width:24px; height:24px; border-radius:4px; cursor:pointer; font-size:11px;">√ó</button>
                        </div>
                    `;
                });
            }

            container.innerHTML = html;
        }

        // Add dependency from the new select dropdown
        function addTaskDependencyFromSelect() {
            const taskIdInput = document.getElementById('editingTaskId');
            if (!taskIdInput || !taskIdInput.value) return;

            const nodeId = taskIdInput.value.replace('node:', '');
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            const selectEl = document.getElementById('newDependencyTaskSelect');
            const typeEl = document.getElementById('newDependencyType');

            if (!selectEl || !selectEl.value) {
                showToast('L√ºtfen bir task se√ßin', 'error');
                return;
            }

            const newDepTaskId = selectEl.value;
            const depType = typeEl?.value || 'FS';

            // Check if already exists
            const alreadyExists = tempTaskDependencies.some(d => String(d.taskId) === String(newDepTaskId));
            if (alreadyExists) {
                showToast('Bu baƒüƒ±mlƒ±lƒ±k zaten mevcut', 'error');
                return;
            }

            const newDep = {
                taskId: newDepTaskId,
                type: depType,
                lag: 0,
                lagUnit: 'days'
            };
            tempTaskDependencies.push(newDep);

            // Save to node immediately
            node.taskDependencies = [...tempTaskDependencies];

            // Also create connection if not exists
            const connExists = connections.some(c =>
                (String(c.from) === String(newDepTaskId) && String(c.to) === String(nodeId)) ||
                (String(c.from) === String(nodeId) && String(c.to) === String(newDepTaskId))
            );
            if (!connExists) {
                connections.push({ from: newDepTaskId, to: nodeId, dependencyType: depType });
            }

            // Update dates based on dependency
            updateTaskDatesFromDependency(nodeId);

            // Reset select
            selectEl.value = '';

            renderConnections();
            renderTaskDependencies(nodeId);
            populateDependencyTaskSelect(nodeId);
            saveToLocalStorage();
            refreshTimelineIfVisible();
            showToast(`‚úì ${depType} baƒüƒ±mlƒ±lƒ±k eklendi`);
        }

        // Populate the dependency task select dropdown
        function populateDependencyTaskSelect(currentNodeId) {
            const selectEl = document.getElementById('newDependencyTaskSelect');
            if (!selectEl) return;

            const allTaskTypes = getAllTaskTypes();
            const taskNodes = nodes.filter(n =>
                (n.isTaskNode || allTaskTypes[n.type]) &&
                String(n.id) !== String(currentNodeId) &&
                !tempTaskDependencies.some(d => String(d.taskId) === String(n.id))
            );

            selectEl.innerHTML = '<option value="">‚Äî Baƒüƒ±mlƒ± Task Se√ß ‚Äî</option>';
            taskNodes.forEach(n => {
                const typeInfo = allTaskTypes[n.type] || { icon: 'üìã', name: 'Task' };
                selectEl.innerHTML += `<option value="${n.id}">${typeInfo.icon} ${n.title}</option>`;
            });
        }

        function addTaskDependency() {
            // Legacy function - now redirects to the select-based add
            const taskIdInput = document.getElementById('editingTaskId');
            if (!taskIdInput || !taskIdInput.value) return;

            const nodeId = taskIdInput.value.replace('node:', '');
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Get all other task nodes
            const allTaskTypes = getAllTaskTypes();
            const taskNodes = nodes.filter(n => (n.isTaskNode || allTaskTypes[n.type]) && n.id !== nodeId);

            if (taskNodes.length === 0) {
                showToast('Ba≈üka task node bulunamadƒ±');
                return;
            }

            // Add new dependency with first available task
            const newDepTaskId = taskNodes[0].id;

            // Check if already exists
            if (tempTaskDependencies.some(d => String(d.taskId) === String(newDepTaskId))) {
                showToast('T√ºm task\'lar zaten baƒüƒ±mlƒ±lƒ±k listesinde');
                return;
            }

            const newDep = {
                taskId: newDepTaskId,
                type: 'FS',
                lag: 0,
                lagUnit: 'days'
            };
            tempTaskDependencies.push(newDep);

            // Save to node immediately
            node.taskDependencies = [...tempTaskDependencies];

            // Also create connection if not exists
            const connExists = connections.some(c => String(c.from) === String(newDepTaskId) && String(c.to) === String(nodeId));
            if (!connExists) {
                connections.push({ from: newDepTaskId, to: nodeId, dependencyType: 'FS' });
            }

            // Update dates based on dependency
            updateTaskDatesFromDependency(nodeId);

            renderConnections();
            renderTaskDependencies(nodeId);
            populateDependencyTaskSelect(nodeId);
            saveToLocalStorage();
            showToast('Baƒüƒ±mlƒ±lƒ±k eklendi');
        }

        function updateDependencyTask(index, taskId) {
            if (tempTaskDependencies[index]) {
                const oldTaskId = tempTaskDependencies[index].taskId;
                tempTaskDependencies[index].taskId = taskId;

                // Update connection and save to node
                const taskIdInput = document.getElementById('editingTaskId');
                if (taskIdInput && taskIdInput.value) {
                    const nodeId = taskIdInput.value.replace('node:', '');
                    const node = nodes.find(n => n.id === nodeId);

                    // Save to node immediately
                    if (node) {
                        node.taskDependencies = [...tempTaskDependencies];
                    }

                    // Remove old connection
                    connections = connections.filter(c => !(c.from === oldTaskId && c.to === nodeId));

                    // Add new connection if not exists
                    const connExists = connections.some(c => c.from === taskId && c.to === nodeId);
                    if (!connExists) {
                        connections.push({ from: taskId, to: nodeId, fp: 'bottom', tp: 'top' });
                    }

                    // Update dates based on new dependency
                    updateTaskDatesFromDependency(nodeId);

                    renderConnections();
                }
            }
        }

        function updateDependencyType(index, type) {
            if (!tempTaskDependencies[index]) return;

            const depTaskId = tempTaskDependencies[index].taskId;
            tempTaskDependencies[index].type = type;

            // Get current editing node
            const taskIdInput = document.getElementById('editingTaskId');
            if (!taskIdInput || !taskIdInput.value) return;

            const nodeId = taskIdInput.value.replace('node:', '');
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;

            // Update node's taskDependencies directly (find and update the specific dependency)
            if (node.taskDependencies) {
                const nodeDep = node.taskDependencies.find(d => String(d.taskId) === String(depTaskId));
                if (nodeDep) {
                    nodeDep.type = type;
                }
            }

            // Update connections array - ensure connection exists and has correct type
            let conn = connections.find(c =>
                (String(c.from) === String(depTaskId) && String(c.to) === String(nodeId)) ||
                (String(c.from) === String(nodeId) && String(c.to) === String(depTaskId))
            );
            if (conn) {
                conn.dependencyType = type;
            } else {
                // Connection doesn't exist, create it with same ID types as original
                conn = { from: depTaskId, to: node.id, dependencyType: type };
                connections.push(conn);
                // Re-render connections to show the new one
                renderConnections();
            }

            // Update dates based on new dependency type
            updateTaskDatesFromDependency(nodeId);

            // Update Properties Panel if open
            if (String(selectedNode) === String(nodeId)) {
                updatePropertiesPanel(nodeId);
            }

            saveToLocalStorage();
            showToast(`‚úì Baƒüƒ±mlƒ±lƒ±k tipi: ${type}`);
        }

        function updateDependencyLag(index, lag) {
            if (!tempTaskDependencies[index]) return;

            const depTaskId = tempTaskDependencies[index].taskId;
            const newLag = parseInt(lag) || 0;
            tempTaskDependencies[index].lag = newLag;

            // Get current editing node
            const taskIdInput = document.getElementById('editingTaskId');
            if (!taskIdInput || !taskIdInput.value) return;

            const nodeId = taskIdInput.value.replace('node:', '');
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;

            // Update node's taskDependencies directly
            if (node.taskDependencies) {
                const nodeDep = node.taskDependencies.find(d => String(d.taskId) === String(depTaskId));
                if (nodeDep) {
                    nodeDep.lag = newLag;
                }
            }

            // Update dates based on new lag
            updateTaskDatesFromDependency(nodeId);
            saveToLocalStorage();
            showToast(`‚úì Gecikme: ${newLag}`);
        }

        function updateDependencyLagUnit(index, unit) {
            if (!tempTaskDependencies[index]) return;

            const depTaskId = tempTaskDependencies[index].taskId;
            tempTaskDependencies[index].lagUnit = unit;

            // Get current editing node
            const taskIdInput = document.getElementById('editingTaskId');
            if (!taskIdInput || !taskIdInput.value) return;

            const nodeId = taskIdInput.value.replace('node:', '');
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;

            // Update node's taskDependencies directly
            if (node.taskDependencies) {
                const nodeDep = node.taskDependencies.find(d => String(d.taskId) === String(depTaskId));
                if (nodeDep) {
                    nodeDep.lagUnit = unit;
                }
            }

            // Update dates based on new lag unit
            updateTaskDatesFromDependency(nodeId);
            saveToLocalStorage();
            const unitNames = { hours: 'Saat', days: 'G√ºn', weeks: 'Hafta', months: 'Ay' };
            showToast(`‚úì Birim: ${unitNames[unit] || unit}`);
        }

        function removeDependency(index) {
            const removedDep = tempTaskDependencies[index];
            tempTaskDependencies.splice(index, 1);
            const taskIdInput = document.getElementById('editingTaskId');
            if (taskIdInput && taskIdInput.value) {
                const nodeId = taskIdInput.value.replace('node:', '');
                const node = nodes.find(n => String(n.id) === String(nodeId));

                // Save to node immediately
                if (node) {
                    node.taskDependencies = [...tempTaskDependencies];
                }

                // Also remove the connection if exists
                if (removedDep && removedDep.taskId) {
                    connections = connections.filter(c =>
                        !(String(c.from) === String(removedDep.taskId) && String(c.to) === String(nodeId)) &&
                        !(String(c.from) === String(nodeId) && String(c.to) === String(removedDep.taskId))
                    );
                }

                renderConnections();
                renderTaskDependencies(nodeId);
                saveToLocalStorage();
                showToast('‚úÇÔ∏è Baƒüƒ±mlƒ±lƒ±k silindi');
            }
        }

        // ============ UPDATE TASK DATES BASED ON DEPENDENCIES ============
        function updateTaskDatesFromDependency(nodeId) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node || !node.taskDependencies || node.taskDependencies.length === 0) return;

            // Get the first dependency (primary dependency)
            const dep = node.taskDependencies[0];
            const parentTask = nodes.find(n => String(n.id) === String(dep.taskId));
            if (!parentTask) return;

            const depType = dep.type || 'FS';
            const lag = dep.lag || 0;
            const lagUnit = dep.lagUnit || 'hours';

            // Get parent task dates
            const parentStart = parentTask.taskDateStart ? new Date(parentTask.taskDateStart) : null;
            const parentEnd = parentTask.taskDateDue ? new Date(parentTask.taskDateDue) : null;

            if (!parentStart && !parentEnd) return;

            // Calculate lag in milliseconds
            let lagMs = 0;
            switch (lagUnit) {
                case 'minutes': lagMs = lag * 60 * 1000; break;
                case 'hours': lagMs = lag * 60 * 60 * 1000; break;
                case 'days': lagMs = lag * 24 * 60 * 60 * 1000; break;
                case 'weeks': lagMs = lag * 7 * 24 * 60 * 60 * 1000; break;
                case 'months': lagMs = lag * 30 * 24 * 60 * 60 * 1000; break;
            }

            let newStart = null;
            let newEnd = null;

            // Calculate dates based on dependency type
            // IMPORTANT: SS tasks take parent's start date, FF tasks take parent's end date
            switch (depType) {
                case 'FS': // Finish-to-Start: This task starts when parent finishes
                    if (parentEnd) {
                        newStart = new Date(parentEnd.getTime() + lagMs);
                    }
                    break;
                case 'SS': // Start-to-Start: This task starts when parent starts (takes parent's start date)
                    if (parentStart) {
                        newStart = new Date(parentStart.getTime() + lagMs);
                    }
                    break;
                case 'FF': // Finish-to-Finish: This task finishes when parent finishes (takes parent's end date)
                    if (parentEnd) {
                        newEnd = new Date(parentEnd.getTime() + lagMs);
                    }
                    break;
                case 'SF': // Start-to-Finish: This task finishes when parent starts
                    if (parentStart) {
                        newEnd = new Date(parentStart.getTime() + lagMs);
                    }
                    break;
            }

            // Format date for datetime-local input
            function formatDate(date) {
                if (!date) return '';
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                const hours = String(date.getHours()).padStart(2, '0');
                const mins = String(date.getMinutes()).padStart(2, '0');
                return `${year}-${month}-${day}T${hours}:${mins}`;
            }

            // Update node dates
            if (newStart) {
                node.taskDateStart = formatDate(newStart);
                // If we have duration, calculate end date
                if (node.taskDuration && node.taskDurationType) {
                    const duration = node.taskDuration;
                    const durationType = node.taskDurationType;
                    let endDate = new Date(newStart);
                    switch (durationType) {
                        case 'minutes': endDate.setMinutes(endDate.getMinutes() + duration); break;
                        case 'hours': endDate.setHours(endDate.getHours() + duration); break;
                        case 'days': endDate.setDate(endDate.getDate() + duration); break;
                        case 'weeks': endDate.setDate(endDate.getDate() + (duration * 7)); break;
                        case 'months': endDate.setMonth(endDate.getMonth() + duration); break;
                    }
                    node.taskDateDue = formatDate(endDate);
                }
            }

            if (newEnd) {
                node.taskDateDue = formatDate(newEnd);
                // If we have duration, calculate start date backwards
                if (node.taskDuration && node.taskDurationType) {
                    const duration = node.taskDuration;
                    const durationType = node.taskDurationType;
                    let startDate = new Date(newEnd);
                    switch (durationType) {
                        case 'minutes': startDate.setMinutes(startDate.getMinutes() - duration); break;
                        case 'hours': startDate.setHours(startDate.getHours() - duration); break;
                        case 'days': startDate.setDate(startDate.getDate() - duration); break;
                        case 'weeks': startDate.setDate(startDate.getDate() - (duration * 7)); break;
                        case 'months': startDate.setMonth(startDate.getMonth() - duration); break;
                    }
                    node.taskDateStart = formatDate(startDate);
                }
            }

            // Re-render node to show updated dates
            renderNode(node);
        }

        // ============ ARRANGE TASKS BY DEPENDENCIES ============
        function arrangeTasksByDependencies() {
            saveUndoState('arrange tasks');

            const allTaskTypes = getAllTaskTypes();
            const taskNodes = nodes.filter(n => n.isTaskNode || allTaskTypes[n.type]);

            if (taskNodes.length === 0) {
                showToast('D√ºzenlenecek task bulunamadƒ±');
                return;
            }

            // Build dependency graph
            const graph = new Map();
            const inDegree = new Map();

            // Initialize
            taskNodes.forEach(task => {
                graph.set(task.id, []);
                inDegree.set(task.id, 0);
            });

            // Build edges based on dependencies
            taskNodes.forEach(task => {
                if (task.taskDependencies && task.taskDependencies.length > 0) {
                    task.taskDependencies.forEach(dep => {
                        // This task depends on dep.taskId
                        // So dep.taskId -> this task (this task comes after)
                        if (graph.has(dep.taskId)) {
                            graph.get(dep.taskId).push(task.id);
                            inDegree.set(task.id, (inDegree.get(task.id) || 0) + 1);
                        }
                    });
                }
            });

            // Topological sort using Kahn's algorithm
            const queue = [];
            const sorted = [];

            // Find all tasks with no dependencies (in-degree 0)
            taskNodes.forEach(task => {
                if (inDegree.get(task.id) === 0) {
                    queue.push(task.id);
                }
            });

            while (queue.length > 0) {
                const current = queue.shift();
                sorted.push(current);

                const dependents = graph.get(current) || [];
                dependents.forEach(depId => {
                    const newDegree = inDegree.get(depId) - 1;
                    inDegree.set(depId, newDegree);
                    if (newDegree === 0) {
                        queue.push(depId);
                    }
                });
            }

            // Add any remaining tasks (circular dependencies)
            taskNodes.forEach(task => {
                if (!sorted.includes(task.id)) {
                    sorted.push(task.id);
                }
            });

            // Arrange task nodes in a vertical layout
            const startX = 100;
            const startY = 100;
            const verticalGap = 180;
            const horizontalGap = 300;

            // Group by priority for horizontal arrangement
            const priorityOrder = ['critical', 'high', 'medium', 'low'];

            sorted.forEach((taskId, index) => {
                const task = nodes.find(n => n.id === taskId);
                if (task) {
                    task.x = startX;
                    task.y = startY + (index * verticalGap);
                }
            });

            renderAll();
            renderConnections();
            showToast(`${sorted.length} task baƒüƒ±mlƒ±lƒ±klara g√∂re sƒ±ralandƒ±`);
        }

        // ============ AUTO-CALCULATE DATE FUNCTIONS ============
        // Calculate End Date from Start Date + Duration
        function calculateEndDate() {
            const startInput = document.getElementById('taskDateStart');
            const durationInput = document.getElementById('taskDuration');
            const durationTypeSelect = document.getElementById('taskDurationType');
            const endInput = document.getElementById('taskDateEstimated');

            if (!startInput.value || !durationInput.value) return;

            const taskIdInput = document.getElementById('editingTaskId');
            const nodeId = taskIdInput && taskIdInput.value && taskIdInput.value.startsWith('node:') 
                ? taskIdInput.value.replace('node:', '') 
                : null;
            const node = nodeId ? nodes.find(n => String(n.id) === String(nodeId)) : null;
            
            // MS PROJECT LOGIC: If task has dependencies, dates should be calculated from parent task
            // Duration change should recalculate dates based on dependency type
            const hasDependencies = node && node.taskDependencies && node.taskDependencies.length > 0;
            
            if (hasDependencies && node) {
                // Task has dependencies - recalculate dates from parent task based on dependency type
                const primaryDep = node.taskDependencies[0];
                const parentTask = nodes.find(n => String(n.id) === String(primaryDep.taskId));
                
                if (parentTask) {
                    const depType = primaryDep.type || 'FS';
                    const lag = primaryDep.lag || 0;
                    const lagUnit = primaryDep.lagUnit || 'days';
                    
                    // Calculate lag in milliseconds
                    let lagMs = 0;
                    switch(lagUnit) {
                        case 'minutes': lagMs = lag * 60 * 1000; break;
                        case 'hours': lagMs = lag * 60 * 60 * 1000; break;
                        case 'days': lagMs = lag * 24 * 60 * 60 * 1000; break;
                        case 'weeks': lagMs = lag * 7 * 24 * 60 * 60 * 1000; break;
                        case 'months': lagMs = lag * 30 * 24 * 60 * 60 * 1000; break;
                    }
                    
                    const parentStart = parentTask.taskDateStart ? new Date(parentTask.taskDateStart) : null;
                    const parentEnd = parentTask.taskDateDue ? new Date(parentTask.taskDateDue) : null;
                    const duration = parseInt(durationInput.value) || 1;
                    const durationType = durationTypeSelect.value;
                    
                    // Recalculate dates based on dependency type with new duration
                    let newStart, newEnd;
                    switch(depType) {
                        case 'SS': // Start-to-Start: This task starts when parent starts
                            if (parentStart) {
                                newStart = new Date(parentStart.getTime() + lagMs);
                                newEnd = new Date(newStart);
                                switch(durationType) {
                                    case 'minutes': newEnd.setMinutes(newEnd.getMinutes() + duration); break;
                                    case 'hours': newEnd.setHours(newEnd.getHours() + duration); break;
                                    case 'days': newEnd.setDate(newEnd.getDate() + duration); break;
                                    case 'weeks': newEnd.setDate(newEnd.getDate() + (duration * 7)); break;
                                    case 'months': newEnd.setMonth(newEnd.getMonth() + duration); break;
                                }
                            }
                            break;
                        case 'FF': // Finish-to-Finish: This task finishes when parent finishes
                            if (parentEnd) {
                                newEnd = new Date(parentEnd.getTime() + lagMs);
                                newStart = new Date(newEnd);
                                let durationMs = duration * 24 * 60 * 60 * 1000;
                                if (durationType === 'minutes') durationMs = duration * 60 * 1000;
                                else if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                newStart.setTime(newStart.getTime() - durationMs);
                            }
                            break;
                        case 'FS': // Finish-to-Start: This task starts after parent finishes
                            if (parentEnd) {
                                newStart = new Date(parentEnd.getTime() + lagMs);
                                newEnd = new Date(newStart);
                                switch(durationType) {
                                    case 'minutes': newEnd.setMinutes(newEnd.getMinutes() + duration); break;
                                    case 'hours': newEnd.setHours(newEnd.getHours() + duration); break;
                                    case 'days': newEnd.setDate(newEnd.getDate() + duration); break;
                                    case 'weeks': newEnd.setDate(newEnd.getDate() + (duration * 7)); break;
                                    case 'months': newEnd.setMonth(newEnd.getMonth() + duration); break;
                                }
                            }
                            break;
                        case 'SF': // Start-to-Finish: This task finishes when parent starts
                            if (parentStart) {
                                newEnd = new Date(parentStart.getTime() + lagMs);
                                newStart = new Date(newEnd);
                                let durationMs = duration * 24 * 60 * 60 * 1000;
                                if (durationType === 'minutes') durationMs = duration * 60 * 1000;
                                else if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                newStart.setTime(newStart.getTime() - durationMs);
                            }
                            break;
                    }
                    
                    if (newStart && newEnd) {
                        // Format dates for inputs
                        function formatDate(date) {
                            const year = date.getFullYear();
                            const month = String(date.getMonth() + 1).padStart(2, '0');
                            const day = String(date.getDate()).padStart(2, '0');
                            const hours = String(date.getHours()).padStart(2, '0');
                            const mins = String(date.getMinutes()).padStart(2, '0');
                            return `${year}-${month}-${day}T${hours}:${mins}`;
                        }
                        
                        startInput.value = formatDate(newStart);
                        endInput.value = formatDate(newEnd);
                        
                        // Update node
                        node.taskDateStart = formatDate(newStart);
                        node.taskDateDue = formatDate(newEnd);
                        node.taskDuration = duration;
                        node.taskDurationType = durationType;
                        
                        // Cascade update dependent tasks (this task's dependents)
                        if (typeof cascadeUpdateDependentTasks === 'function') {
                            cascadeUpdateDependentTasks(nodeId);
                        }
                        refreshAllTaskViews();
                        return;
                    }
                }
            }
            
            // No dependencies or parent not found - calculate normally
            const start = new Date(startInput.value);
            const duration = parseInt(durationInput.value) || 0;
            const durationType = durationTypeSelect.value;

            let endDate = new Date(start);

            switch (durationType) {
                case 'minutes':
                    endDate.setMinutes(endDate.getMinutes() + duration);
                    break;
                case 'hours':
                    endDate.setHours(endDate.getHours() + duration);
                    break;
                case 'days':
                    endDate.setDate(endDate.getDate() + duration);
                    break;
                case 'weeks':
                    endDate.setDate(endDate.getDate() + (duration * 7));
                    break;
                case 'months':
                    endDate.setMonth(endDate.getMonth() + duration);
                    break;
            }

            // Format for datetime-local input (YYYY-MM-DDTHH:MM)
            const year = endDate.getFullYear();
            const month = String(endDate.getMonth() + 1).padStart(2, '0');
            const day = String(endDate.getDate()).padStart(2, '0');
            const hours = String(endDate.getHours()).padStart(2, '0');
            const mins = String(endDate.getMinutes()).padStart(2, '0');

            endInput.value = `${year}-${month}-${day}T${hours}:${mins}`;
            
            // Auto-update task node and refresh views if editing in Task Editor
            if (nodeId && node) {
                node.taskDateStart = startInput.value;
                node.taskDateDue = endInput.value;
                node.taskDuration = parseInt(durationInput.value) || 1;
                node.taskDurationType = durationTypeSelect.value;
                // Cascade update dependent tasks
                if (typeof cascadeUpdateDependentTasks === 'function') {
                    cascadeUpdateDependentTasks(nodeId);
                }
                // Refresh all views immediately
                refreshAllTaskViews();
            }
        }

        // Calculate Duration from Start and End Dates
        function calculateDurationFromDates() {
            const startInput = document.getElementById('taskDateStart');
            const endInput = document.getElementById('taskDateEstimated');
            const durationInput = document.getElementById('taskDuration');
            const durationTypeSelect = document.getElementById('taskDurationType');

            if (!startInput.value || !endInput.value) return;

            const start = new Date(startInput.value);
            const end = new Date(endInput.value);

            if (end <= start) return; // Invalid range

            const diffMs = end - start;
            const durationType = durationTypeSelect.value;

            let duration = 0;

            switch (durationType) {
                case 'minutes':
                    duration = Math.round(diffMs / (1000 * 60));
                    break;
                case 'hours':
                    duration = Math.round(diffMs / (1000 * 60 * 60));
                    break;
                case 'days':
                    duration = Math.round(diffMs / (1000 * 60 * 60 * 24));
                    break;
                case 'weeks':
                    duration = Math.round(diffMs / (1000 * 60 * 60 * 24 * 7));
                    break;
                case 'months':
                    duration = Math.round(diffMs / (1000 * 60 * 60 * 24 * 30));
                    break;
            }

            durationInput.value = Math.max(1, duration);
            
            // Auto-update task node and refresh views if editing in Task Editor
            const taskIdInput = document.getElementById('editingTaskId');
            if (taskIdInput && taskIdInput.value && taskIdInput.value.startsWith('node:')) {
                const nodeId = taskIdInput.value.replace('node:', '');
                const node = nodes.find(n => String(n.id) === String(nodeId));
                if (node) {
                    node.taskDateStart = startInput.value;
                    node.taskDateDue = endInput.value;
                    node.taskDuration = parseInt(durationInput.value) || 1;
                    // Cascade update dependent tasks
                    if (typeof cascadeUpdateDependentTasks === 'function') {
                        cascadeUpdateDependentTasks(nodeId);
                    }
                    // Refresh all views immediately
                    refreshAllTaskViews();
                }
            }
        }

        // Properties Panel - Calculate End Date from Start + Duration
        function calculatePropEndDate() {
            const startInput = document.getElementById('propTaskDateStart');
            const durationInput = document.getElementById('propTaskDuration');
            const durationTypeSelect = document.getElementById('propTaskDurationType');
            const endInput = document.getElementById('propTaskDateDue');

            if (!startInput || !durationInput || !endInput) return;
            if (!startInput.value || !durationInput.value) return;

            const start = new Date(startInput.value);
            const duration = parseInt(durationInput.value) || 0;
            const durationType = durationTypeSelect?.value || 'hours';

            let endDate = new Date(start);

            switch (durationType) {
                case 'minutes': endDate.setMinutes(endDate.getMinutes() + duration); break;
                case 'hours': endDate.setHours(endDate.getHours() + duration); break;
                case 'days': endDate.setDate(endDate.getDate() + duration); break;
                case 'weeks': endDate.setDate(endDate.getDate() + (duration * 7)); break;
                case 'months': endDate.setMonth(endDate.getMonth() + duration); break;
            }

            const year = endDate.getFullYear();
            const month = String(endDate.getMonth() + 1).padStart(2, '0');
            const day = String(endDate.getDate()).padStart(2, '0');
            const hours = String(endDate.getHours()).padStart(2, '0');
            const mins = String(endDate.getMinutes()).padStart(2, '0');

            endInput.value = `${year}-${month}-${day}T${hours}:${mins}`;
            
            // Auto-update task node and refresh views if editing
            if (propEditingNodeId) {
                const node = nodes.find(n => n.id === propEditingNodeId);
                if (node) {
                    node.taskDateStart = startInput.value;
                    node.taskDateDue = endInput.value;
                    // Cascade update dependent tasks
                    if (typeof cascadeUpdateDependentTasks === 'function') {
                        cascadeUpdateDependentTasks(propEditingNodeId);
                    }
                    // Refresh all views immediately
                    refreshAllTaskViews();
                }
            }
        }

        // Properties Panel - Calculate Duration from Dates
        function calculatePropDurationFromDates() {
            const startInput = document.getElementById('propTaskDateStart');
            const endInput = document.getElementById('propTaskDateDue');
            const durationInput = document.getElementById('propTaskDuration');
            const durationTypeSelect = document.getElementById('propTaskDurationType');

            if (!startInput || !endInput || !durationInput) return;
            if (!startInput.value || !endInput.value) return;

            const start = new Date(startInput.value);
            const end = new Date(endInput.value);

            if (end <= start) return;

            const diffMs = end - start;
            const durationType = durationTypeSelect?.value || 'hours';

            let duration = 0;

            switch (durationType) {
                case 'minutes': duration = Math.round(diffMs / (1000 * 60)); break;
                case 'hours': duration = Math.round(diffMs / (1000 * 60 * 60)); break;
                case 'days': duration = Math.round(diffMs / (1000 * 60 * 60 * 24)); break;
                case 'weeks': duration = Math.round(diffMs / (1000 * 60 * 60 * 24 * 7)); break;
                case 'months': duration = Math.round(diffMs / (1000 * 60 * 60 * 24 * 30)); break;
            }

            durationInput.value = Math.max(1, duration);
            
            // Auto-update task node and refresh views if editing
            if (propEditingNodeId) {
                const node = nodes.find(n => n.id === propEditingNodeId);
                if (node) {
                    node.taskDateStart = startInput.value;
                    node.taskDateDue = endInput.value;
                    node.taskDuration = parseInt(durationInput.value) || 1;
                    // Cascade update dependent tasks
                    if (typeof cascadeUpdateDependentTasks === 'function') {
                        cascadeUpdateDependentTasks(propEditingNodeId);
                    }
                    // Refresh all views immediately
                    refreshAllTaskViews();
                }
            }
        }
        
        // Refresh all task-related views (Timeline, Task Manager, Outline)
        function refreshAllTaskViews() {
            // Refresh timeline if visible (either in timeline mode or task manager modal is open)
            const taskManagerModal = document.getElementById('taskManagerModal');
            const isTaskManagerOpen = taskManagerModal && taskManagerModal.style.display !== 'none';
            
            if (currentTaskViewMode === 'timeline' || isTaskManagerOpen) {
                renderTaskTimeline();
                // Re-initialize drag handlers after timeline refresh
                setTimeout(() => {
                    if (typeof initTimelineDragHandlers === 'function') {
                        initTimelineDragHandlers();
                    }
                }, 100);
            }
            // Refresh main page timeline if visible
            if (timelineBarVisible && typeof renderTimelineBar === 'function') {
                renderTimelineBar();
            }
            // Refresh task list if visible
            const taskListContainer = document.getElementById('taskListContainer');
            if (taskListContainer && taskListContainer.style.display !== 'none') {
                renderTaskList();
            }
            // Refresh outline
            renderOutline();
            // Refresh node on canvas
            if (propEditingNodeId) {
                const node = nodes.find(n => n.id === propEditingNodeId);
                if (node) {
                    renderNode(node);
                }
            }
            // Update properties panel if visible and showing a task node
            if (propEditingNodeId && typeof updatePropertiesPanel === 'function') {
                const propNode = nodes.find(n => n.id === propEditingNodeId);
                if (propNode && (propNode.isTaskNode || TASK_NODE_TYPES[propNode.type])) {
                    updatePropertiesPanel(propEditingNodeId);
                }
            }
            // Also update properties panel if selectedNode is a task node
            if (selectedNode && typeof updatePropertiesPanel === 'function') {
                const selectedNodeObj = nodes.find(n => n.id === selectedNode);
                if (selectedNodeObj && (selectedNodeObj.isTaskNode || TASK_NODE_TYPES[selectedNodeObj.type])) {
                    updatePropertiesPanel(selectedNode);
                }
            }
        }

        // Arrange tasks by date
        function arrangeTasksByDate() {
            saveUndoState('arrange tasks by date');

            const allTaskTypes = getAllTaskTypes();
            const taskNodes = nodes.filter(n => n.isTaskNode || allTaskTypes[n.type]);

            if (taskNodes.length === 0) {
                showToast('D√ºzenlenecek task bulunamadƒ±');
                return;
            }

            // Sort by start date, then due date
            const sorted = [...taskNodes].sort((a, b) => {
                const dateA = a.taskDateStart || a.taskDateDue || '9999-12-31';
                const dateB = b.taskDateStart || b.taskDateDue || '9999-12-31';
                return dateA.localeCompare(dateB);
            });

            const startX = 100;
            const startY = 100;
            const verticalGap = 180;

            sorted.forEach((task, index) => {
                task.x = startX;
                task.y = startY + (index * verticalGap);
            });

            renderAll();
            renderConnections();
            showToast(`${sorted.length} task tarihe g√∂re sƒ±ralandƒ±`);
        }

        // Arrange tasks by priority
        function arrangeTasksByPriority() {
            saveUndoState('arrange tasks by priority');

            const allTaskTypes = getAllTaskTypes();
            const taskNodes = nodes.filter(n => n.isTaskNode || allTaskTypes[n.type]);

            if (taskNodes.length === 0) {
                showToast('D√ºzenlenecek task bulunamadƒ±');
                return;
            }

            const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };

            const sorted = [...taskNodes].sort((a, b) => {
                const pA = priorityOrder[a.taskPriority] ?? 2;
                const pB = priorityOrder[b.taskPriority] ?? 2;
                return pA - pB;
            });

            const startX = 100;
            const startY = 100;
            const verticalGap = 180;

            sorted.forEach((task, index) => {
                task.x = startX;
                task.y = startY + (index * verticalGap);
            });

            renderAll();
            renderConnections();
            showToast(`${sorted.length} task √∂nceliƒüe g√∂re sƒ±ralandƒ±`);
        }

        // Populate task status dropdown dynamically
        function populateTaskStatusOptions() {
            const select = document.getElementById('taskStatus');
            if (!select) return;

            const currentValue = select.value;
            select.innerHTML = '';

            TASK_STATUSES.forEach(status => {
                const option = document.createElement('option');
                option.value = status.id;
                option.textContent = `${status.icon} ${status.name}`;
                select.appendChild(option);
            });

            if (currentValue) select.value = currentValue;
        }

        // Task Status Manager Functions
        function openTaskStatusManager() {
            renderTaskStatusList();
            openModal('taskStatusManagerModal');
        }

        function renderTaskStatusList() {
            const container = document.getElementById('taskStatusList');
            container.innerHTML = TASK_STATUSES.map((status, index) => `
                <div style="display:flex; align-items:center; gap:10px; padding:10px; background:#252538; border-radius:8px; margin-bottom:8px;">
                    <span style="font-size:20px;">${status.icon}</span>
                    <span style="flex:1; color:#fff;">${status.name}</span>
                    <span style="width:20px; height:20px; border-radius:4px; background:${status.color};"></span>
                    <button onclick="deleteTaskStatus('${status.id}')" style="background:#ef4444; color:#fff; border:none; padding:5px 10px; border-radius:4px; cursor:pointer; font-size:11px;" ${index < 6 ? 'disabled title="Varsayƒ±lan durumlar silinemez"' : ''}>üóëÔ∏è</button>
                </div>
            `).join('');
        }

        function addCustomTaskStatus() {
            const name = document.getElementById('newStatusName').value.trim();
            const color = document.getElementById('newStatusColor').value;
            const icon = document.getElementById('newStatusIcon').value;

            if (!name) {
                alert('L√ºtfen durum adƒ± girin');
                return;
            }

            const id = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');

            if (TASK_STATUSES.some(s => s.id === id)) {
                alert('Bu durum zaten mevcut');
                return;
            }

            TASK_STATUSES.push({ id, name, color, icon });

            // Clear inputs
            document.getElementById('newStatusName').value = '';
            document.getElementById('newStatusColor').value = '#8b5cf6';
            document.getElementById('newStatusIcon').value = 'üìå';

            renderTaskStatusList();
            populateTaskStatusOptions();
            saveToLocalStorage();
            showToast(`"${name}" durumu eklendi`);
        }

        function deleteTaskStatus(statusId) {
            const index = TASK_STATUSES.findIndex(s => s.id === statusId);
            if (index < 6) {
                alert('Varsayƒ±lan durumlar silinemez');
                return;
            }

            if (!confirm('Bu durumu silmek istediƒüinize emin misiniz?')) return;

            TASK_STATUSES.splice(index, 1);
            renderTaskStatusList();
            populateTaskStatusOptions();
            saveToLocalStorage();
            showToast('Durum silindi');
        }

        // Task Type Manager Functions - Legend Style
        let editingTaskTypeId = null;

        function openTaskTypeManager() {
            cancelTaskTypeEdit();
            renderTaskTypeList();
            openModal('taskTypeManagerModal');
        }

        function renderTaskTypeList() {
            const container = document.getElementById('taskTypeList');
            if (!container) {
                console.error('taskTypeList container not found!');
                return;
            }

            const allTypes = getAllTaskTypes();
            console.log('Rendering task types:', Object.keys(allTypes).length, allTypes);

            if (Object.keys(allTypes).length === 0) {
                container.innerHTML = '<div style="color:#888; text-align:center; padding:20px;">No task types found</div>';
                return;
            }

            let html = '';

            // First show default types
            Object.entries(TASK_NODE_TYPES).forEach(([id, type]) => {
                html += `
                    <div class="task-type-item" style="display:flex; align-items:center; gap:10px; padding:12px; background:#333; border-radius:8px; margin-bottom:8px;">
                        <span style="font-size:1.5em;">${type.icon || 'üìã'}</span>
                        <div style="flex:1;">
                            <div style="font-weight:bold; color:#fff;">${type.name}</div>
                            <div style="font-size:0.8em; color:#666;">ID: ${id} <span style="color:#8b5cf6;">(default)</span></div>
                        </div>
                        <div style="width:30px; height:30px; border-radius:6px; background:${type.color || '#8b5cf6'};"></div>
                        <button onclick="editTaskType('${id}')" style="background:#3b82f6; color:#fff; border:none; padding:8px 14px; border-radius:6px; cursor:pointer; font-size:12px;">‚úèÔ∏è Edit</button>
                    </div>
                `;
            });

            // Then show custom types
            if (CUSTOM_TASK_TYPES && CUSTOM_TASK_TYPES.length > 0) {
                html += '<div style="border-top:1px solid #444; margin:15px 0; padding-top:10px;"><span style="color:#8b5cf6; font-size:12px;">CUSTOM TYPES</span></div>';
                CUSTOM_TASK_TYPES.forEach(type => {
                    html += `
                        <div class="task-type-item" style="display:flex; align-items:center; gap:10px; padding:12px; background:#333; border-radius:8px; margin-bottom:8px;">
                            <span style="font-size:1.5em;">${type.icon || 'üìã'}</span>
                            <div style="flex:1;">
                                <div style="font-weight:bold; color:#fff;">${type.name}</div>
                                <div style="font-size:0.8em; color:#666;">ID: ${type.id}</div>
                            </div>
                            <div style="width:30px; height:30px; border-radius:6px; background:${type.color || '#8b5cf6'};"></div>
                            <button onclick="editTaskType('${type.id}')" style="background:#3b82f6; color:#fff; border:none; padding:8px 14px; border-radius:6px; cursor:pointer; font-size:12px;">‚úèÔ∏è Edit</button>
                            <button onclick="deleteTaskType('${type.id}')" style="background:#ef4444; color:#fff; border:none; padding:8px 14px; border-radius:6px; cursor:pointer; font-size:12px;">üóëÔ∏è</button>
                        </div>
                    `;
                });
            }

            container.innerHTML = html;
        }

        function editTaskType(typeId) {
            console.log('editTaskType called:', typeId);

            // Check default types first
            let type = TASK_NODE_TYPES[typeId];
            let isDefault = !!type;

            // If not in defaults, check custom types
            if (!type) {
                const customType = CUSTOM_TASK_TYPES.find(t => t.id === typeId);
                if (customType) {
                    type = { icon: customType.icon, name: customType.name, color: customType.color };
                }
            }

            if (!type) {
                console.error('Type not found:', typeId);
                showToast('Tip bulunamadƒ±!', 'error');
                return;
            }

            editingTaskTypeId = typeId;
            console.log('Editing type:', typeId, type, 'isDefault:', isDefault);

            // Update form title
            const formTitle = document.getElementById('taskTypeFormTitle');
            if (formTitle) {
                formTitle.innerHTML = `‚úèÔ∏è EDIT TYPE ${isDefault ? '(Default)' : '(Custom)'}`;
            }

            // Fill form with existing values
            const idInput = document.getElementById('newTypeId');
            if (idInput) {
                idInput.value = typeId;
                idInput.disabled = true; // Can't change ID when editing
            }

            const nameInput = document.getElementById('newTypeName');
            if (nameInput) nameInput.value = type.name || '';

            const iconInput = document.getElementById('newTypeIcon');
            if (iconInput) iconInput.value = type.icon || 'üìã';

            const colorInput = document.getElementById('newTypeColor');
            if (colorInput) colorInput.value = type.color || '#8b5cf6';

            // Scroll to form and highlight it
            const form = document.getElementById('taskTypeForm');
            if (form) {
                form.style.borderColor = '#22c55e';
                form.scrollIntoView({ behavior: 'smooth' });
                setTimeout(() => { form.style.borderColor = '#8b5cf6'; }, 2000);
            }
        }

        function cancelTaskTypeEdit() {
            console.log('cancelTaskTypeEdit called');
            editingTaskTypeId = null;

            const formTitle = document.getElementById('taskTypeFormTitle');
            if (formTitle) formTitle.innerHTML = '‚ûï ADD NEW TYPE';

            const idInput = document.getElementById('newTypeId');
            if (idInput) {
                idInput.value = '';
                idInput.disabled = false;
            }

            const nameInput = document.getElementById('newTypeName');
            if (nameInput) nameInput.value = '';

            const iconInput = document.getElementById('newTypeIcon');
            if (iconInput) iconInput.value = 'üìã';

            const colorInput = document.getElementById('newTypeColor');
            if (colorInput) colorInput.value = '#8b5cf6';

            // Reset form border
            const form = document.getElementById('taskTypeForm');
            if (form) form.style.borderColor = '#8b5cf6';
        }

        function saveTaskType() {
            const name = document.getElementById('newTypeName').value.trim();
            const color = document.getElementById('newTypeColor').value;
            const icon = document.getElementById('newTypeIcon').value || 'üìã';

            console.log('saveTaskType called:', { name, color, icon, editingTaskTypeId });

            if (!name) {
                showToast('L√ºtfen tip adƒ± girin!', 'error');
                return;
            }

            if (editingTaskTypeId) {
                // EDIT existing type
                const isDefault = !!TASK_NODE_TYPES[editingTaskTypeId];
                console.log('Editing existing type:', editingTaskTypeId, 'isDefault:', isDefault);

                if (isDefault) {
                    // Update default type
                    TASK_NODE_TYPES[editingTaskTypeId] = {
                        icon: icon,
                        name: name,
                        color: color
                    };
                    console.log('Updated default type:', TASK_NODE_TYPES[editingTaskTypeId]);
                } else {
                    // Update custom type
                    const index = CUSTOM_TASK_TYPES.findIndex(t => t.id === editingTaskTypeId);
                    if (index !== -1) {
                        CUSTOM_TASK_TYPES[index] = { id: editingTaskTypeId, name, icon, color };
                        console.log('Updated custom type:', CUSTOM_TASK_TYPES[index]);
                    }
                }

                showToast(`‚úÖ "${name}" g√ºncellendi!`);
            } else {
                // ADD new type
                const idInput = document.getElementById('newTypeId');
                let id = idInput ? idInput.value.trim().toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '') : '';

                if (!id) {
                    id = 'custom-' + name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                }

                if (TASK_NODE_TYPES[id] || CUSTOM_TASK_TYPES.some(t => t.id === id)) {
                    showToast('Bu ID zaten mevcut!', 'error');
                    return;
                }

                CUSTOM_TASK_TYPES.push({ id, name, icon, color });
                console.log('Added new custom type:', { id, name, icon, color });
                showToast(`‚úÖ "${name}" eklendi!`);
            }

            // Refresh UI
            applyTaskTypeStyles();
            renderTaskTypeList();
            updateNewTaskDropdown();
            if (typeof updateAddTaskMenuTypes === 'function') {
                updateAddTaskMenuTypes();
            }

            // CRITICAL: Save to localStorage AND session
            saveToLocalStorage();
            saveTaskTypesToStorage();

            cancelTaskTypeEdit();

            // Re-render all task nodes to apply new styles
            renderAll();
            renderConnections();
        }

        // Separate function to ensure task types are saved
        function saveTaskTypesToStorage() {
            try {
                // Save task types separately for reliability
                localStorage.setItem('writerTaskNodeTypes', JSON.stringify(TASK_NODE_TYPES));
                localStorage.setItem('writerCustomTaskTypes', JSON.stringify(CUSTOM_TASK_TYPES));
                console.log('Task types saved to localStorage');
            } catch(e) {
                console.error('Error saving task types:', e);
            }
        }

        // Sanitize corrupted UTF-8 characters (fixes √É¬∞√Ç√Ç type encoding issues)
        function sanitizeCorruptedIcon(icon) {
            if (!icon || typeof icon !== 'string') return '‚ñ¢';
            // Detect corrupted UTF-8 patterns (Latin-1 misinterpretation)
            const corruptedPattern = /[\xC0-\xFF][\x80-\xBF]*|√É[¬∞¬¢¬ß¬π]|√Ç[√Ç≈∏¬π]/;
            if (corruptedPattern.test(icon) || icon.length > 4) {
                // Return a safe default icon
                return '‚ñ¢';
            }
            return icon;
        }

        // Sanitize task type object
        function sanitizeTaskType(type) {
            if (!type) return type;
            return {
                ...type,
                icon: sanitizeCorruptedIcon(type.icon)
            };
        }
        
        // Note: sanitizeStatus, sanitizeTaskStatuses, getDefaultTaskStatuses are defined earlier in the code

        // Load task types from storage
        function loadTaskTypesFromStorage() {
            try {
                const savedDefaults = localStorage.getItem('writerTaskNodeTypes');
                if (savedDefaults) {
                    const parsed = JSON.parse(savedDefaults);
                    // Check for corruption and reset if needed
                    let hasCorruption = false;
                    Object.keys(parsed).forEach(key => {
                        const icon = parsed[key]?.icon || '';
                        if (icon.length > 4 || /[\xC0-\xFF][\x80-\xBF]*|√É[¬∞¬¢¬ß¬π]|√Ç[√Ç≈∏¬π]/.test(icon)) {
                            hasCorruption = true;
                        }
                    });
                    
                    if (hasCorruption) {
                        console.warn('Corrupted task types detected, resetting to defaults...');
                        localStorage.removeItem('writerTaskNodeTypes');
                        // Keep the default TASK_NODE_TYPES defined in code
                    } else {
                        // Merge with defaults (keep new default types, update existing)
                        Object.keys(parsed).forEach(key => {
                            TASK_NODE_TYPES[key] = sanitizeTaskType(parsed[key]);
                        });
                    }
                    console.log('Loaded TASK_NODE_TYPES from storage:', Object.keys(TASK_NODE_TYPES).length);
                }

                const savedCustom = localStorage.getItem('writerCustomTaskTypes');
                if (savedCustom) {
                    let customTypes = JSON.parse(savedCustom);
                    // Check for corruption in custom types
                    let hasCorruption = customTypes.some(t => {
                        const icon = t?.icon || '';
                        return icon.length > 4 || /[\xC0-\xFF][\x80-\xBF]*|√É[¬∞¬¢¬ß¬π]|√Ç[√Ç≈∏¬π]/.test(icon);
                    });
                    
                    if (hasCorruption) {
                        console.warn('Corrupted custom task types detected, sanitizing...');
                        customTypes = customTypes.map(t => sanitizeTaskType(t));
                        // Save sanitized version
                        localStorage.setItem('writerCustomTaskTypes', JSON.stringify(customTypes));
                    }
                    CUSTOM_TASK_TYPES = customTypes;
                    console.log('Loaded CUSTOM_TASK_TYPES from storage:', CUSTOM_TASK_TYPES.length);
                }
            } catch(e) {
                console.error('Error loading task types:', e);
                // Reset corrupted storage
                localStorage.removeItem('writerTaskNodeTypes');
                localStorage.removeItem('writerCustomTaskTypes');
            }
        }

        function deleteTaskType(typeId) {
            if (TASK_NODE_TYPES[typeId]) {
                showToast('Varsayƒ±lan tipler silinemez!', 'error');
                return;
            }

            if (!confirm('Bu tipi silmek istediƒüinize emin misiniz?')) return;

            const index = CUSTOM_TASK_TYPES.findIndex(t => t.id === typeId);
            if (index !== -1) {
                CUSTOM_TASK_TYPES.splice(index, 1);
                applyTaskTypeStyles();
                renderTaskTypeList();
                updateNewTaskDropdown();
                saveTaskTypesToStorage(); // Save immediately
                updateAddTaskMenuTypes();
                saveToLocalStorage();
                showToast('Tip silindi');
            }
        }

        // Apply dynamic styles for task types
        function applyTaskTypeStyles() {
            let styleEl = document.getElementById('taskTypeStyles');
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = 'taskTypeStyles';
                document.head.appendChild(styleEl);
            }

            let css = '';
            const allTypes = getAllTaskTypes();

            Object.entries(allTypes).forEach(([id, type]) => {
                css += `
                    .task-node-card.type-${id} .task-node-header {
                        background: ${type.color};
                        color: ${isLightColor(type.color) ? '#1a1a1a' : '#ffffff'};
                    }
                `;
            });

            styleEl.textContent = css;
        }

        // Helper to determine if color is light
        function isLightColor(color) {
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 128;
        }

        // Update add task menu with all types
        function updateAddTaskMenuTypes() {
            const taskTypeListEl = document.getElementById('addTaskMenu')?.querySelector('#taskTypeList');
            if (!taskTypeListEl) return;

            const allTypes = getAllTaskTypes();
            taskTypeListEl.innerHTML = Object.entries(allTypes).map(([id, type]) => `
                <div class="context-menu-item" onclick="addTaskNode('${id}'); hideAllMenus();">
                    <span class="item-icon">${type.icon}</span> ${type.name}
                </div>
            `).join('');
        }

        function updateNewTaskDropdown() {
            const dropdown = document.getElementById('newTaskDropdown');
            if (!dropdown) return;

            const allTypes = getAllTaskTypes();
            dropdown.innerHTML = Object.entries(allTypes).map(([id, type]) => `
                <div onclick="addTaskNode('${id}'); hideNewTaskDropdown();" style="padding:10px 15px; cursor:pointer; border-bottom:1px solid #333; color:#fff;">${type.icon} ${type.name}</div>
            `).join('');
        }

        function getNodeTypeIcon(type) {
            const icons = {
                'section': 'üìÑ',
                'group': 'üìÅ',
                'note': 'üìù',
                'introduction': 'üìñ',
                'draft': '‚úèÔ∏è',
                'conclusion': 'üèÅ'
            };
            return icons[type] || 'üìÑ';
        }

        // Show tasks for a specific node
        function showNodeTasks(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Set filter to show only this node's tasks
            currentTaskFilter = null;
            currentNodeFilter = nodeId;

            // Update modal title to show node name
            const modalTitle = document.querySelector('#taskManagerModal .modal-header h2');
            if (modalTitle) {
                modalTitle.innerHTML = `üìã Tasks for: <span style="color:#8b5cf6">${node.title}</span>`;
            }

            renderTaskListForNode(nodeId);
            openModal('taskManagerModal');
        }

        let currentNodeFilter = null;

        function renderTaskListForNode(nodeId) {
            const container = document.getElementById('taskListContainer');
            const nodeTasks = tasks.filter(t => t.assignedNodeId === nodeId);
            const node = nodes.find(n => n.id === nodeId);

            if (nodeTasks.length === 0) {
                container.innerHTML = `
                    <div class="task-empty-state">
                        <div class="icon">üìã</div>
                        <h3>No tasks for "${node?.title || 'this node'}"</h3>
                        <p>Click the button below to add a task</p>
                        <button onclick="openTaskEditor(null, '${nodeId}')" style="margin-top:15px; background:linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color:#fff; border:none; padding:12px 24px; border-radius:10px; cursor:pointer; font-weight:600;">+ Add Task to ${node?.title || 'Node'}</button>
                    </div>
                `;
                return;
            }

            // Add "Add Task" button at top
            let html = `<div style="margin-bottom:15px;">
                <button onclick="openTaskEditor(null, '${nodeId}')" style="background:linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color:#fff; border:none; padding:10px 20px; border-radius:8px; cursor:pointer; font-weight:600;">+ Add Task to ${node?.title || 'Node'}</button>
            </div>`;

            html += nodeTasks.map(task => {
                const statusInfo = TASK_STATUSES.find(s => s.id === task.status) || TASK_STATUSES[0];
                const importanceInfo = IMPORTANCE_LEVELS.find(i => i.id === task.importance) || IMPORTANCE_LEVELS[1];
                const safeStatusIcon = sanitizeCorruptedIconEarly(statusInfo.icon);
                const safeStatusName = sanitizeText(statusInfo.name);

                let daysRemaining = '';
                if (task.dateEstimated) {
                    const today = new Date();
                    const estimated = new Date(task.dateEstimated);
                    const diff = Math.ceil((estimated - today) / (1000 * 60 * 60 * 24));
                    if (diff < 0) {
                        daysRemaining = `<span style="color:#ef4444">${Math.abs(diff)} days overdue</span>`;
                    } else if (diff === 0) {
                        daysRemaining = `<span style="color:#f59e0b">Due today</span>`;
                    } else {
                        daysRemaining = `<span style="color:#22c55e">${diff} days left</span>`;
                    }
                }

                return `
                    <div class="task-item" style="border-left-color: ${statusInfo.color}">
                        <div class="task-item-header">
                            <div class="task-item-title">${safeStatusIcon} ${sanitizeText(task.title)}</div>
                            <div class="task-item-badges">
                                <span class="task-badge status" style="background:${statusInfo.color}20; color:${statusInfo.color}">${safeStatusName}</span>
                                <span class="task-badge importance-${task.importance}">${importanceInfo.name}</span>
                            </div>
                        </div>
                        ${task.description ? `<p style="color:#aaa; font-size:13px; margin-bottom:12px;">${task.description}</p>` : ''}
                        <div class="task-item-meta">
                            ${task.assignedBy ? `<div class="task-meta-item">üë§ ${task.assignedBy}</div>` : ''}
                            ${task.duration ? `<div class="task-meta-item">‚è±Ô∏è ${task.duration} ${task.durationType}</div>` : ''}
                            ${daysRemaining ? `<div class="task-meta-item">üéØ ${daysRemaining}</div>` : ''}
                            <div class="task-meta-item">
                                üìà ${task.progress || 0}%
                                <div class="task-progress-bar">
                                    <div class="task-progress-fill" style="width:${task.progress || 0}%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="task-item-actions">
                            <button class="task-action-btn" onclick="openTaskEditor(${task.id})">‚úèÔ∏è Edit</button>
                            <button class="task-action-btn" onclick="quickUpdateTaskStatus(${task.id})">üîÑ Change Status</button>
                            <button class="task-action-btn delete" onclick="deleteTask(${task.id}); renderTaskListForNode('${nodeId}');">üóëÔ∏è Delete</button>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function saveTask() {
            const taskId = document.getElementById('editingTaskId').value;
            const title = document.getElementById('taskTitle').value.trim();

            if (!title) {
                alert('Please enter a task title');
                return;
            }

            // Check if we're editing a task NODE (not a standalone task)
            if (taskId && taskId.startsWith('node:')) {
                const nodeId = taskId.replace('node:', '');
                const node = nodes.find(n => n.id === nodeId);
                if (node) {
                    node.title = title;
                    node.summary = document.getElementById('taskDescription').value.trim();
                    node.taskStatus = document.getElementById('taskStatus').value;
                    node.taskPriority = document.getElementById('taskImportance').value;
                    node.taskAssignedBy = document.getElementById('taskAssignedBy').value.trim();
                    node.taskProgress = parseInt(document.getElementById('taskProgress').value) || 0;
                    node.taskDuration = parseInt(document.getElementById('taskDuration').value) || 1;
                    node.taskDurationType = document.getElementById('taskDurationType').value;
                    
                    // IMPORTANT: Apply dependency logic BEFORE setting dates
                    // If task has dependencies, dates should be calculated from parent task based on dependency type
                    // This ensures SS tasks take parent's start date, FF tasks take parent's end date, etc.
                    const hasDependencies = tempTaskDependencies && tempTaskDependencies.length > 0;
                    if (hasDependencies) {
                        // Get primary dependency (first one)
                        const primaryDep = tempTaskDependencies[0];
                        const parentTask = nodes.find(n => String(n.id) === String(primaryDep.taskId));
                        
                        if (parentTask) {
                            const depType = primaryDep.type || 'FS';
                            const lag = primaryDep.lag || 0;
                            const lagUnit = primaryDep.lagUnit || 'days';
                            
                            // Calculate lag in milliseconds
                            let lagMs = 0;
                            switch(lagUnit) {
                                case 'minutes': lagMs = lag * 60 * 1000; break;
                                case 'hours': lagMs = lag * 60 * 60 * 1000; break;
                                case 'days': lagMs = lag * 24 * 60 * 60 * 1000; break;
                                case 'weeks': lagMs = lag * 7 * 24 * 60 * 60 * 1000; break;
                                case 'months': lagMs = lag * 30 * 24 * 60 * 60 * 1000; break;
                            }
                            
                            const parentStart = parentTask.taskDateStart ? new Date(parentTask.taskDateStart) : null;
                            const parentEnd = parentTask.taskDateDue ? new Date(parentTask.taskDateDue) : null;
                            
                            // Apply dependency logic based on type
                            switch(depType) {
                                case 'SS': // Start-to-Start: This task starts when parent starts
                                    if (parentStart) {
                                        const newStart = new Date(parentStart.getTime() + lagMs);
                                        node.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                        // Calculate end date based on duration
                                        const duration = node.taskDuration || 1;
                                        const durationType = node.taskDurationType || 'days';
                                        let dueDate = new Date(newStart);
                                        switch(durationType) {
                                            case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                            case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                            case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                            case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                        }
                                        node.taskDateDue = dueDate.toISOString().split('T')[0] + 'T18:00';
                                    }
                                    break;
                                case 'FF': // Finish-to-Finish: This task finishes when parent finishes
                                    if (parentEnd) {
                                        const newEnd = new Date(parentEnd.getTime() + lagMs);
                                        node.taskDateDue = newEnd.toISOString().split('T')[0] + 'T18:00';
                                        // Calculate start date based on duration (backwards from end)
                                        const duration = node.taskDuration || 1;
                                        const durationType = node.taskDurationType || 'days';
                                        let durationMs = duration * 24 * 60 * 60 * 1000;
                                        if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                        else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                        else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                        const newStart = new Date(newEnd.getTime() - durationMs);
                                        node.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                    }
                                    break;
                                case 'FS': // Finish-to-Start: This task starts after parent finishes
                                    if (parentEnd) {
                                        const newStart = new Date(parentEnd.getTime() + lagMs);
                                        node.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                        // Calculate end date based on duration
                                        const duration = node.taskDuration || 1;
                                        const durationType = node.taskDurationType || 'days';
                                        let dueDate = new Date(newStart);
                                        switch(durationType) {
                                            case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                            case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                            case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                            case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                        }
                                        node.taskDateDue = dueDate.toISOString().split('T')[0] + 'T18:00';
                                    }
                                    break;
                                case 'SF': // Start-to-Finish: This task finishes when parent starts
                                    if (parentStart) {
                                        const newEnd = new Date(parentStart.getTime() + lagMs);
                                        node.taskDateDue = newEnd.toISOString().split('T')[0] + 'T18:00';
                                        // Calculate start date based on duration (backwards from end)
                                        const duration = node.taskDuration || 1;
                                        const durationType = node.taskDurationType || 'days';
                                        let durationMs = duration * 24 * 60 * 60 * 1000;
                                        if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                        else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                        else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                        const newStart = new Date(newEnd.getTime() - durationMs);
                                        node.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                    }
                                    break;
                                default:
                                    // No dependency logic, use form values
                                    node.taskDateStart = document.getElementById('taskDateStart').value;
                                    node.taskDateDue = document.getElementById('taskDateEstimated').value;
                            }
                        } else {
                            // Parent task not found, use form values
                            node.taskDateStart = document.getElementById('taskDateStart').value;
                            node.taskDateDue = document.getElementById('taskDateEstimated').value;
                        }
                    } else {
                        // No dependencies, use form values directly
                        node.taskDateStart = document.getElementById('taskDateStart').value;
                        node.taskDateDue = document.getElementById('taskDateEstimated').value;
                    }

                    const linkedNodeId = document.getElementById('taskAssignedNode').value;
                    const oldLinkedNodeId = node.linkedNodeIds?.[0] || null;
                    node.linkedNodeIds = linkedNodeId ? [linkedNodeId] : [];

                    // Sync connection with assigned node
                    // Remove old connection if existed
                    if (oldLinkedNodeId && oldLinkedNodeId !== linkedNodeId) {
                        connections = connections.filter(c =>
                            !(c.from === nodeId && c.to === oldLinkedNodeId) &&
                            !(c.to === nodeId && c.from === oldLinkedNodeId)
                        );
                    }

                    // Create new connection if assigned to a node
                    if (linkedNodeId && linkedNodeId !== oldLinkedNodeId) {
                        // Check if connection already exists
                        const connExists = connections.some(c =>
                            (c.from === nodeId && c.to === linkedNodeId) ||
                            (c.to === nodeId && c.from === linkedNodeId)
                        );
                        if (!connExists) {
                            // Create parent-child relationship (task becomes child of assigned node)
                            node.parentId = linkedNodeId;
                        }
                    } else if (!linkedNodeId) {
                        // Remove parent relationship if no node assigned
                        node.parentId = null;
                    }

                    // Save task dependencies and sync connections
                    node.taskDependencies = [...tempTaskDependencies];

                    // Sync connections with task dependencies
                    tempTaskDependencies.forEach(dep => {
                        const connExists = connections.some(c =>
                            (String(c.from) === String(dep.taskId) && String(c.to) === String(nodeId)) ||
                            (String(c.from) === String(nodeId) && String(c.to) === String(dep.taskId))
                        );
                        if (!connExists) {
                            connections.push({ from: dep.taskId, to: nodeId, dependencyType: dep.type || 'FS' });
                        }
                    });

                    // MS PROJECT LOGIC: Cascade update only applies to independent tasks or parent tasks
                    // If this task has dependencies, it's a dependent task and its dates are calculated from parent
                    // Only cascade update if this task has NO dependencies (it's an independent/parent task)
                    // OR if this task's dates were changed and it has dependents
                    const isDependentTask = hasDependencies;
                    if (!isDependentTask && typeof cascadeUpdateDependentTasks === 'function') {
                        // This is an independent task - cascade update its dependents
                        cascadeUpdateDependentTasks(nodeId);
                    } else if (isDependentTask && typeof cascadeUpdateDependentTasks === 'function') {
                        // This is a dependent task - its dates are calculated from parent
                        // But it might have its own dependents, so cascade update those
                        cascadeUpdateDependentTasks(nodeId);
                    }

                    closeModal('taskEditorModal');
                    renderAll();
                    updateAllStats();
                    saveToLocalStorage();
                    
                    // Force immediate timeline refresh - both task manager and main page timeline
                    refreshAllTaskViews();
                    const taskManagerModal = document.getElementById('taskManagerModal');
                    const isTaskManagerOpen = taskManagerModal && taskManagerModal.style.display !== 'none';
                    if (isTaskManagerOpen) {
                        // Force immediate refresh of task manager timeline
                        setTimeout(() => {
                            renderTaskTimeline();
                            // Re-initialize drag handlers after timeline refresh
                            if (typeof initTimelineDragHandlers === 'function') {
                                initTimelineDragHandlers();
                            }
                        }, 50);
                    }
                    // Always refresh main page timeline if visible
                    if (timelineBarVisible && typeof renderTimelineBar === 'function') {
                        setTimeout(() => {
                            renderTimelineBar();
                        }, 50);
                    }
                    
                    // Update properties panel if it's showing this task
                    if (propEditingNodeId && typeof updatePropertiesPanel === 'function') {
                        if (String(propEditingNodeId) === String(nodeId)) {
                            setTimeout(() => {
                                updatePropertiesPanel(nodeId);
                            }, 100);
                        }
                    }
                    // Also update if selectedNode matches
                    if (selectedNode && typeof updatePropertiesPanel === 'function') {
                        if (String(selectedNode) === String(nodeId)) {
                            setTimeout(() => {
                                updatePropertiesPanel(selectedNode);
                            }, 100);
                        }
                    }
                    
                    showToast('‚úì Task ve baƒüƒ±mlƒ± g√∂revler g√ºncellendi');
                    return;
                }
            }

            const taskData = {
                title: title,
                description: document.getElementById('taskDescription').value.trim(),
                status: document.getElementById('taskStatus').value,
                importance: document.getElementById('taskImportance').value,
                assignedBy: document.getElementById('taskAssignedBy').value.trim(),
                progress: parseInt(document.getElementById('taskProgress').value) || 0,
                duration: parseInt(document.getElementById('taskDuration').value) || 1,
                durationType: document.getElementById('taskDurationType').value,
                dateStart: document.getElementById('taskDateStart').value,
                dateEstimated: document.getElementById('taskDateEstimated').value,
                assignedNodeId: document.getElementById('taskAssignedNode').value || null,
                dateUpdated: new Date().toISOString()
            };

            if (taskId) {
                // Update existing task
                const index = tasks.findIndex(t => t.id === parseInt(taskId));
                if (index !== -1) {
                    tasks[index] = { ...tasks[index], ...taskData };
                }
            } else {
                // Create new task
                taskData.id = taskIdCounter++;
                taskData.dateCreated = new Date().toISOString();
                tasks.push(taskData);
            }

            closeModal('taskEditorModal');
            renderTaskList();
            updateStatsPanel();
            renderOutline(); // Refresh outline to show task counts
            saveToLocalStorage();
            
            // Force immediate timeline refresh
            refreshTimelineIfVisible();
            refreshAllTaskViews();
            
            // Also refresh main page timeline if visible
            if (timelineBarVisible && typeof renderTimelineBar === 'function') {
                setTimeout(() => {
                    renderTimelineBar();
                }, 50);
            }
            
            // Force task manager timeline refresh if open
            const taskManagerModal = document.getElementById('taskManagerModal');
            const isTaskManagerOpen = taskManagerModal && taskManagerModal.style.display !== 'none';
            if (isTaskManagerOpen && typeof renderTaskTimeline === 'function') {
                setTimeout(() => {
                    renderTaskTimeline();
                    // Re-initialize drag handlers after timeline refresh
                    if (typeof initTimelineDragHandlers === 'function') {
                        initTimelineDragHandlers();
                    }
                }, 50);
            }
            
            // Update properties panel if visible and showing a task
            if (propEditingNodeId && typeof updatePropertiesPanel === 'function') {
                setTimeout(() => {
                    updatePropertiesPanel(propEditingNodeId);
                }, 100);
            }
            // Also update if selectedNode is set
            if (selectedNode && typeof updatePropertiesPanel === 'function') {
                setTimeout(() => {
                    updatePropertiesPanel(selectedNode);
                }, 100);
            }
        }

        function deleteTask(taskId) {
            if (confirm('Are you sure you want to delete this task?')) {
                tasks = tasks.filter(t => t.id !== taskId);
                renderTaskList();
                updateStatsPanel();
                saveToLocalStorage();
                refreshTimelineIfVisible();
            }
        }

        function filterTasks(status) {
            currentTaskFilter = status;
            // Don't reset sidebar filter, allow both filters to work together
            updateTaskFilterButtons();
            renderTaskList();
            refreshTimelineIfVisible();
        }

        function updateTaskFilterButtons() {
            document.querySelectorAll('.task-filter-btn').forEach(btn => {
                const filter = btn.dataset.filter;
                btn.classList.toggle('active',
                    (filter === 'all' && !currentTaskFilter) ||
                    filter === currentTaskFilter
                );
            });
        }

        function renderTaskList() {
            const container = document.getElementById('taskListContainer');

            // Get ONLY task nodes (isTaskNode must be true)
            const allTaskTypes = getAllTaskTypes();
            let taskNodes = nodes.filter(n => n.isTaskNode === true);

            // Apply status filter
            if (currentTaskFilter) {
                taskNodes = taskNodes.filter(t => t.taskStatus === currentTaskFilter);
            }
            
            // Apply sidebar node filter
            if (currentSidebarNodeFilter) {
                if (currentSidebarNodeFilter === 'orphan') {
                    // Show only orphan tasks (not linked to any node)
                    taskNodes = taskNodes.filter(t => !t.parentId && (!t.linkedNodeIds || t.linkedNodeIds.length === 0));
                } else {
                    // Show tasks linked to specific node
                    taskNodes = taskNodes.filter(t => {
                        const isLinked = t.parentId === currentSidebarNodeFilter || 
                                        (t.linkedNodeIds && t.linkedNodeIds.includes(currentSidebarNodeFilter));
                        const isConnected = connections.some(c => 
                            (c.from === t.id && c.to === currentSidebarNodeFilter) || 
                            (c.from === currentSidebarNodeFilter && c.to === t.id)
                        );
                        return isLinked || isConnected;
                    });
                }
            }

            if (taskNodes.length === 0) {
                container.innerHTML = `
                    <div class="task-empty-state">
                        <div class="icon">üìã</div>
                        <h3>No tasks found</h3>
                        <p>${currentTaskFilter ? 'No tasks with this status' : 'Click "+ New Task" to add a task node'}</p>
                    </div>
                `;
                return;
            }

            const html = taskNodes.map(task => {
                const statusInfo = TASK_STATUSES.find(s => s.id === task.taskStatus) || TASK_STATUSES[0];
                const importanceInfo = IMPORTANCE_LEVELS.find(i => i.id === task.taskPriority) || IMPORTANCE_LEVELS[1];
                const taskTypeInfo = allTaskTypes[task.type] || { icon: '‚ñ¢', name: 'Task' };
                
                // Sanitize icons and names
                const safeTypeIcon = sanitizeCorruptedIconEarly(taskTypeInfo.icon);
                const safeStatusIcon = sanitizeCorruptedIconEarly(statusInfo.icon);
                const safeStatusName = sanitizeText(statusInfo.name);
                const safeTitle = sanitizeText(task.title);

                // Calculate days remaining
                let daysRemaining = '';
                if (task.taskDateDue) {
                    const today = new Date();
                    const estimated = new Date(task.taskDateDue);
                    const diff = Math.ceil((estimated - today) / (1000 * 60 * 60 * 24));
                    if (diff < 0) {
                        daysRemaining = `<span style="color:#ef4444">${Math.abs(diff)} g√ºn gecikti</span>`;
                    } else if (diff === 0) {
                        daysRemaining = `<span style="color:#f59e0b">Bug√ºn!</span>`;
                    } else {
                        daysRemaining = `<span style="color:#22c55e">${diff} g√ºn kaldƒ±</span>`;
                    }
                }

                // Get linked node info
                let linkedNodeInfo = '';
                const linkedNodeId = task.linkedNodeIds?.[0] || task.parentId;
                if (linkedNodeId) {
                    const linkedNode = nodes.find(n => n.id === linkedNodeId);
                    if (linkedNode) {
                        linkedNodeInfo = `<div class="task-meta-item">üîó ${sanitizeText(linkedNode.title)}</div>`;
                    }
                }

                return `
                    <div class="task-item" style="border-left-color: ${statusInfo.color}">
                        <div class="task-item-header">
                            <div class="task-item-title">${safeTypeIcon} ${safeTitle}</div>
                            <div class="task-item-badges">
                                <span class="task-badge status" style="background:${statusInfo.color}20; color:${statusInfo.color}">${safeStatusName}</span>
                                <span class="task-badge importance-${task.taskPriority}">${sanitizeText(importanceInfo.name)}</span>
                            </div>
                        </div>
                        ${task.summary ? `<p style="color:#aaa; font-size:13px; margin-bottom:12px;">${task.summary}</p>` : ''}
                        <div class="task-item-meta">
                            ${task.taskAssignedBy ? `<div class="task-meta-item">üë§ ${task.taskAssignedBy}</div>` : ''}
                            ${task.taskDuration ? `<div class="task-meta-item">‚è±Ô∏è ${task.taskDuration} ${task.taskDurationType || 'hours'}</div>` : ''}
                            ${task.taskDateStart ? `<div class="task-meta-item">üìÖ Ba≈ülangƒ±√ß: ${task.taskDateStart}</div>` : ''}
                            ${daysRemaining ? `<div class="task-meta-item">üéØ ${daysRemaining}</div>` : ''}
                            ${linkedNodeInfo}
                            <div class="task-meta-item">
                                üìà ${task.taskProgress || 0}%
                                <div class="task-progress-bar">
                                    <div class="task-progress-fill" style="width:${task.taskProgress || 0}%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="task-item-actions">
                            <button class="task-action-btn" onclick="openTaskNodeEditor('${task.id}')">‚úèÔ∏è D√ºzenle</button>
                            <button class="task-action-btn" onclick="quickUpdateTaskNodeStatus('${task.id}')">üîÑ Durum</button>
                            <button class="task-action-btn" onclick="focusOnNode('${task.id}')">üéØ Git</button>
                            <button class="task-action-btn delete" onclick="deleteTaskNode('${task.id}')">üóëÔ∏è Sil</button>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function quickUpdateTaskStatus(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            const statusOptions = TASK_STATUSES.map(s => `${s.icon} ${s.name}`).join('\n');
            const currentStatus = TASK_STATUSES.find(s => s.id === task.status);

            const newStatusName = prompt(`Current status: ${currentStatus?.name || 'Unknown'}\n\nSelect new status:\n${TASK_STATUSES.map((s, i) => `${i + 1}. ${s.icon} ${s.name}`).join('\n')}\n\nEnter number (1-${TASK_STATUSES.length}):`);

            if (newStatusName) {
                const index = parseInt(newStatusName) - 1;
                if (index >= 0 && index < TASK_STATUSES.length) {
                    task.status = TASK_STATUSES[index].id;
                    task.dateUpdated = new Date().toISOString();
                    renderTaskList();
                    updateStatsPanel();
                    saveToLocalStorage();
                }
            }
        }

        // Quick update task node status from Task Manager
        function quickUpdateTaskNodeStatus(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            const currentStatus = TASK_STATUSES.find(s => s.id === node.taskStatus);

            const newStatusName = prompt(`Mevcut durum: ${currentStatus?.name || 'Bilinmiyor'}\n\nYeni durum se√ßin:\n${TASK_STATUSES.map((s, i) => `${i + 1}. ${s.icon} ${s.name}`).join('\n')}\n\nNumara girin (1-${TASK_STATUSES.length}):`);

            if (newStatusName) {
                const index = parseInt(newStatusName) - 1;
                if (index >= 0 && index < TASK_STATUSES.length) {
                    saveUndoState('change task status');
                    node.taskStatus = TASK_STATUSES[index].id;
                    renderNode(node);
                    renderTaskList();
                    updateStatsPanel();
                    renderOutline();
                    saveToLocalStorage();
                    showToast(`Durum deƒüi≈ütirildi: ${TASK_STATUSES[index].name}`);
                }
            }
        }

        // Focus on a node in canvas
        function focusOnNode(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Close Task Manager modal
            closeModal('taskManagerModal');

            // Center canvas on the node
            const nodeEl = document.getElementById(`node-${nodeId}`);
            if (nodeEl) {
                const canvasRect = canvasContainer.getBoundingClientRect();
                const nodeWidth = node.isTaskNode ? 300 : 200;
                const nodeHeight = nodeEl.offsetHeight || 150;

                canvasContainer.scrollLeft = node.x - (canvasRect.width / 2) + (nodeWidth / 2);
                canvasContainer.scrollTop = node.y - (canvasRect.height / 2) + (nodeHeight / 2);

                // Select and highlight the node
                selectNode(nodeId);

                // Add a temporary highlight effect
                nodeEl.style.boxShadow = '0 0 30px rgba(139, 92, 246, 0.8)';
                setTimeout(() => {
                    nodeEl.style.boxShadow = '';
                }, 1500);
            }
        }

        // Delete a task node
        function deleteTaskNode(nodeId) {
            if (!confirm('Bu task\'ƒ± silmek istediƒüinize emin misiniz?')) return;

            saveUndoState('delete task node');

            const nodeToDelete = nodes.find(n => n.id === nodeId);
            if (!nodeToDelete) return;

            // Move to trash
            const deletedNode = {
                ...nodeToDelete,
                deletedAt: new Date().toISOString(),
                deletedConnections: connections.filter(c => c.from === nodeId || c.to === nodeId)
            };
            trash.push(deletedNode);

            // Remove from nodes and connections
            nodes = nodes.filter(n => n.id !== nodeId);
            connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);

            const el = document.getElementById(`node-${nodeId}`);
            if (el) el.remove();

            renderConnections();
            renderTaskList();
            updateStatsPanel();
            renderOutline();
            saveToLocalStorage();
            showToast('Task silindi');
        }

        // Generic delete node function for Properties panel
        function deleteNodeById(nodeId) {
            if (!nodeId) return;
            if (!confirm('Bu karti silmek istediginize emin misiniz?')) return;

            saveUndoState('delete node');

            const nodeToDelete = nodes.find(n => n.id === nodeId);
            if (!nodeToDelete) return;

            // Move to trash
            const deletedNode = {
                ...nodeToDelete,
                deletedAt: new Date().toISOString(),
                deletedConnections: connections.filter(c => c.from === nodeId || c.to === nodeId)
            };
            trash.push(deletedNode);

            // Remove children's parent reference
            nodes.forEach(n => {
                if (n.parentId === nodeId) {
                    n.parentId = null;
                }
            });

            // Remove from nodes and connections
            const nId = String(nodeId);
            nodes = nodes.filter(n => String(n.id) !== nId);
            connections = connections.filter(c => String(c.from) !== nId && String(c.to) !== nId);

            // Remove DOM element
            const el = document.getElementById(`node-${nodeId}`);
            if (el) {
                el.remove();
            }

            // Clear selection and properties panel
            if (String(selectedNode) === nId) {
                selectedNode = null;
                hidePropertiesPanel();
            }

            // Immediately re-render everything
            renderConnections();
            renderTaskList();
            updateStatsPanel();
            renderOutline();
            
            saveToLocalStorage();
            showToast('Kart silindi');
        }

        function getTaskCountByStatus(status) {
            // Count task nodes by status
            const allTaskTypes = getAllTaskTypes();
            const taskNodes = nodes.filter(n => n.isTaskNode || allTaskTypes[n.type]);

            if (Array.isArray(status)) {
                return taskNodes.filter(t => status.includes(t.taskStatus)).length;
            }
            return taskNodes.filter(t => t.taskStatus === status).length;
        }

        // ============ OUTLINE ============
        function renderOutline() {
            const container = document.getElementById('outlineTree');

            // Build outline item HTML
            function buildOutlineItem(n, level) {
                const nodeIndex = nodes.findIndex(node => node.id === n.id);
                const hasChildren = getChildren(n.id).length > 0;
                const childCount = getChildren(n.id).length;
                const grandchildCount = countAllDescendants(n.id) - childCount;

                // Check if this is a task node
                const isTaskNode = n.isTaskNode || TASK_NODE_TYPES[n.type];
                // Check if this is a special node (folder, sticky, image)
                const isSpecialNode = SPECIAL_NODE_TYPES && SPECIAL_NODE_TYPES[n.type];

                // Count tasks assigned to this node (only for regular nodes)
                const nodeTasks = !isTaskNode ? tasks.filter(t => t.assignedNodeId === n.id) : [];
                const taskCount = nodeTasks.length;
                const pendingTasks = nodeTasks.filter(t => t.status !== 'complete' && t.status !== 'done').length;
                const urgentTasks = nodeTasks.filter(t => t.status === 'urgent').length;

                // Task badge HTML for regular nodes
                let taskBadge = '';
                if (taskCount > 0) {
                    let badgeColor = pendingTasks > 0 ? '#f59e0b' : '#22c55e';
                    if (urgentTasks > 0) badgeColor = '#ef4444';
                    taskBadge = `<span class="outline-task-badge" style="background:${badgeColor}" onclick="event.stopPropagation(); showNodeTasks('${n.id}')" title="${taskCount} task(s), ${pendingTasks} pending">üìã${taskCount}</span>`;
                }

                // For task nodes, show status and progress
                let statusBadge = '';
                let statusCircle = '';
                if (isTaskNode) {
                    const statusInfo = TASK_STATUSES.find(s => s.id === n.taskStatus) || TASK_STATUSES[0];
                    const progress = n.taskProgress || 0;
                    const safeIcon = sanitizeCorruptedIconEarly(statusInfo.icon);
                    const safeName = sanitizeText(statusInfo.name);
                    statusBadge = `<span class="outline-task-badge" style="background:${statusInfo.color}" title="${safeName} - ${progress}%">${safeIcon} ${progress}%</span>`;
                    statusCircle = `<span class="outline-status-circle" style="background:${statusInfo.color};" title="${safeName}"></span>`;
                } else if (!isSpecialNode) {
                    // Regular section nodes - show status circle
                    const sectionStatus = n.sectionStatus || 'none';
                    const statusInfo = SECTION_STATUSES.find(s => s.id === sectionStatus) || SECTION_STATUSES[0];
                    statusCircle = `<span class="outline-status-circle" style="background:${statusInfo.color};" title="${statusInfo.name}"></span>`;
                }

                let toggleBtn = '';
                if (hasChildren) {
                    const arrow = n.collapsed ? '‚ñ∂' : '‚ñº';
                    const countStr = grandchildCount > 0 ? `${childCount}+${grandchildCount}` : `${childCount}`;
                    toggleBtn = `<span class="toggle-btn" onclick="event.stopPropagation(); toggleCollapse('${n.id}')">${arrow} ${countStr}</span>`;
                }

                // Get icon for node type
                let typeIcon;
                if (isSpecialNode) {
                    typeIcon = SPECIAL_NODE_TYPES[n.type]?.icon || 'üìÑ';
                } else if (isTaskNode) {
                    typeIcon = TASK_NODE_TYPES[n.type]?.icon || 'üìã';
                } else {
                    typeIcon = { section: 'üìÑ', group: 'üìÅ', note: 'üìù', draft: '‚úèÔ∏è', research: 'üî¨', reference: 'üìö', introduction: 'üé¨', conclusion: 'üèÅ', appendix: 'üìé', abstract: 'üìã' }[n.type] || 'üìÑ';
                }

                const cls = `outline-item ${selectedNode === n.id ? 'active' : ''} ${isTaskNode ? 'task-outline-item' : ''} ${isSpecialNode ? 'special-outline-item' : ''}`;
                const indent = level * 18;
                
                // Node color for left border
                const nodeColor = n.color || (isTaskNode ? (TASK_NODE_TYPES[n.type]?.color || '#8b5cf6') : '#3b82f6');
                const borderStyle = `border-left: 3px solid ${nodeColor};`;

                return `<div class="${cls}"
                    data-index="${nodeIndex}"
                    data-id="${n.id}"
                    data-parent="${n.parentId || ''}"
                    data-level="${level}"
                    data-type="${n.type}"
                    draggable="true"
                    style="padding-left: ${14 + indent}px; ${borderStyle}"
                    onclick="selectNode('${n.id}'); focusNode('${n.id}')"
                    ondblclick="${isSpecialNode ? `openSpecialNodeEditor('${n.id}')` : (isTaskNode ? `openTaskNodeEditor('${n.id}')` : `openFullEditor('${n.id}')`)}"
                    ondragstart="handleOutlineDragStart(event)"
                    ondragover="handleOutlineDragOver(event)"
                    ondragleave="handleOutlineDragLeave(event)"
                    ondrop="handleOutlineDrop(event)"
                    ondragend="handleOutlineDragEnd(event)">
                    ${toggleBtn}
                    <span class="outline-title">${typeIcon} ${n.title}</span>
                    ${taskBadge}
                    ${statusBadge}
                    ${statusCircle}
                </div>`;
            }

            // Check if a task should be shown as root (no parent and no task dependencies)
            function isRootNode(n) {
                // Has explicit parent
                if (n.parentId) return false;
                
                // If it's a task node with dependencies, it's not root
                if ((n.isTaskNode || TASK_NODE_TYPES[n.type]) && n.taskDependencies && n.taskDependencies.length > 0) {
                    // Check if any of its dependencies is also a task
                    const hasPredecessorTask = n.taskDependencies.some(d => {
                        const depNode = nodes.find(dn => String(dn.id) === String(d.taskId));
                        return depNode && (depNode.isTaskNode || TASK_NODE_TYPES[depNode.type]);
                    });
                    if (hasPredecessorTask) return false;
                }
                
                return true;
            }

            // Hierarchical tree rendering - includes task dependencies
            function renderNodeTree(parentId, level = 0, renderedIds = new Set()) {
                let children;
                
                if (parentId === null) {
                    // Root level - get nodes without parent and without task predecessors
                    children = nodes.filter(n => isRootNode(n));
                } else {
                    // Get all children including dependency-based children
                    children = getChildren(parentId);
                }
                
                if (children.length === 0) return '';

                let html = '';
                children.forEach(n => {
                    // Prevent infinite loops and duplicate rendering
                    if (renderedIds.has(String(n.id))) return;
                    renderedIds.add(String(n.id));
                    
                    html += buildOutlineItem(n, level);
                    const nodeChildren = getChildren(n.id);
                    const hasChildren = nodeChildren.length > 0;
                    if (hasChildren && !n.collapsed) {
                        html += renderNodeTree(n.id, level + 1, renderedIds);
                    }
                });
                return html;
            }

            // Start from root nodes
            const renderedIds = new Set();
            const rootHtml = renderNodeTree(null, 0, renderedIds);
            container.innerHTML = rootHtml || '<div style="padding: 20px; color: #666; text-align: center;">No items yet</div>';
        }

        // Outline Drag & Drop - supports hierarchy changes
        function handleOutlineDragStart(e) {
            const item = e.target.closest('.outline-item');
            if (!item) return;
            draggedOutlineItem = item;
            item.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', item.dataset.id);
        }

        function handleOutlineDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const item = e.target.closest('.outline-item');
            if (item && item !== draggedOutlineItem) {
                const rect = item.getBoundingClientRect();
                const thirdHeight = rect.height / 3;

                document.querySelectorAll('.outline-item').forEach(el => {
                    el.classList.remove('drag-over', 'drag-over-bottom', 'drag-over-child');
                });

                // Top third = insert before, middle = make child, bottom third = insert after
                if (e.clientY < rect.top + thirdHeight) {
                    item.classList.add('drag-over'); // Insert before
                } else if (e.clientY > rect.bottom - thirdHeight) {
                    item.classList.add('drag-over-bottom'); // Insert after
                } else {
                    item.classList.add('drag-over-child'); // Make child of this item
                }
            }
        }

        function handleOutlineDragLeave(e) {
            const item = e.target.closest('.outline-item');
            if (item) {
                item.classList.remove('drag-over', 'drag-over-bottom', 'drag-over-child');
            }
        }

        function handleOutlineDrop(e) {
            e.preventDefault();

            const targetItem = e.target.closest('.outline-item');
            if (!targetItem || !draggedOutlineItem) return;

            const draggedId = draggedOutlineItem.dataset.id;
            const targetId = targetItem.dataset.id;

            if (draggedId === targetId) return;

            const draggedNode = nodes.find(n => n.id === draggedId);
            const targetNode = nodes.find(n => n.id === targetId);
            if (!draggedNode || !targetNode) return;

            // Prevent making a parent a child of its own descendant
            function isDescendant(parentId, childId) {
                const child = nodes.find(n => n.id === childId);
                if (!child || !child.parentId) return false;
                if (child.parentId === parentId) return true;
                return isDescendant(parentId, child.parentId);
            }

            if (isDescendant(draggedId, targetId)) {
                showToast('‚ùå Cannot move parent into its own child');
                return;
            }

            const rect = targetItem.getBoundingClientRect();
            const thirdHeight = rect.height / 3;

            if (e.clientY < rect.top + thirdHeight) {
                // Insert BEFORE target - same parent as target
                draggedNode.parentId = targetNode.parentId;
                showToast('üìã Moved before');
            } else if (e.clientY > rect.bottom - thirdHeight) {
                // Insert AFTER target - same parent as target
                draggedNode.parentId = targetNode.parentId;
                showToast('üìã Moved after');
            } else {
                // Make CHILD of target
                draggedNode.parentId = targetId;
                // Expand target so child is visible
                targetNode.collapsed = false;
                showToast('üìÅ Made child of ' + targetNode.title);
            }

            renderOutline();
            renderAll();
            renderConnections();

            document.querySelectorAll('.outline-item').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-bottom', 'drag-over-child', 'dragging');
            });
        }

        function handleOutlineDragEnd(e) {
            document.querySelectorAll('.outline-item').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-bottom', 'drag-over-child', 'dragging');
            });
            draggedOutlineItem = null;
        }

        function focusNode(id) {
            const nid = String(id);
            selectNode(id);
            const node = nodes.find(n => String(n.id) === nid);
            if (!node) {
                console.error('focusNode: Node not found:', id);
                return;
            }

            // Update properties panel title to show selected node
            const panelTitle = document.querySelector('.properties-title');
            if (panelTitle) {
                panelTitle.innerHTML = `üìã Properties <span style="color: #8b5cf6; font-weight: 600; margin-left: 8px;">‚Üí ${escapeHtml(node.title)}</span>`;
            }

            // Get the node element
            const el = document.getElementById(`node-${id}`);
            if (el) {
                // Get node position and dimensions (use actual DOM measurements)
                const nodeX = node.x || 0;
                const nodeY = node.y || 0;
                const nodeW = el.offsetWidth || 240;
                const nodeH = el.offsetHeight || 200;
                
                // Get container dimensions
                const containerW = canvasContainer.clientWidth;
                const containerH = canvasContainer.clientHeight;
                
                // Calculate optimal zoom to fit the node nicely (with padding)
                const padding = 150; // Padding around the node
                const nodeWidthWithPadding = nodeW + padding * 2;
                const nodeHeightWithPadding = nodeH + padding * 2;
                
                // Calculate zoom needed to fit node in view (accounting for current zoom)
                const zoomX = (containerW / nodeWidthWithPadding);
                const zoomY = (containerH / nodeHeightWithPadding);
                const optimalZoom = Math.min(zoomX, zoomY, 1.2); // Max zoom 120%
                
                // Apply zoom if it's reasonable (between 0.4 and 1.2)
                if (optimalZoom >= 0.4 && optimalZoom <= 1.2) {
                    zoom = Math.max(optimalZoom, 0.4); // Minimum zoom 40%
                    applyCanvasZoom();
                }
                
                // Wait a bit for zoom to apply, then center
                setTimeout(() => {
                    // Calculate center of node (in canvas coordinates)
                    const centerX = nodeX + nodeW / 2;
                    const centerY = nodeY + nodeH / 2;
                    
                    // Calculate scroll position to center the node (accounting for zoom)
                    const scrollX = (centerX * zoom) - (containerW / 2);
                    const scrollY = (centerY * zoom) - (containerH / 2);
                    
                    // Smooth scroll to position
                    canvasContainer.scrollTo({
                        left: Math.max(0, scrollX),
                        top: Math.max(0, scrollY),
                        behavior: 'smooth'
                    });
                }, 50);
                
                // Add strong visual highlight with pulse effect
                el.style.transition = 'box-shadow 0.3s, transform 0.3s';
                el.style.boxShadow = '0 0 50px rgba(139, 92, 246, 1), 0 0 100px rgba(139, 92, 246, 0.7), 0 0 150px rgba(139, 92, 246, 0.4)';
                el.style.transform = 'scale(1.08)';
                el.classList.add('node-focused');
                
                // Show toast notification
                showToast(`üìç ${escapeHtml(node.title)} konumuna gidildi`);
                
                // Remove highlight after animation (but keep selected class)
                setTimeout(() => {
                    el.style.boxShadow = '';
                    el.style.transform = '';
                    el.classList.remove('node-focused');
                }, 2500);
            }

            // Also show Properties Panel
            const panel = document.getElementById('propertiesPanel');
            if (panel && !panel.classList.contains('active')) {
                propertiesPanelVisible = true;
                panel.classList.add('active');
            }
            updatePropertiesPanel(id);
        }

        function switchTab(tab) {
            // Update tab styling
            document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
            const tabBtn = document.querySelector(`.panel-tab[onclick="switchTab('${tab}')"]`);
            if (tabBtn) tabBtn.classList.add('active');

            // Hide all panels first
            document.querySelectorAll('.panel-content').forEach(p => {
                p.classList.remove('active-panel');
            });

            // Show selected panel
            const panelId = tab + 'Panel';
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.classList.add('active-panel');
            }

            // Update file panel stats when switching to it
            if (tab === 'file') {
                updateFilePanelStats();
            }
        }

        function updateFilePanelStats() {
            document.getElementById('fileNodeCount').textContent = nodes.length;
            let totalWords = 0;
            nodes.forEach(node => {
                const text = (node.fullText || '').replace(/<[^>]*>/g, ' ');
                totalWords += text.split(/\s+/).filter(w => w.length > 0).length;
            });
            document.getElementById('fileWordCount').textContent = totalWords.toLocaleString();
        }

        function newFile() {
            if (nodes.length > 0) {
                if (!confirm('Mevcut √ßalƒ±≈üma kaydedilmedi. Yeni proje olu≈üturulsun mu?')) return;
            }
            
            // Ask for project name
            const projectName = prompt('Yeni Proje Adƒ±:', 'Yeni Proje');
            if (!projectName) return;
            
            const projectDesc = prompt('Proje A√ßƒ±klamasƒ± (isteƒüe baƒülƒ±):', '');
            
            // Clear all data
            nodes = [];
            connections = [];
            trash = [];
            currentProjectName = projectName;
            currentFileHandle = null;
            lastSavedURL = null;
            selectedNode = null;
            window.projectMetadata = {
                name: projectName,
                description: projectDesc || '',
                wordTarget: 50000,
                deadline: null,
                createdAt: new Date().toISOString()
            };
            
            // Clear canvas DOM elements
            const canvas = document.getElementById('canvas');
            const nodeElements = canvas.querySelectorAll('.node, .task-node-card, .folder-node, .sticky-node, .image-node');
            nodeElements.forEach(el => el.remove());
            
            // Clear connections SVG
            const connectionsEl = document.getElementById('connections');
            if (connectionsEl) connectionsEl.innerHTML = '';
            
            // Clear outline
            const outlineTree = document.getElementById('outlineTree');
            if (outlineTree) outlineTree.innerHTML = '<div style="color:#888; text-align:center; padding:20px;">No items yet</div>';
            
            // Clear stats
            const statsContent = document.getElementById('statsContent');
            if (statsContent) statsContent.innerHTML = '<div style="color:#888; text-align:center; padding:40px;">No data</div>';
            
            // Reset UI
            document.getElementById('currentFileName').textContent = projectName + '.json';
            hidePropertiesPanel();
            
            // Remove old session data
            localStorage.removeItem('writerLastSession');
            
            renderAll();
            renderConnections();
            updateAllStats();
            renderOutline();
            updateFilePanelStats();
            
            showToast('‚ú® Yeni proje olu≈üturuldu: ' + projectName);
        }
        
        function closeProject() {
            if (nodes.length > 0) {
                if (!confirm('Projeyi kapatmak istediƒüinize emin misiniz? Kaydedilmemi≈ü deƒüi≈üiklikler kaybolacak.')) return;
            }
            
            nodes = [];
            connections = [];
            trash = [];
            currentProjectName = 'Untitled';
            currentFileHandle = null;
            lastSavedURL = null;
            window.projectMetadata = {};
            selectedNode = null;
            
            // Clear canvas DOM elements
            const canvas = document.getElementById('canvas');
            const nodeElements = canvas.querySelectorAll('.node, .task-node-card, .folder-node, .sticky-node, .image-node');
            nodeElements.forEach(el => el.remove());
            
            // Clear connections SVG
            const connectionsEl = document.getElementById('connections');
            if (connectionsEl) {
                connectionsEl.innerHTML = '';
            }
            
            // Clear outline
            const outlineTree = document.getElementById('outlineTree');
            if (outlineTree) {
                outlineTree.innerHTML = '<div style="color:#888; text-align:center; padding:20px;">No items yet</div>';
            }
            
            // Clear stats panel content
            const statsContent = document.getElementById('statsContent');
            if (statsContent) {
                statsContent.innerHTML = '<div style="color:#888; text-align:center; padding:40px;">No data</div>';
            }

            // Reset UI
            document.getElementById('currentFileName').textContent = 'No file opened';
            hidePropertiesPanel();
            
            // Clear session storage
            localStorage.removeItem('writerLastSession');
            
            showToast('üìï Proje kapatƒ±ldƒ±');
        }

        // ============ POV & DESC MANAGERS ============
        function openPovManager() {
            renderPovManagerList();
            document.getElementById('povManagerModal').classList.add('active');
        }

        function renderPovManagerList() {
            const container = document.getElementById('povManagerList');
            container.innerHTML = povList.map(p => `
                <div class="manager-item">
                    <div class="color-preview" style="background:${p.color}"></div>
                    <div class="item-info">
                        <div class="item-name">${p.name}</div>
                        <div class="item-desc">${p.desc || ''}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editPov(${p.id})">‚úèÔ∏è</button>
                        <button onclick="deletePov(${p.id})">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function editPov(id) {
            editingPovId = id;
            const p = povList.find(x => x.id === id);
            document.getElementById('povFormTitle').textContent = 'Edit Author';
            document.getElementById('povNameInput').value = p.name;
            document.getElementById('povColorInput').value = p.color;
            document.getElementById('povDescInput').value = p.desc || '';
        }

        function savePov() {
            const name = document.getElementById('povNameInput').value.trim();
            const color = document.getElementById('povColorInput').value;
            const desc = document.getElementById('povDescInput').value.trim();

            if (!name) { showToast('Name required'); return; }

            if (editingPovId) {
                const p = povList.find(x => x.id === editingPovId);
                p.name = name; p.color = color; p.desc = desc;
            } else {
                povList.push({ id: idCounter.pov++, name, color, desc });
            }

            editingPovId = null;
            document.getElementById('povFormTitle').textContent = 'Add New Author';
            document.getElementById('povNameInput').value = '';
            document.getElementById('povDescInput').value = '';

            renderPovManagerList();
            updateSelects();
            renderAll();
            showToast('Kaydedildi');
        }

        function deletePov(id) {
            if (!confirm('Bu POV\'u sil?')) return;
            povList = povList.filter(p => p.id !== id);
            nodes.forEach(n => { if (n.povId === id) n.povId = null; });
            renderPovManagerList();
            updateSelects();
            renderAll();
        }

        function openDescManager() {
            renderDescManagerList();
            document.getElementById('descManagerModal').classList.add('active');
        }

        function renderDescManagerList() {
            const container = document.getElementById('descManagerList');
            container.innerHTML = descTypes.map(d => `
                <div class="manager-item">
                    <span style="font-size:1.5em">${d.icon}</span>
                    <div class="item-info">
                        <div class="item-name">${d.name}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editDescType(${d.id})">‚úèÔ∏è</button>
                        <button onclick="deleteDescType(${d.id})">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function editDescType(id) {
            editingDescTypeId = id;
            const d = descTypes.find(x => x.id === id);
            document.getElementById('descFormTitle').textContent = 'Edit Type';
            document.getElementById('descNameInput').value = d.name;
            document.getElementById('descIconInput').value = d.icon;
            document.getElementById('descColorInput').value = d.color;
        }

        function saveDescType() {
            const name = document.getElementById('descNameInput').value.trim();
            const icon = document.getElementById('descIconInput').value;
            const color = document.getElementById('descColorInput').value;

            if (!name) { showToast('Name required'); return; }

            if (editingDescTypeId) {
                const d = descTypes.find(x => x.id === editingDescTypeId);
                d.name = sanitizeText(name); 
                d.icon = sanitizeCorruptedIconEarly(icon); 
                d.color = color;
            } else {
                descTypes.push({ 
                    id: idCounter.desc++, 
                    name: sanitizeText(name), 
                    icon: sanitizeCorruptedIconEarly(icon), 
                    color: color 
                });
            }

            editingDescTypeId = null;
            document.getElementById('descFormTitle').textContent = 'Add New Type';
            document.getElementById('descNameInput').value = '';

            renderDescManagerList();
            updateSelects();
            renderAll();
            showToast('Kaydedildi');
        }

        function deleteDescType(id) {
            if (!confirm('Delete this type?')) return;
            descTypes = descTypes.filter(d => d.id !== id);
            nodes.forEach(n => { n.descs = n.descs.filter(d => d.tid !== id); });
            renderDescManagerList();
            updateSelects();
            renderAll();
        }

        function updateSelects() {
            const povOpts = '<option value="">‚Äî Author ‚Äî</option>' + povList.map(p => `<option value="${p.id}">${p.name}</option>`).join('');
            document.getElementById('editPov').innerHTML = povOpts;

            const descOpts = '<option value="">‚Äî Type ‚Äî</option>' + descTypes.map(d => `<option value="${d.id}">${d.icon} ${escapeHtml(d.name)}</option>`).join('');
            document.getElementById('newDescType').innerHTML = descOpts;
        }

        // ============ PROPERTIES PANEL STATE ============
        let propertiesPanelVisible = false;

        // ============ NODE OPERATIONS ============
        function selectNode(id) {
            selectedNode = id;
            // Remove selection from both regular nodes and task node cards
            document.querySelectorAll('.node, .task-node-card').forEach(n => n.classList.remove('selected'));
            const el = document.getElementById(`node-${id}`);
            if (el) el.classList.add('selected');

            document.querySelectorAll('.outline-item').forEach(i => i.classList.remove('active'));

            // Update Properties Panel if visible (check both variable and DOM state)
            const panel = document.getElementById('propertiesPanel');
            const isPanelVisible = propertiesPanelVisible || (panel && panel.classList.contains('active'));

            if (isPanelVisible) {
                propertiesPanelVisible = true; // Sync variable with DOM state
                // Find node and update panel
                const node = nodes.find(n => String(n.id) === String(id));
                if (node) {
                    updatePropertiesPanel(id);
                    // Force a second refresh on next frame to ensure image previews update
                    requestAnimationFrame(() => {
                        if (String(selectedNode) === String(id)) {
                    updatePropertiesPanel(id);
                        }
                    });
                }
            }
        }

        // ============ PROPERTIES PANEL ============
        let propEditingNodeId = null;
        let propOriginalValues = null;
        let propOriginalConnections = null; // Store original connections for cancel

        function togglePropertiesPanel() {
            propertiesPanelVisible = !propertiesPanelVisible;
            const panel = document.getElementById('propertiesPanel');
            const menuLabel = document.getElementById('propertiesPanelMenuLabel');
            const zoomControls = document.getElementById('zoomControls');

            if (propertiesPanelVisible) {
                panel.classList.add('active');
                if (menuLabel) menuLabel.textContent = 'Hide Properties Panel';
                if (selectedNode) {
                    updatePropertiesPanel(selectedNode);
                }
                // Move zoom controls left to avoid overlap
                if (zoomControls) zoomControls.style.right = '340px';
                localStorage.setItem('propertiesPanelVisible', 'true');
            } else {
                panel.classList.remove('active');
                if (menuLabel) menuLabel.textContent = 'Show Properties Panel';
                // Reset zoom controls position
                if (zoomControls) zoomControls.style.right = '20px';
                localStorage.setItem('propertiesPanelVisible', 'false');
            }
        }

        function updatePropertiesPanel(nodeId) {
            const container = document.getElementById('propertiesContent');
            if (!container) return;

            // Find node with flexible ID comparison
            const node = nodes.find(n => String(n.id) === String(nodeId));
            // Use the actual node.id for consistency
            const id = node ? node.id : nodeId;

            // Update properties panel title
            const panelTitle = document.querySelector('.properties-title');
            if (panelTitle) {
                if (node) {
                    panelTitle.innerHTML = `üìã Properties <span style="color: #8b5cf6; font-weight: 600; margin-left: 8px;">‚Üí ${escapeHtml(node.title)}</span>`;
                } else {
                    panelTitle.innerHTML = 'üìã Properties';
                }
            }

            if (!node) {
                container.innerHTML = `
                    <div class="properties-empty">
                        <span style="font-size:2em; opacity:0.3;">üìÑ</span>
                        <p>Select a card to view and edit its properties</p>
                    </div>
                `;
                return;
            }

            const words = countWords(node.fullText);
            const chars = (node.fullText || '').length;
            const target = node.target || 0;
            const progress = target > 0 ? Math.min(Math.round((words / target) * 100), 100) : 0;

            // Check if this is a special node (folder, sticky, image)
            const isSpecialNode = SPECIAL_NODE_TYPES[node.type] || SPECIAL_NODE_TYPES[node.nodeType] || 
                                  node.nodeType === 'folder' || node.nodeType === 'sticky' || node.nodeType === 'image';

            // If it's a special node, show special-specific properties
            if (isSpecialNode) {
                renderSpecialNodeProperties(container, node, nodeId);
                return;
            }

            // Check if this is a task node
            const isTaskNode = node.isTaskNode || TASK_NODE_TYPES[node.type];

            // If it's a task node, show task-specific properties
            if (isTaskNode) {
                renderTaskNodeProperties(container, node, nodeId);
                return;
            }

            // Get POV options
            const povOptions = povList.map(p =>
                `<option value="${p.id}" ${node.povId === p.id ? 'selected' : ''}>${p.name}</option>`
            ).join('');

            // Get type options
            const typeOptions = ['section', 'note', 'draft', 'research', 'reference', 'abstract', 'introduction', 'conclusion', 'appendix', 'group'].map(t =>
                `<option value="${t}" ${node.type === t ? 'selected' : ''}>${t.charAt(0).toUpperCase() + t.slice(1)}</option>`
            ).join('');

            // Get tags - support both old format (just ID) and new format ({tid, val})
            const tagHtml = (node.descs || []).map((descItem, index) => {
                // Handle both formats
                const tid = typeof descItem === 'object' ? descItem.tid : descItem;
                const val = typeof descItem === 'object' ? descItem.val : null;
                const desc = descTypes.find(d => d.id === tid);
                if (!desc) return '';
                const displayName = val || desc.name;
                return `<span class="prop-tag" style="background:${desc.color}">${desc.icon} ${escapeHtml(displayName)} <span class="prop-tag-remove" onclick="removeTagFromNode(${nodeId}, ${index})">√ó</span></span>`;
            }).join('');

            // Get status options for section nodes
            const sectionStatus = node.sectionStatus || 'none';
            const statusOptions = SECTION_STATUSES.map(s =>
                `<option value="${s.id}" ${sectionStatus === s.id ? 'selected' : ''}>${s.icon} ${s.name}</option>`
            ).join('');

            // Store original values for cancel
            propEditingNodeId = nodeId;
            propOriginalValues = {
                title: node.title,
                type: node.type,
                summary: node.summary || '',
                povId: node.povId,
                target: node.target || 0,
                fullText: node.fullText || '',
                notes: node.notes || '',
                parentId: node.parentId,
                sectionStatus: node.sectionStatus || 'none'
            };
            // Store connections state for cancel
            propOriginalConnections = {
                connections: JSON.parse(JSON.stringify(connections)),
                nodeParentIds: nodes.map(n => ({ id: n.id, parentId: n.parentId }))
            };

            container.innerHTML = `
                <!-- Stats -->
                <div class="prop-group">
                    <div class="prop-group-title">Statistics</div>
                    <div class="prop-stats">
                        <div class="prop-stat">
                            <div class="prop-stat-value">${words}</div>
                            <div class="prop-stat-label">Words</div>
                        </div>
                        <div class="prop-stat">
                            <div class="prop-stat-value">${chars}</div>
                            <div class="prop-stat-label">Characters</div>
                        </div>
                    </div>
                    ${target > 0 ? `
                    <div style="margin-top:10px;">
                        <div style="display:flex; justify-content:space-between; font-size:12px; color:#888; margin-bottom:4px;">
                            <span>Progress</span>
                            <span>${words}/${target} (${progress}%)</span>
                        </div>
                        <div style="height:6px; background:#2a2a40; border-radius:3px; overflow:hidden;">
                            <div style="height:100%; width:${progress}%; background:${progress >= 100 ? '#4ade80' : '#6366f1'}; transition:width 0.3s;"></div>
                        </div>
                    </div>
                    ` : ''}
                </div>

                <!-- Basic Info -->
                <div class="prop-group">
                    <div class="prop-group-title">Basic Info</div>
                    <div class="prop-row">
                        <label class="prop-label">Title</label>
                        <input type="text" class="prop-input" id="propTitle" value="${escapeHtml(node.title)}">
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">Type</label>
                        <select class="prop-select" id="propType">
                            ${typeOptions}
                        </select>
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">Status</label>
                        <select class="prop-select" id="propSectionStatus">
                            ${statusOptions}
                        </select>
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">Summary</label>
                        <textarea class="prop-input" id="propSummary" style="min-height:60px; resize:none; overflow-y:hidden; line-height:1.5;">${escapeHtml(node.summary || '')}</textarea>
                    </div>
                </div>

                <!-- Author & Target -->
                <div class="prop-group">
                    <div class="prop-group-title">Author & Target</div>
                    <div class="prop-row">
                        <label class="prop-label">Author/POV</label>
                        <select class="prop-select" id="propPovId">
                            <option value="">‚Äî Select Author ‚Äî</option>
                            ${povOptions}
                        </select>
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">Word Target</label>
                        <input type="number" class="prop-input" id="propTarget" value="${target}" min="0">
                    </div>
                </div>

                <!-- Tags -->
                <div class="prop-group">
                    <div class="prop-group-title">Tags</div>
                    <div class="prop-tags" id="propTagsContainer">
                        ${tagHtml || '<span style="color:#666; font-size:12px;">No tags</span>'}
                    </div>
                    <div class="prop-row" style="margin-top:12px; gap:12px;">
                        <select class="prop-select" id="propTagSelect" style="flex:1;">
                            <option value="">‚Äî Tip Se√ß ‚Äî</option>
                            ${descTypes.map(d => `<option value="${d.id}">${d.icon} ${escapeHtml(d.name)}</option>`).join('')}
                        </select>
                    </div>
                    <div class="prop-row" style="margin-top:10px; gap:12px;">
                        <input type="text" class="prop-input" id="propTagValue" placeholder="Deƒüer..." style="flex:1;">
                        <button class="prop-btn" onclick="addTagToNodeFromPanel('${nodeId}')" style="padding:8px 16px; flex:0; background:#22c55e;">+</button>
                    </div>
                </div>

                <!-- Node Connections -->
                <div class="prop-group">
                    <div class="prop-group-title">üîó Baƒülantƒ±lar</div>
                    <div id="propNodeConnections" style="max-height:200px; overflow-y:auto;">
                        ${renderNodeConnections(node)}
                    </div>
                </div>

                <!-- Content Preview -->
                <div class="prop-group">
                    <div class="prop-group-title">Content</div>
                    <textarea class="prop-textarea" id="propFullText" placeholder="Write content here...">${htmlToPlainText(node.fullText || '')}</textarea>
                </div>

                <!-- Notes -->
                <div class="prop-group">
                    <div class="prop-group-title">Notes</div>
                    <textarea class="prop-textarea" id="propNotes" style="min-height:80px;" placeholder="Personal notes...">${escapeHtml(node.notes || '')}</textarea>
                </div>

                <!-- Apply/Cancel Buttons -->
                <div class="prop-group" style="position:sticky; bottom:0; background:#1e1e2e; padding:15px 0; margin:0 -16px; padding:15px 16px; border-top:1px solid #333;">
                    <div style="display:flex; gap:10px;">
                        <button class="prop-btn" onclick="applyPropertiesChanges()" style="flex:1;">‚úì Apply</button>
                        <button class="prop-btn" onclick="cancelPropertiesChanges()" style="flex:1; background:#444;">‚úï Cancel</button>
                    </div>
                </div>

                <!-- Actions -->
                <div class="prop-group" style="margin-top:10px;">
                    <button class="prop-btn" onclick="openFullEditor('${nodeId}')" style="background:#6366f1;">Open Full Editor</button>
                    <button class="prop-btn prop-btn-danger" onclick="deleteNodeById('${nodeId}')" style="margin-top:8px;">Delete Card</button>
                </div>
            `;

            // Auto-expand summary textarea based on content
            setTimeout(() => {
                const summaryTextarea = document.getElementById('propSummary');
                if (summaryTextarea) {
                    // Function to auto-resize
                    const autoResize = (el) => {
                        el.style.height = 'auto';
                        el.style.height = Math.max(60, el.scrollHeight) + 'px';
                    };
                    // Initial resize
                    autoResize(summaryTextarea);
                    // Resize on input
                    summaryTextarea.addEventListener('input', () => autoResize(summaryTextarea));
                }
            }, 0);
        }

        // Apply changes from Properties panel
        function applyPropertiesChanges() {
            if (!propEditingNodeId) return;

            const node = nodes.find(n => n.id === propEditingNodeId);
            if (!node) return;

            saveUndoState('update properties');

            // Get values from form
            const title = document.getElementById('propTitle')?.value || '';
            const type = document.getElementById('propType')?.value || 'section';
            const summary = document.getElementById('propSummary')?.value || '';
            const sectionStatus = document.getElementById('propSectionStatus')?.value || 'none';
            const povIdStr = document.getElementById('propPovId')?.value;
            const povId = povIdStr ? parseInt(povIdStr) : null;
            const target = parseInt(document.getElementById('propTarget')?.value) || 0;
            const fullText = document.getElementById('propFullText')?.value || '';
            const notes = document.getElementById('propNotes')?.value || '';

            // Apply changes
            node.title = title;
            node.type = type;
            node.summary = summary;
            node.sectionStatus = sectionStatus;
            node.povId = povId;
            node.target = target;
            node.fullText = fullText;
            node.notes = notes;

            // Update UI
            renderNode(node);
            renderConnections();
            renderOutline();
            autoSave();

            // Clear stored original state - changes are now permanent
            propOriginalConnections = null;

            showToast('‚úì Deƒüi≈üiklikler uygulandƒ±');
        }

        // Render Special Node Properties Panel (Folder, Sticky, Image)
        function renderSpecialNodeProperties(container, node, nodeId) {
            const typeInfo = SPECIAL_NODE_TYPES[node.type] || { icon: 'üìÑ', name: 'Node', color: '#888' };

            propEditingNodeId = nodeId;
            propOriginalValues = {
                title: node.title,
                summary: node.summary || '',
                stickyColor: node.stickyColor,
                stickyTag: node.stickyTag,
                imageCaption: node.imageCaption,
                parentId: node.parentId
            };
            // Store connections state for cancel
            propOriginalConnections = {
                connections: JSON.parse(JSON.stringify(connections)),
                nodeParentIds: nodes.map(n => ({ id: n.id, parentId: n.parentId }))
            };

            let typeSpecificHtml = '';

            if (node.type === 'folder') {
                // FOLDER Properties
                const files = node.folderFiles || [];
                const folderColor = node.folderColor || 'blue';
                const folderType = node.folderType || 'general';

                // Folder color options
                const colorOptionsHtml = FOLDER_COLORS.map(c =>
                    `<div onclick="updateFolderColor('${nodeId}', '${c.id}')" style="width:28px; height:28px; background:${c.color}; border-radius:6px; cursor:pointer; border:3px solid ${folderColor === c.id ? '#fff' : 'transparent'}; transition:all 0.2s;" title="${c.name}"></div>`
                ).join('');

                // Folder type options
                const typeOptionsHtml = FOLDER_TYPES.map(t =>
                    `<option value="${t.id}" ${folderType === t.id ? 'selected' : ''}>${t.icon} ${t.name}</option>`
                ).join('');

                const fileListHtml = files.length === 0
                    ? '<div style="color:var(--text-tertiary); font-size:12px; padding:10px; text-align:center;">Klas√∂r bo≈ü</div>'
                    : files.map((f, i) => `
                        <div style="display:flex; align-items:center; gap:8px; padding:8px; background:rgba(255,255,255,0.05); border-radius:8px; margin-bottom:6px;">
                            <span style="font-size:18px;">${getFileIconByName(f.name)}</span>
                            <div style="flex:1; min-width:0;">
                                <div style="font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${f.name}</div>
                                <div style="font-size:10px; color:var(--text-tertiary);">${formatFileSize(f.size)}</div>
                            </div>
                            <button onclick="previewFolderFile('${nodeId}', ${i})" style="background:rgba(99,102,241,0.2); border:none; color:#a5b4fc; cursor:pointer; font-size:14px; padding:4px 8px; border-radius:4px;">üëÅÔ∏è</button>
                            <button onclick="confirmRemoveFolderFile('${nodeId}', ${i}, '${escapeHtml(f.name).replace(/'/g, "\\'")}')" style="background:none; border:none; color:#ef4444; cursor:pointer; font-size:16px;">√ó</button>
                        </div>
                    `).join('');

                typeSpecificHtml = `
                    <div class="prop-group">
                        <div class="prop-group-title">üé® Renk</div>
                        <div style="display:flex; gap:6px; flex-wrap:wrap;">
                            ${colorOptionsHtml}
                        </div>
                    </div>
                    <div class="prop-group">
                        <div class="prop-group-title">üìÅ Klas√∂r T√ºr√º</div>
                        <select class="prop-select" id="propFolderType" onchange="updateFolderType('${nodeId}', this.value)">
                            ${typeOptionsHtml}
                        </select>
                    </div>
                    <div class="prop-group">
                        <div class="prop-group-title">üìÇ Dosyalar (${files.length})</div>
                        <div style="max-height:200px; overflow-y:auto;">
                            ${fileListHtml}
                        </div>
                        <button class="prop-btn" onclick="addFilesToFolder('${nodeId}')" style="margin-top:10px; background:var(--accent-primary);">
                            + Dosya Ekle
                        </button>
                    </div>
                `;
            } else if (node.type === 'sticky') {
                // STICKY NOTE Properties
                const colorOptions = STICKY_COLORS.map(c =>
                    `<div onclick="updateStickyColor('${nodeId}', '${c.id}')" style="width:32px; height:32px; background:${c.color}; border-radius:6px; cursor:pointer; border:3px solid ${node.stickyColor === c.id ? '#fff' : 'transparent'}; transition:all 0.2s;" title="${c.name}"></div>`
                ).join('');

                const tagOptions = STICKY_TAGS.map(t =>
                    `<option value="${t.id}" ${node.stickyTag === t.id ? 'selected' : ''}>${t.name}</option>`
                ).join('');

                typeSpecificHtml = `
                    <div class="prop-group">
                        <div class="prop-group-title">üé® Renk</div>
                        <div style="display:flex; gap:8px; flex-wrap:wrap;">
                            ${colorOptions}
                        </div>
                    </div>
                    <div class="prop-group">
                        <div class="prop-group-title">üè∑Ô∏è Etiket</div>
                        <select class="prop-select" id="propStickyTag" onchange="updateStickyTag('${nodeId}', this.value)">
                            ${tagOptions}
                        </select>
                    </div>
                    <div class="prop-group">
                        <div class="prop-group-title">üìù ƒ∞√ßerik</div>
                        <textarea class="prop-input" id="propStickyContent" style="min-height:100px; resize:vertical;" placeholder="Not i√ßeriƒüi...">${escapeHtml(node.summary || node.stickyContent || '')}</textarea>
                    </div>
                `;
            } else if (node.type === 'image') {
                // IMAGE Properties
                const imageColor = node.imageColor || 'purple';
                const colorOptions = STICKY_COLORS.map(c =>
                    `<div onclick="updateImageColor('${nodeId}', '${c.id}')" style="width:32px; height:32px; background:${c.color}; border-radius:6px; cursor:pointer; border:3px solid ${imageColor === c.id ? '#fff' : 'transparent'}; transition:all 0.2s;" title="${c.name}"></div>`
                ).join('');

                const previewHtml = node.imageData || node.imageSrc
                    ? `<img src="${node.imageData || node.imageSrc}" style="max-width:100%; max-height:150px; border-radius:8px; object-fit:contain;">`
                    : `<div style="text-align:center; color:var(--text-tertiary); padding:30px;">üñºÔ∏è<br>Resim yok</div>`;

                typeSpecificHtml = `
                    <div class="prop-group">
                        <div class="prop-group-title">üé® Renk</div>
                        <div style="display:flex; gap:8px; flex-wrap:wrap;">
                            ${colorOptions}
                        </div>
                    </div>
                    <div class="prop-group">
                        <div class="prop-group-title">üñºÔ∏è √ñnizleme</div>
                        <div style="background:rgba(0,0,0,0.2); border-radius:8px; padding:10px; text-align:center;">
                            ${previewHtml}
                        </div>
                        <div style="display:flex; gap:8px; margin-top:10px;">
                            <button class="prop-btn" onclick="selectNodeImage('${nodeId}')" style="flex:1; background:var(--accent-primary);">
                                ${node.imageData || node.imageSrc ? 'üîÑ Deƒüi≈ütir' : '+ Resim Se√ß'}
                            </button>
                            ${node.imageData || node.imageSrc ? `<button class="prop-btn" onclick="viewImageFullscreen('${nodeId}')" style="background:#6366f1;">üîç</button>` : ''}
                        </div>
                    </div>
                    <div class="prop-group">
                        <div class="prop-group-title">üí¨ Alt Yazƒ±</div>
                        <textarea class="prop-input" id="propImageCaption" style="min-height:60px; resize:vertical;" placeholder="Resim a√ßƒ±klamasƒ±...">${escapeHtml(node.imageCaption || node.summary || '')}</textarea>
                    </div>
                `;
            }

            container.innerHTML = `
                <!-- Header -->
                <div class="prop-group" style="background:linear-gradient(135deg, ${typeInfo.color}22, ${typeInfo.color}11); border:1px solid ${typeInfo.color}33; border-radius:12px; padding:16px;">
                    <div style="display:flex; align-items:center; gap:12px;">
                        <div style="width:48px; height:48px; background:linear-gradient(135deg, ${typeInfo.color}, ${typeInfo.color}cc); border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:24px;">${typeInfo.icon}</div>
                        <div>
                            <div style="font-size:11px; color:var(--text-tertiary); text-transform:uppercase; letter-spacing:0.5px;">${typeInfo.name}</div>
                            <div style="font-size:16px; font-weight:600; color:var(--text-primary);">${node.title}</div>
                        </div>
                    </div>
                </div>

                <!-- Basic Info -->
                <div class="prop-group">
                    <div class="prop-group-title">üìã Temel Bilgiler</div>
                    <div class="prop-row">
                        <label class="prop-label">Ba≈ülƒ±k</label>
                        <input type="text" class="prop-input" id="propSpecialTitle" value="${escapeHtml(node.title)}">
                    </div>
                </div>

                ${typeSpecificHtml}

                <!-- Connections Section -->
                <div class="prop-group">
                    <div class="prop-group-title">üîó Baƒülantƒ±lar</div>
                    <div id="propSpecialConnections">
                        ${renderNodeConnections(node)}
                    </div>
                </div>

                <!-- Apply/Cancel Buttons -->
                <div class="prop-group" style="position:sticky; bottom:0; background:var(--bg-secondary); padding:15px 0; margin:0 -16px; padding:15px 16px; border-top:1px solid var(--border-subtle);">
                    <div style="display:flex; gap:10px;">
                        <button class="prop-btn" onclick="applySpecialPropertiesChanges()" style="flex:1; background:var(--accent-primary);">‚úì Uygula</button>
                        <button class="prop-btn" onclick="cancelPropertiesChanges()" style="flex:1; background:#444;">‚úï ƒ∞ptal</button>
                    </div>
                </div>

                <!-- Actions -->
                <div class="prop-group" style="margin-top:10px;">
                    <button class="prop-btn prop-btn-danger" onclick="deleteNodeById('${nodeId}')" style="width:100%;">Sil</button>
                </div>
            `;
        }

        // Helper functions for special nodes
        function getFileIconByName(fileName) {
            if (!fileName) return 'üìÑ';
            const ext = fileName.split('.').pop().toLowerCase();
            const icons = {
                'pdf': 'üìï', 'doc': 'üìò', 'docx': 'üìò', 'txt': 'üìÑ',
                'jpg': 'üñºÔ∏è', 'jpeg': 'üñºÔ∏è', 'png': 'üñºÔ∏è', 'gif': 'üñºÔ∏è', 'webp': 'üñºÔ∏è',
                'mp3': 'üéµ', 'wav': 'üéµ', 'mp4': 'üé¨', 'mov': 'üé¨',
                'zip': 'üì¶', 'rar': 'üì¶', 'js': 'üìú', 'html': 'üåê', 'css': 'üé®'
            };
            return icons[ext] || 'üìÑ';
        }

        function formatFileSize(bytes) {
            if (!bytes) return '-';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function updateStickyColor(nodeId, color) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;
            node.stickyColor = color;
            renderNode(node);
            updatePropertiesPanel(nodeId);
            autoSave();
        }

        function updateStickyTag(nodeId, tag) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;
            node.stickyTag = tag;
            renderNode(node);
            autoSave();
        }

        function updateFolderColor(nodeId, color) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;
            node.folderColor = color;
            renderNode(node);
            updatePropertiesPanel(nodeId);
            autoSave();
        }

        function updateFolderType(nodeId, type) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;
            node.folderType = type;
            renderNode(node);
            autoSave();
        }

        function updateImageColor(nodeId, color) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) return;
            node.imageColor = color;
            renderNode(node);
            updatePropertiesPanel(nodeId);
            autoSave();
        }

        function addFilesToFolder(nodeId) {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.onchange = (e) => {
                const files = Array.from(e.target.files);
                const node = nodes.find(n => String(n.id) === String(nodeId));
                if (!node) return;

                if (!node.folderFiles) node.folderFiles = [];

                files.forEach(file => {
                    const fileObj = {
                        id: 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        addedAt: new Date().toISOString()
                    };

                    // Read file data for preview capability
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        fileObj.data = ev.target.result;
                        // If it's an image, also set preview
                        if (file.type.startsWith('image/')) {
                            fileObj.preview = ev.target.result;
                        }
                        renderNode(node);
                        updatePropertiesPanel(nodeId);
                        autoSave();
                    };
                    reader.readAsDataURL(file);

                    node.folderFiles.push(fileObj);
                });

                renderNode(node);
                updatePropertiesPanel(nodeId);
                autoSave();
                showToast(`üìÅ ${files.length} dosya eklendi`);
            };
            input.click();
        }

        function removeFolderFile(nodeId, fileIndex) {
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node || !node.folderFiles) return;

            node.folderFiles.splice(fileIndex, 1);
            renderNode(node);
            updatePropertiesPanel(nodeId);
            autoSave();
            showToast('üóëÔ∏è Dosya kaldƒ±rƒ±ldƒ±');
        }

        // Properties panel delete confirmation
        function confirmRemoveFolderFile(nodeId, index, fileName) {
            const confirmModal = document.createElement('div');
            confirmModal.id = 'propFileDeleteConfirm';
            confirmModal.className = 'modal';
            confirmModal.style.display = 'flex';
            confirmModal.style.zIndex = '100002';
            confirmModal.innerHTML = `
                <div class="modal-content" style="max-width:480px; width:90%; background:#1a1a2e; border:2px solid #ef4444; border-radius:12px;">
                    <div class="modal-header" style="background:#2d1f1f; border-bottom:1px solid #ef4444; padding:14px 20px; border-radius:10px 10px 0 0;">
                        <h3 style="color:#f87171; font-size:16px;">‚ö†Ô∏è Dosyayƒ± Sil</h3>
                        <button class="modal-close" onclick="document.getElementById('propFileDeleteConfirm').remove()" style="font-size:20px;">√ó</button>
                    </div>
                    <div style="padding:30px; text-align:center;">
                        <div style="font-size:56px; margin-bottom:20px;">üóëÔ∏è</div>
                        <p style="color:#e0e0e0; font-size:16px; margin-bottom:12px;">Bu dosyayƒ± silmek istiyor musunuz?</p>
                        <p style="color:#f87171; font-size:15px; font-weight:600; padding:14px 20px; background:rgba(239,68,68,0.1); border-radius:8px; margin:16px 0; word-break:break-all;">${fileName}</p>
                        <p style="color:#888; font-size:13px;">Bu i≈ülem geri alƒ±namaz.</p>
                    </div>
                    <div style="display:flex; gap:12px; padding:20px; border-top:1px solid #333;">
                        <button onclick="document.getElementById('propFileDeleteConfirm').remove()" style="flex:1; background:#444; color:#fff; border:none; padding:12px; border-radius:8px; cursor:pointer; font-size:14px;">
                            ‚úï ƒ∞ptal
                        </button>
                        <button onclick="document.getElementById('propFileDeleteConfirm').remove(); removeFolderFile('${nodeId}', ${index});" style="flex:1; background:linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color:#fff; border:none; padding:12px; border-radius:8px; cursor:pointer; font-size:14px; font-weight:600;">
                            üóëÔ∏è Evet, Sil
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(confirmModal);
        }

        function applySpecialPropertiesChanges() {
            if (!propEditingNodeId) return;

            const node = nodes.find(n => String(n.id) === String(propEditingNodeId));
            if (!node) return;

            saveUndoState('update special node');

            // Get common values
            node.title = document.getElementById('propSpecialTitle')?.value || node.title;

            // Type-specific values
            if (node.type === 'sticky') {
                node.summary = document.getElementById('propStickyContent')?.value || '';
                node.stickyContent = node.summary;
            } else if (node.type === 'image') {
                node.imageCaption = document.getElementById('propImageCaption')?.value || '';
                node.summary = node.imageCaption;
            }

            renderNode(node);
            renderConnections();
            autoSave();
            
            // Clear stored original state - changes are now permanent
            propOriginalConnections = null;
            
            showToast('‚úì Deƒüi≈üiklikler uygulandƒ±');
        }

        // Render Task Node Properties Panel
        function renderTaskNodeProperties(container, node, nodeId) {
            const allTaskTypes = getAllTaskTypes();
            const rawTaskTypeInfo = allTaskTypes[node.type] || { icon: '‚ñ¢', name: 'Task', color: '#8b5cf6' };
            const taskTypeInfo = {
                ...rawTaskTypeInfo,
                icon: sanitizeCorruptedIconEarly(rawTaskTypeInfo.icon),
                name: sanitizeText(rawTaskTypeInfo.name)
            };
            const progress = node.taskProgress || 0;

            // Force check and reset TASK_STATUSES if corrupted
            const hasCorruptStatus = TASK_STATUSES.some(s => 
                hasCorruptedText(s.icon) || hasCorruptedText(s.name) || 
                (s.icon && s.icon.includes('√¢')) || (s.icon && s.icon.length > 4)
            );
            if (hasCorruptStatus) {
                console.warn('üßπ Corrupted TASK_STATUSES detected in properties panel, resetting...');
                TASK_STATUSES = getDefaultTaskStatuses();
            }

            // Status options - TASK_STATUSES is already customizable (sanitize icons)
            const statusOptions = TASK_STATUSES.map(s =>
                `<option value="${s.id}" ${node.taskStatus === s.id ? 'selected' : ''}>${sanitizeCorruptedIconEarly(s.icon)} ${sanitizeText(s.name)}</option>`
            ).join('');

            // Priority options
            const priorityOptions = IMPORTANCE_LEVELS.map(p =>
                `<option value="${p.id}" ${node.taskPriority === p.id ? 'selected' : ''}>${sanitizeText(p.name)}</option>`
            ).join('');

            // Duration type options
            const durationTypeOptions = DURATION_TYPES.map(d =>
                `<option value="${d.id}" ${node.taskDurationType === d.id ? 'selected' : ''}>${sanitizeText(d.name)}</option>`
            ).join('');

            // Task type options - include custom types (sanitize icons)
            const taskTypeOptions = Object.entries(allTaskTypes).map(([key, val]) =>
                `<option value="${key}" ${node.type === key ? 'selected' : ''}>${sanitizeCorruptedIconEarly(val.icon)} ${sanitizeText(val.name)}</option>`
            ).join('');

            // Store original values
            propEditingNodeId = nodeId;
            propOriginalValues = {
                title: node.title,
                type: node.type,
                summary: node.summary || '',
                taskStatus: node.taskStatus,
                taskPriority: node.taskPriority,
                taskProgress: node.taskProgress,
                taskDuration: node.taskDuration,
                taskDurationType: node.taskDurationType,
                taskDateStart: node.taskDateStart,
                taskDateDue: node.taskDateDue,
                taskAssignedBy: node.taskAssignedBy,
                parentId: node.parentId
            };
            // Store connections state for cancel
            propOriginalConnections = {
                connections: JSON.parse(JSON.stringify(connections)),
                nodeParentIds: nodes.map(n => ({ id: n.id, parentId: n.parentId }))
            };

            container.innerHTML = `
                <!-- Task Header -->
                <div class="prop-group" style="background:linear-gradient(135deg, ${taskTypeInfo.color}22, ${taskTypeInfo.color}11); border:1px solid ${taskTypeInfo.color}33; border-radius:12px; padding:16px;">
                    <div style="display:flex; align-items:center; gap:12px;">
                        <div style="width:48px; height:48px; background:linear-gradient(135deg, ${taskTypeInfo.color}, ${taskTypeInfo.color}cc); border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:24px;">${taskTypeInfo.icon}</div>
                        <div>
                            <div style="font-size:11px; color:var(--text-tertiary); text-transform:uppercase; letter-spacing:0.5px;">${taskTypeInfo.name}</div>
                            <div style="font-size:16px; font-weight:600; color:var(--text-primary);">${sanitizeText(node.title)}</div>
                        </div>
                    </div>
                </div>

                <!-- Progress -->
                <div class="prop-group">
                    <div class="prop-group-title">üìä ƒ∞lerleme</div>
                    <div style="display:flex; align-items:center; gap:12px;">
                        <input type="range" id="propTaskProgress" value="${progress}" min="0" max="100" style="flex:1; height:8px;" oninput="document.getElementById('propProgressValue').textContent = this.value + '%'">
                        <span id="propProgressValue" style="font-weight:600; color:var(--accent-primary); min-width:45px;">${progress}%</span>
                    </div>
                    <div style="height:8px; background:rgba(255,255,255,0.1); border-radius:4px; margin-top:8px; overflow:hidden;">
                        <div id="propProgressBar" style="height:100%; width:${progress}%; background:linear-gradient(90deg, #22c55e, #4ade80); border-radius:4px; transition:width 0.3s;"></div>
                    </div>
                </div>

                <!-- Basic Info -->
                <div class="prop-group">
                    <div class="prop-group-title">üìã Temel Bilgiler</div>
                    <div class="prop-row">
                        <label class="prop-label">Ba≈ülƒ±k</label>
                        <input type="text" class="prop-input" id="propTitle" value="${escapeHtml(node.title)}">
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">Task Tipi</label>
                        <select class="prop-select" id="propType">
                            ${taskTypeOptions}
                        </select>
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">A√ßƒ±klama</label>
                        <textarea class="prop-input" id="propSummary" style="min-height:60px; resize:none; overflow-y:hidden; line-height:1.5;">${escapeHtml(node.summary || '')}</textarea>
                    </div>
                </div>

                <!-- Status & Priority -->
                <div class="prop-group">
                    <div class="prop-group-title">üéØ Durum & √ñncelik</div>
                    <div class="prop-row">
                        <label class="prop-label">Durum</label>
                        <select class="prop-select" id="propTaskStatus">
                            ${statusOptions}
                        </select>
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">√ñncelik</label>
                        <select class="prop-select" id="propTaskPriority">
                            ${priorityOptions}
                        </select>
                    </div>
                </div>

                <!-- Duration & Dates -->
                <div class="prop-group">
                    <div class="prop-group-title">Sure & Tarihler</div>
                    <div class="prop-row" style="gap:8px;">
                        <div style="flex:1;">
                            <label class="prop-label">Sure</label>
                            <input type="number" class="prop-input" id="propTaskDuration" value="${node.taskDuration || 1}" min="1" oninput="calculatePropEndDate()">
                        </div>
                        <div style="flex:1;">
                            <label class="prop-label">Birim</label>
                            <select class="prop-select" id="propTaskDurationType" onchange="calculatePropEndDate()">
                                ${durationTypeOptions}
                            </select>
                        </div>
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">Baslangic</label>
                        <input type="datetime-local" class="prop-input" id="propTaskDateStart" value="${node.taskDateStart || ''}" oninput="calculatePropEndDate()">
                    </div>
                    <div class="prop-row">
                        <label class="prop-label">Bitis</label>
                        <input type="datetime-local" class="prop-input" id="propTaskDateDue" value="${node.taskDateDue || ''}" oninput="calculatePropDurationFromDates()">
                    </div>
                </div>

                <!-- Assignment -->
                <div class="prop-group">
                    <div class="prop-group-title">üë§ Atama</div>
                    <div class="prop-row">
                        <label class="prop-label">Atayan Ki≈üi</label>
                        <input type="text" class="prop-input" id="propTaskAssignedBy" value="${escapeHtml(node.taskAssignedBy || '')}" placeholder="ƒ∞sim girin...">
                    </div>
                </div>

                <!-- Task Dependencies - Simplified -->
                <div class="prop-group">
                    <div class="prop-group-title">üìã Task Baƒüƒ±mlƒ±lƒ±klarƒ±</div>

                    <!-- Task Dependencies List -->
                    <div id="propTaskDependencies" style="background:rgba(0,0,0,0.2); border-radius:8px; padding:10px; max-height:150px; overflow-y:auto; margin-bottom:10px;">
                        ${renderPropTaskDependencies(node)}
                    </div>
                    <div style="display:flex; gap:8px; align-items:center;">
                        <select class="prop-select" id="propAddDependencySelect" style="flex:1;">
                            <option value="">‚Äî Task Se√ß ‚Äî</option>
                            ${renderAvailableTasksForDependency(node.id)}
                        </select>
                        <select class="prop-select" id="propAddDependencyType" style="width:80px;">
                            <option value="FS">FS</option>
                            <option value="SS">SS</option>
                            <option value="FF">FF</option>
                            <option value="SF">SF</option>
                        </select>
                        <button onclick="addPropDependency('${node.id}')" style="background:#22c55e; color:#fff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; font-size:12px;">+ Ekle</button>
                    </div>
                </div>
                
                <!-- Node Connections (Parent/Child) -->
                <div class="prop-group">
                    <div class="prop-group-title">üîó Baƒülantƒ±lar</div>
                    <div id="propNodeConnections">
                        ${renderNodeConnections(node)}
                    </div>
                </div>

                <!-- Apply/Cancel Buttons -->
                <div class="prop-group" style="position:sticky; bottom:0; background:var(--bg-secondary); padding:15px 0; margin:0 -16px; padding:15px 16px; border-top:1px solid var(--border-subtle);">
                    <div style="display:flex; gap:10px;">
                        <button class="prop-btn" onclick="applyTaskPropertiesChanges()" style="flex:1; background:var(--accent-primary);">‚úì Uygula</button>
                        <button class="prop-btn" onclick="cancelPropertiesChanges()" style="flex:1; background:#444;">‚úï ƒ∞ptal</button>
                    </div>
                </div>

                <!-- Actions -->
                <div class="prop-group" style="margin-top:10px;">
                    <button class="prop-btn prop-btn-danger" onclick="deleteTaskNodeFromProperties('${nodeId}')" style="width:100%;">Task'i Sil</button>
                </div>
            `;

            // Add event listener for progress slider and auto-expand summary
            setTimeout(() => {
                const slider = document.getElementById('propTaskProgress');
                if (slider) {
                    slider.addEventListener('input', (e) => {
                        const val = e.target.value;
                        document.getElementById('propProgressValue').textContent = val + '%';
                        document.getElementById('propProgressBar').style.width = val + '%';
                    });
                }

                // Auto-expand summary textarea
                const summaryTextarea = document.getElementById('propSummary');
                if (summaryTextarea) {
                    const autoResize = (el) => {
                        el.style.height = 'auto';
                        el.style.height = Math.max(60, el.scrollHeight) + 'px';
                    };
                    autoResize(summaryTextarea);
                    summaryTextarea.addEventListener('input', () => autoResize(summaryTextarea));
                }
            }, 100);
        }

        // Render task dependencies list for properties panel - WITH TYPE SELECTOR
        // Render node connections for normal nodes (not tasks)
        function renderNodeConnections(node) {
            // Find all connections involving this node
            const nodeConns = [];
            const nodeIdStr = String(node.id);

            // Parent connection
            if (node.parentId) {
                const parent = nodes.find(n => String(n.id) === String(node.parentId));
                if (parent) {
                    nodeConns.push({ type: 'parent', node: parent, label: '√úst Node' });
                }
            }

            // Child connections
            const children = nodes.filter(n => String(n.parentId) === nodeIdStr);
            children.forEach(child => {
                nodeConns.push({ type: 'child', node: child, label: 'Alt Node' });
            });

            // Explicit connections
            connections.forEach(conn => {
                const fromStr = String(conn.from);
                const toStr = String(conn.to);
                if (fromStr === nodeIdStr) {
                    const targetNode = nodes.find(n => String(n.id) === toStr);
                    if (targetNode && String(targetNode.parentId) !== nodeIdStr && String(node.parentId) !== String(targetNode.id)) {
                        nodeConns.push({ type: 'connection', node: targetNode, conn: conn, label: 'Baƒülantƒ±', direction: conn.directionType || 'single' });
                    }
                } else if (toStr === nodeIdStr) {
                    const targetNode = nodes.find(n => String(n.id) === fromStr);
                    if (targetNode && String(targetNode.parentId) !== nodeIdStr && String(node.parentId) !== String(targetNode.id)) {
                        nodeConns.push({ type: 'connection', node: targetNode, conn: conn, label: 'Baƒülantƒ±', direction: conn.directionType || 'single' });
                    }
                }
            });

            if (nodeConns.length === 0) {
                return '<div style="color:#888; font-size:12px; text-align:center; padding:10px;">Baƒülantƒ± yok</div>';
            }

            return nodeConns.map(item => {
                return `
                    <div style="display:flex; align-items:center; gap:8px; padding:10px; background:rgba(255,255,255,0.05); border-radius:8px; margin-bottom:6px;">
                        <span style="font-size:14px; color:#888;">${item.label}</span>
                        <div style="flex:1; overflow:hidden;">
                            <div style="font-size:13px; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${item.node.title}</div>
                        </div>
                        <button onclick="event.stopPropagation(); removeNodeConnection('${node.id}', '${item.node.id}', '${item.type}')" style="background:#ef4444; color:#fff; border:none; padding:6px 10px; border-radius:4px; cursor:pointer; font-size:12px;">‚úï</button>
                    </div>
                `;
            }).join('');
        }

        // Update connection direction from properties panel
        function updateNodeConnectionDirection(nodeId, targetId, direction) {
            const nId = String(nodeId);
            const tId = String(targetId);
            const conn = connections.find(c =>
                (String(c.from) === nId && String(c.to) === tId) ||
                (String(c.from) === tId && String(c.to) === nId)
            );
            if (conn) {
                conn.directionType = direction;
                renderConnections();
                saveToLocalStorage();
                showToast(direction === 'double' ? '‚Üî √áift y√∂nl√º' : direction === 'none' ? '‚Äî Y√∂ns√ºz' : '‚Üí Tek y√∂nl√º');
            }
        }

        // Remove connection from properties panel
        function removeNodeConnection(nodeId, targetId, type) {
            // Don't save undo state here - will be done when Apply is clicked
            
            const nId = String(nodeId);
            const tId = String(targetId);

            if (type === 'parent') {
                // Remove parent relationship
                const node = nodes.find(n => String(n.id) === nId);
                if (node) {
                    node.parentId = null;
                }
                // Also remove from connections array
                connections = connections.filter(c =>
                    !((String(c.from) === tId && String(c.to) === nId) ||
                      (String(c.from) === nId && String(c.to) === tId))
                );
            } else if (type === 'child') {
                // Remove child's parent reference
                const child = nodes.find(n => String(n.id) === tId);
                if (child) {
                    child.parentId = null;
                }
                // Also remove from connections array
                connections = connections.filter(c =>
                    !((String(c.from) === nId && String(c.to) === tId) ||
                      (String(c.from) === tId && String(c.to) === nId))
                );
            } else {
                // Remove from connections array
                connections = connections.filter(c =>
                    !((String(c.from) === nId && String(c.to) === tId) ||
                      (String(c.from) === tId && String(c.to) === nId))
                );

                // Also remove task dependencies
                const node1 = nodes.find(n => String(n.id) === nId);
                const node2 = nodes.find(n => String(n.id) === tId);
                if (node1 && node1.taskDependencies) {
                    node1.taskDependencies = node1.taskDependencies.filter(d => String(d.taskId) !== tId);
                }
                if (node2 && node2.taskDependencies) {
                    node2.taskDependencies = node2.taskDependencies.filter(d => String(d.taskId) !== nId);
                }
            }

            // Clear all connections immediately from SVG
            const connectionsEl = document.getElementById('connections');
            if (connectionsEl) {
                connectionsEl.innerHTML = '';
            }
            
            // Render connections synchronously first
            renderConnections();
            updatePropertiesPanel(nId);
            
            // Then also with requestAnimationFrame for stability
            requestAnimationFrame(() => {
                renderConnections();
            });
            
            // Don't save to localStorage - wait for Apply button
            showToast('‚úÇÔ∏è Baƒülantƒ± silindi (Uygula ile kaydedin)');
        }

        function renderPropTaskDependencies(node) {
            const deps = node.taskDependencies || [];
            const successors = getSuccessorTasks(node.id);

            if (deps.length === 0 && successors.length === 0) {
                return '<div style="color:#888; font-size:12px; text-align:center; padding:10px;">Baƒüƒ±mlƒ±lƒ±k yok</div>';
            }

            let html = '';

            // √úST BAƒûIMLILAR (Predecessors) - Bu task bunlara baƒüƒ±mlƒ±
            if (deps.length > 0) {
                html += '<div style="font-size:11px; color:#22c55e; margin-bottom:8px; font-weight:bold;">‚Üë √úST BAƒûIMLILAR (√ñnce tamamlanmalƒ±)</div>';
                deps.forEach((dep, idx) => {
                    const depNode = nodes.find(n => String(n.id) === String(dep.taskId));
                    if (!depNode) return;

                    const typeInfo = getAllTaskTypes()[depNode.type] || { icon: 'üìã', name: 'Task' };
                    const currentType = dep.type || 'FS';
                    const currentLag = dep.lag || 0;
                    const currentLagUnit = dep.lagUnit || 'days';

                    html += `
                        <div style="display:flex; align-items:center; gap:6px; padding:8px; background:rgba(34,197,94,0.1); border:1px solid rgba(34,197,94,0.3); border-radius:6px; margin-bottom:6px;">
                            <span style="font-size:14px;">${typeInfo.icon}</span>
                            <div style="flex:1; min-width:0; overflow:hidden;">
                                <div style="font-size:11px; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${depNode.title}</div>
                            </div>
                            <input type="number" value="${currentLag}" onchange="updatePropDependencyLag('${node.id}', '${dep.taskId}', this.value)" style="width:40px; padding:3px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:11px; text-align:center;">
                            <select onchange="updatePropDependencyLagUnit('${node.id}', '${dep.taskId}', this.value)" style="padding:3px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:10px;">
                                <option value="days" ${currentLagUnit === 'days' ? 'selected' : ''}>G√ºn</option>
                                <option value="hours" ${currentLagUnit === 'hours' ? 'selected' : ''}>Saat</option>
                                <option value="weeks" ${currentLagUnit === 'weeks' ? 'selected' : ''}>Hafta</option>
                            </select>
                            <select onchange="updatePropDependencyType('${node.id}', '${dep.taskId}', this.value)" style="background:#1a1a2e; border:1px solid #444; color:#fff; padding:3px 6px; border-radius:4px; font-size:10px; font-weight:bold;">
                                <option value="FS" ${currentType === 'FS' ? 'selected' : ''}>FS</option>
                                <option value="SS" ${currentType === 'SS' ? 'selected' : ''}>SS</option>
                                <option value="FF" ${currentType === 'FF' ? 'selected' : ''}>FF</option>
                                <option value="SF" ${currentType === 'SF' ? 'selected' : ''}>SF</option>
                            </select>
                            <button onclick="removePropDependency('${node.id}', '${dep.taskId}')" style="background:#ef4444; color:#fff; border:none; width:22px; height:22px; border-radius:4px; cursor:pointer; font-size:12px;">‚úï</button>
                        </div>
                    `;
                });
            }

            // ALT BAƒûIMLILAR (Successors) - Bunlar bu task'a baƒüƒ±mlƒ±
            if (successors.length > 0) {
                html += '<div style="font-size:11px; color:#f59e0b; margin-top:12px; margin-bottom:8px; font-weight:bold;">‚Üì ALT BAƒûIMLILAR (Bu task\'ƒ± bekliyor)</div>';
                successors.forEach((succ) => {
                    const typeInfo = getAllTaskTypes()[succ.node.type] || { icon: 'üìã', name: 'Task' };
                    const currentLag = succ.lag || 0;
                    const currentLagUnit = succ.lagUnit || 'days';
                    html += `
                        <div style="display:flex; align-items:center; gap:6px; padding:8px; background:rgba(245,158,11,0.1); border:1px solid rgba(245,158,11,0.3); border-radius:6px; margin-bottom:6px;">
                            <span style="font-size:14px;">${typeInfo.icon}</span>
                            <div style="flex:1; min-width:0; overflow:hidden;">
                                <div style="font-size:11px; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${succ.node.title}</div>
                            </div>
                            <input type="number" value="${currentLag}" onchange="updateSuccessorLag('${succ.node.id}', '${node.id}', this.value)" style="width:40px; padding:3px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:11px; text-align:center;">
                            <select onchange="updateSuccessorLagUnit('${succ.node.id}', '${node.id}', this.value)" style="padding:3px; background:#1a1a2e; border:1px solid #444; color:#fff; border-radius:4px; font-size:10px;">
                                <option value="days" ${currentLagUnit === 'days' ? 'selected' : ''}>G√ºn</option>
                                <option value="hours" ${currentLagUnit === 'hours' ? 'selected' : ''}>Saat</option>
                                <option value="weeks" ${currentLagUnit === 'weeks' ? 'selected' : ''}>Hafta</option>
                            </select>
                            <select onchange="updateSuccessorDependencyType('${succ.node.id}', '${node.id}', this.value)" style="background:#1a1a2e; border:1px solid #444; color:#fff; padding:3px 6px; border-radius:4px; font-size:10px; font-weight:bold;">
                                <option value="FS" ${succ.type === 'FS' ? 'selected' : ''}>FS</option>
                                <option value="SS" ${succ.type === 'SS' ? 'selected' : ''}>SS</option>
                                <option value="FF" ${succ.type === 'FF' ? 'selected' : ''}>FF</option>
                                <option value="SF" ${succ.type === 'SF' ? 'selected' : ''}>SF</option>
                            </select>
                            <button onclick="removeSuccessorDependency('${succ.node.id}', '${node.id}')" style="background:#ef4444; color:#fff; border:none; width:22px; height:22px; border-radius:4px; cursor:pointer; font-size:12px;">‚úï</button>
                        </div>
                    `;
                });
            }

            if (html === '') {
                return '<div style="color:#888; font-size:12px; text-align:center; padding:10px;">Baƒüƒ±mlƒ±lƒ±k yok</div>';
            }

            return html;
        }

        // Find tasks that depend on this node (successors)
        function getSuccessorTasks(nodeId) {
            const successors = [];
            nodes.forEach(n => {
                if (n.taskDependencies) {
                    const dep = n.taskDependencies.find(d => String(d.taskId) === String(nodeId));
                    if (dep) {
                        successors.push({
                            node: n,
                            type: dep.type || 'FS',
                            lag: dep.lag || 0,
                            lagUnit: dep.lagUnit || 'days'
                        });
                    }
                }
            });
            return successors;
        }

        // Update dependency type from properties panel - SYNC WITH TASK SETTINGS
        function updatePropDependencyType(nodeId, depTaskId, newType) {
            // Handle string IDs
            const nId = typeof nodeId === 'string' ? nodeId : String(nodeId);
            const dId = typeof depTaskId === 'string' ? depTaskId : String(depTaskId);

            const node = nodes.find(n => String(n.id) === nId);
            if (!node || !node.taskDependencies) {
                console.error('Node or dependencies not found:', nId);
                return;
            }

            // Update in taskDependencies array
            const dep = node.taskDependencies.find(d => String(d.taskId) === dId);
            if (dep) {
                dep.type = newType;
                console.log('Updated dependency type:', dep);
            } else {
                console.error('Dependency not found:', dId);
            }

            // Update in connections array too
            const conn = connections.find(c =>
                (String(c.from) === dId && String(c.to) === nId) ||
                (String(c.from) === nId && String(c.to) === dId)
            );
            if (conn) {
                conn.dependencyType = newType;
            }

            // IMPORTANT: Update task dates based on new dependency type
            if (typeof updateTaskDatesFromDependency === 'function') {
                updateTaskDatesFromDependency(nId);
            }
            
            // Refresh everything - without re-rendering connections (no visual flicker)
            updatePropertiesPanel(nId);
            saveToLocalStorage();
            refreshAllTaskViews();
            showToast(`‚úì Baƒüƒ±mlƒ±lƒ±k tipi: ${newType}`);
        }

        // Update successor dependency type (the successor node's dependency on current node)
        function updateSuccessorDependencyType(successorNodeId, currentNodeId, newType) {
            const sId = String(successorNodeId);
            const cId = String(currentNodeId);

            const successorNode = nodes.find(n => String(n.id) === sId);
            if (!successorNode || !successorNode.taskDependencies) {
                console.error('Successor node or dependencies not found:', sId);
                return;
            }

            // Update the successor's dependency on current node
            const dep = successorNode.taskDependencies.find(d => String(d.taskId) === cId);
            if (dep) {
                dep.type = newType;
                console.log('Updated successor dependency type:', dep);
            } else {
                console.error('Dependency not found in successor:', cId);
                return;
            }

            // Update in connections array too
            const conn = connections.find(c =>
                (String(c.from) === cId && String(c.to) === sId) ||
                (String(c.from) === sId && String(c.to) === cId)
            );
            if (conn) {
                conn.dependencyType = newType;
            }

            // Refresh task editor if open
            const taskIdInput = document.getElementById('editingTaskId');
            if (taskIdInput && taskIdInput.value) {
                const editingNodeId = taskIdInput.value.replace('node:', '');
                if (String(editingNodeId) === cId) {
                    renderTaskDependencies(parseInt(editingNodeId));
                }
            }

            // Refresh properties panel if current node is selected
            if (selectedNode && String(selectedNode) === cId) {
                updatePropertiesPanel(currentNodeId);
            }

            saveToLocalStorage();
            showToast(`‚úì Baƒüƒ±mlƒ±lƒ±k tipi: ${newType}`);
        }

        // Remove a successor's dependency on current node
        function removeSuccessorDependency(successorNodeId, currentNodeId) {
            const sId = String(successorNodeId);
            const cId = String(currentNodeId);

            const successorNode = nodes.find(n => String(n.id) === sId);
            if (!successorNode) return;

            // Remove the dependency from successor
            if (successorNode.taskDependencies) {
                successorNode.taskDependencies = successorNode.taskDependencies.filter(d => String(d.taskId) !== cId);
            }

            // Remove from connections
            const connIdx = connections.findIndex(c =>
                (String(c.from) === cId && String(c.to) === sId) ||
                (String(c.from) === sId && String(c.to) === cId)
            );
            if (connIdx !== -1) {
                connections.splice(connIdx, 1);
            }

            // Refresh views
            renderConnections();

            // Refresh task editor if open
            const taskIdInput = document.getElementById('editingTaskId');
            if (taskIdInput && taskIdInput.value) {
                const editingNodeId = taskIdInput.value.replace('node:', '');
                if (String(editingNodeId) === cId) {
                    renderTaskDependencies(parseInt(editingNodeId));
                }
            }

            // Refresh properties panel
            if (selectedNode && String(selectedNode) === cId) {
                updatePropertiesPanel(currentNodeId);
            }

            saveToLocalStorage();
            showToast('‚úÇÔ∏è Baƒüƒ±mlƒ±lƒ±k silindi');
        }

        // Update lag for predecessor dependency from Properties Panel
        function updatePropDependencyLag(nodeId, depTaskId, newLag) {
            const nId = String(nodeId);
            const dId = String(depTaskId);
            const node = nodes.find(n => String(n.id) === nId);
            if (!node || !node.taskDependencies) return;

            const dep = node.taskDependencies.find(d => String(d.taskId) === dId);
            if (dep) {
                dep.lag = parseInt(newLag) || 0;
                
                // IMPORTANT: Update task dates based on new lag value
                if (typeof updateTaskDatesFromDependency === 'function') {
                    updateTaskDatesFromDependency(nId);
                }
                
                saveToLocalStorage();
                refreshAllTaskViews();
                showToast(`‚úì Gecikme: ${dep.lag}`);
            }
        }

        // Update lag unit for predecessor dependency from Properties Panel
        function updatePropDependencyLagUnit(nodeId, depTaskId, newUnit) {
            const nId = String(nodeId);
            const dId = String(depTaskId);
            const node = nodes.find(n => String(n.id) === nId);
            if (!node || !node.taskDependencies) return;

            const dep = node.taskDependencies.find(d => String(d.taskId) === dId);
            if (dep) {
                dep.lagUnit = newUnit;
                
                // IMPORTANT: Update task dates based on new lag unit
                if (typeof updateTaskDatesFromDependency === 'function') {
                    updateTaskDatesFromDependency(nId);
                }
                
                saveToLocalStorage();
                refreshAllTaskViews();
                const unitNames = { hours: 'Saat', days: 'G√ºn', weeks: 'Hafta', months: 'Ay' };
                showToast(`‚úì Birim: ${unitNames[newUnit] || newUnit}`);
            }
        }

        // Update successor's lag
        function updateSuccessorLag(successorNodeId, currentNodeId, newLag) {
            const sId = String(successorNodeId);
            const cId = String(currentNodeId);
            const successorNode = nodes.find(n => String(n.id) === sId);
            if (!successorNode || !successorNode.taskDependencies) return;

            const dep = successorNode.taskDependencies.find(d => String(d.taskId) === cId);
            if (dep) {
                dep.lag = parseInt(newLag) || 0;
                saveToLocalStorage();
                showToast(`‚úì Gecikme: ${dep.lag}`);
            }
        }

        // Update successor's lag unit
        function updateSuccessorLagUnit(successorNodeId, currentNodeId, newUnit) {
            const sId = String(successorNodeId);
            const cId = String(currentNodeId);
            const successorNode = nodes.find(n => String(n.id) === sId);
            if (!successorNode || !successorNode.taskDependencies) return;

            const dep = successorNode.taskDependencies.find(d => String(d.taskId) === cId);
            if (dep) {
                dep.lagUnit = newUnit;
                saveToLocalStorage();
                const unitNames = { hours: 'Saat', days: 'G√ºn', weeks: 'Hafta', months: 'Ay' };
                showToast(`‚úì Birim: ${unitNames[newUnit] || newUnit}`);
            }
        }

        // Render available tasks for dependency selection
        function renderAvailableTasksForDependency(currentNodeId) {
            const taskNodes = nodes.filter(n =>
                (n.isTaskNode || TASK_NODE_TYPES[n.type]) && n.id !== currentNodeId
            );

            return taskNodes.map(n => {
                const typeInfo = getAllTaskTypes()[n.type] || { icon: 'üìã', name: 'Task' };
                return `<option value="${n.id}">${typeInfo.icon} ${n.title}</option>`;
            }).join('');
        }

        // Add dependency from properties panel
        function addPropDependency(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            const depSelect = document.getElementById('propAddDependencySelect');
            const typeSelect = document.getElementById('propAddDependencyType');

            const depTaskId = depSelect?.value;
            const depType = typeSelect?.value || 'FS';

            if (!depTaskId) {
                showToast('L√ºtfen bir task se√ßin', 'error');
                return;
            }

            // Initialize taskDependencies if not exists
            if (!node.taskDependencies) {
                node.taskDependencies = [];
            }

            // Check if already exists
            if (node.taskDependencies.some(d => d.taskId === depTaskId)) {
                showToast('Bu baƒüƒ±mlƒ±lƒ±k zaten mevcut', 'error');
                return;
            }

            // Add dependency
            node.taskDependencies.push({ taskId: depTaskId, type: depType, lag: 0, lagUnit: 'days' });

            // IMPORTANT: Update task dates based on new dependency
            if (typeof updateTaskDatesFromDependency === 'function') {
                updateTaskDatesFromDependency(nodeId);
            }

            // Create visual connection if not exists
            const connExists = connections.some(c =>
                (c.from === depTaskId && c.to === nodeId) ||
                (c.from === nodeId && c.to === depTaskId)
            );
            
            refreshAllTaskViews();

            if (!connExists) {
                connections.push({
                    from: depTaskId,
                    to: nodeId,
                    dependencyType: depType,
                    color: '#f59e0b'  // Orange for dependencies
                });
            } else {
                // Update existing connection with dependency type
                const conn = connections.find(c =>
                    (c.from === depTaskId && c.to === nodeId) ||
                    (c.from === nodeId && c.to === depTaskId)
                );
                if (conn) {
                    conn.dependencyType = depType;
                }
            }

            // Refresh UI
            const container = document.getElementById('propTaskDependencies');
            if (container) {
                container.innerHTML = renderPropTaskDependencies(node);
            }

            // Reset select
            depSelect.value = '';

            renderConnections();
            saveToLocalStorage();
            refreshTimelineIfVisible();
            showToast(`‚úì ${depType} baƒüƒ±mlƒ±lƒ±k eklendi`);
        }

        // Remove dependency from properties panel
        function removePropDependency(nodeId, depTaskId) {
            const nId = String(nodeId);
            const dId = String(depTaskId);

            const node = nodes.find(n => String(n.id) === nId);
            if (!node || !node.taskDependencies) return;

            // Remove from taskDependencies
            node.taskDependencies = node.taskDependencies.filter(d => String(d.taskId) !== dId);

            // Remove connection
            connections = connections.filter(c =>
                !(String(c.from) === dId && String(c.to) === nId) &&
                !(String(c.from) === nId && String(c.to) === dId)
            );

            // Refresh UI
            const container = document.getElementById('propTaskDependencies');
            if (container) {
                container.innerHTML = renderPropTaskDependencies(node);
            }

            renderConnections();
            saveToLocalStorage();
            refreshAllTaskViews();
            showToast('‚úÇÔ∏è Baƒüƒ±mlƒ±lƒ±k kaldƒ±rƒ±ldƒ±');
        }

        // Apply task properties changes
        function applyTaskPropertiesChanges() {
            if (!propEditingNodeId) return;

            const node = nodes.find(n => n.id === propEditingNodeId);
            if (!node) return;

            saveUndoState('update task properties');

            // Get values from form
            node.title = document.getElementById('propTitle')?.value || '';
            node.type = document.getElementById('propType')?.value || 'todo';
            node.isTaskNode = true; // Ensure it stays a task node
            node.summary = document.getElementById('propSummary')?.value || '';
            node.taskStatus = document.getElementById('propTaskStatus')?.value || 'todo';
            node.taskPriority = document.getElementById('propTaskPriority')?.value || 'medium';
            node.taskProgress = parseInt(document.getElementById('propTaskProgress')?.value) || 0;
            node.taskDuration = parseInt(document.getElementById('propTaskDuration')?.value) || 1;
            node.taskDurationType = document.getElementById('propTaskDurationType')?.value || 'hours';
            node.taskAssignedBy = document.getElementById('propTaskAssignedBy')?.value || '';

            // IMPORTANT: Apply dependency logic BEFORE setting dates
            // If task has dependencies, dates should be calculated from parent task based on dependency type
            // This ensures SS tasks take parent's start date, FF tasks take parent's end date, etc.
            const hasDependencies = node.taskDependencies && node.taskDependencies.length > 0;
            if (hasDependencies) {
                // Get primary dependency (first one)
                const primaryDep = node.taskDependencies[0];
                const parentTask = nodes.find(n => String(n.id) === String(primaryDep.taskId));
                
                if (parentTask) {
                    const depType = primaryDep.type || 'FS';
                    const lag = primaryDep.lag || 0;
                    const lagUnit = primaryDep.lagUnit || 'days';
                    
                    // Calculate lag in milliseconds
                    let lagMs = 0;
                    switch(lagUnit) {
                        case 'minutes': lagMs = lag * 60 * 1000; break;
                        case 'hours': lagMs = lag * 60 * 60 * 1000; break;
                        case 'days': lagMs = lag * 24 * 60 * 60 * 1000; break;
                        case 'weeks': lagMs = lag * 7 * 24 * 60 * 60 * 1000; break;
                        case 'months': lagMs = lag * 30 * 24 * 60 * 60 * 1000; break;
                    }
                    
                    const parentStart = parentTask.taskDateStart ? new Date(parentTask.taskDateStart) : null;
                    const parentEnd = parentTask.taskDateDue ? new Date(parentTask.taskDateDue) : null;
                    
                    // Apply dependency logic based on type
                    switch(depType) {
                        case 'SS': // Start-to-Start: This task starts when parent starts
                            if (parentStart) {
                                const newStart = new Date(parentStart.getTime() + lagMs);
                                node.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                // Calculate end date based on duration
                                const duration = node.taskDuration || 1;
                                const durationType = node.taskDurationType || 'days';
                                let dueDate = new Date(newStart);
                                switch(durationType) {
                                    case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                    case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                    case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                    case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                }
                                node.taskDateDue = dueDate.toISOString().split('T')[0] + 'T18:00';
                            }
                            break;
                        case 'FF': // Finish-to-Finish: This task finishes when parent finishes
                            if (parentEnd) {
                                const newEnd = new Date(parentEnd.getTime() + lagMs);
                                node.taskDateDue = newEnd.toISOString().split('T')[0] + 'T18:00';
                                // Calculate start date based on duration (backwards from end)
                                const duration = node.taskDuration || 1;
                                const durationType = node.taskDurationType || 'days';
                                let durationMs = duration * 24 * 60 * 60 * 1000;
                                if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                const newStart = new Date(newEnd.getTime() - durationMs);
                                node.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                            }
                            break;
                        case 'FS': // Finish-to-Start: This task starts after parent finishes
                            if (parentEnd) {
                                const newStart = new Date(parentEnd.getTime() + lagMs);
                                node.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                                // Calculate end date based on duration
                                const duration = node.taskDuration || 1;
                                const durationType = node.taskDurationType || 'days';
                                let dueDate = new Date(newStart);
                                switch(durationType) {
                                    case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                    case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                    case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                    case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                }
                                node.taskDateDue = dueDate.toISOString().split('T')[0] + 'T18:00';
                            }
                            break;
                        case 'SF': // Start-to-Finish: This task finishes when parent starts
                            if (parentStart) {
                                const newEnd = new Date(parentStart.getTime() + lagMs);
                                node.taskDateDue = newEnd.toISOString().split('T')[0] + 'T18:00';
                                // Calculate start date based on duration (backwards from end)
                                const duration = node.taskDuration || 1;
                                const durationType = node.taskDurationType || 'days';
                                let durationMs = duration * 24 * 60 * 60 * 1000;
                                if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                const newStart = new Date(newEnd.getTime() - durationMs);
                                node.taskDateStart = newStart.toISOString().split('T')[0] + 'T09:00';
                            }
                            break;
                        default:
                            // No dependency logic, use form values
                            node.taskDateStart = document.getElementById('propTaskDateStart')?.value || '';
                            node.taskDateDue = document.getElementById('propTaskDateDue')?.value || '';
                    }
                } else {
                    // Parent task not found, use form values
                    node.taskDateStart = document.getElementById('propTaskDateStart')?.value || '';
                    node.taskDateDue = document.getElementById('propTaskDateDue')?.value || '';
                }
            } else {
                // No dependencies, use form values directly
                node.taskDateStart = document.getElementById('propTaskDateStart')?.value || '';
                node.taskDateDue = document.getElementById('propTaskDateDue')?.value || '';
            }

            // Note: Linked node and dependency type are now managed through the Task Baƒüƒ±mlƒ±lƒ±klarƒ± section
            // Dependencies are stored in node.taskDependencies array

            // MS PROJECT LOGIC: Cascade update only applies to independent tasks or parent tasks
            // If this task has dependencies, it's a dependent task and its dates are calculated from parent
            // Only cascade update if this task has NO dependencies (it's an independent/parent task)
            // OR if this task's dates were changed and it has dependents
            const isDependentTask = hasDependencies;
            if (!isDependentTask && typeof cascadeUpdateDependentTasks === 'function') {
                // This is an independent task - cascade update its dependents
                cascadeUpdateDependentTasks(propEditingNodeId);
            } else if (isDependentTask && typeof cascadeUpdateDependentTasks === 'function') {
                // This is a dependent task - its dates are calculated from parent
                // But it might have its own dependents, so cascade update those
                cascadeUpdateDependentTasks(propEditingNodeId);
            }

            // Update UI - use refreshAllTaskViews for comprehensive update
            renderNode(node);
            renderConnections();
            updateStatsPanel();
            autoSave();
            refreshAllTaskViews();

            // Clear stored original state - changes are now permanent
            propOriginalConnections = null;

            showToast('‚úì Task ve baƒüƒ±mlƒ± g√∂revler g√ºncellendi');
        }

        // Delete task node from properties panel
        function deleteTaskNodeFromProperties(nodeId) {
            if (!confirm('Bu task\'ƒ± silmek istediƒüinize emin misiniz?')) return;

            saveUndoState('delete task node');

            const nodeToDelete = nodes.find(n => n.id === nodeId);
            if (!nodeToDelete) return;

            // Move to trash
            const deletedNode = {
                ...nodeToDelete,
                deletedAt: new Date().toISOString(),
                deletedConnections: connections.filter(c => c.from === nodeId || c.to === nodeId)
            };
            trash.push(deletedNode);

            // Remove from nodes and connections
            nodes = nodes.filter(n => n.id !== nodeId);
            connections = connections.filter(c => c.from !== nodeId && c.to !== nodeId);

            // Clear properties panel editing state
            propEditingNodeId = null;
            selectedNode = null;

            // Remove DOM element
            const el = document.getElementById(`node-${nodeId}`);
            if (el) el.remove();

            // Close properties panel or show empty state
            hidePropertiesPanel();

            renderConnections();
            renderTaskList();
            updateStatsPanel();
            renderOutline();
            saveToLocalStorage();
            showToast('Task silindi');
        }

        // Cancel changes - restore original values
        function cancelPropertiesChanges() {
            if (!propEditingNodeId || !propOriginalValues) return;

            // Restore form to original values
            const el = (id) => document.getElementById(id);
            if (el('propTitle')) el('propTitle').value = propOriginalValues.title;
            if (el('propType')) el('propType').value = propOriginalValues.type;
            if (el('propSummary')) el('propSummary').value = propOriginalValues.summary;
            if (el('propPovId')) el('propPovId').value = propOriginalValues.povId || '';
            if (el('propTarget')) el('propTarget').value = propOriginalValues.target;
            if (el('propFullText')) el('propFullText').value = propOriginalValues.fullText;
            if (el('propNotes')) el('propNotes').value = propOriginalValues.notes;

            // Restore connections if they were modified
            if (propOriginalConnections) {
                connections = propOriginalConnections.connections;
                propOriginalConnections.nodeParentIds.forEach(item => {
                    const node = nodes.find(n => String(n.id) === String(item.id));
                    if (node) node.parentId = item.parentId;
                });
                renderConnections();
                updatePropertiesPanel(propEditingNodeId);
            }

            showToast('Deƒüi≈üiklikler iptal edildi');
        }

        function updateNodeProperty(nodeId, property, value) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            saveUndoState('update property');
            node[property] = value;
            renderNode(node);
            renderConnections();
            renderOutline();
            autoSave();
        }

        function addTagToNode(nodeId, tagId) {
            if (!tagId) return;
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.descs) node.descs = [];
            const id = parseInt(tagId);
            if (!node.descs.includes(id)) {
                saveUndoState('add tag');
                node.descs.push(id);
                renderNode(node);
                updatePropertiesPanel(nodeId);
                autoSave();
            }
        }

        function removeTagFromNode(nodeId, tagIndex) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node || !node.descs) return;

            saveUndoState('remove tag');
            // Remove by index
            node.descs.splice(tagIndex, 1);
            renderNode(node);
            updatePropertiesPanel(nodeId);
            autoSave();
        }

        function addTagToNodeFromPanel(nodeId) {
            // Convert nodeId to proper type (might be string from onclick)
            const nId = typeof nodeId === 'string' ? (isNaN(parseInt(nodeId)) ? nodeId : parseInt(nodeId)) : nodeId;

            const select = document.getElementById('propTagSelect');
            const valueInput = document.getElementById('propTagValue');
            if (!select || !select.value) {
                showToast('L√ºtfen bir tag tipi se√ßin', 'error');
                return;
            }

            const tagId = parseInt(select.value);
            const tagValue = valueInput ? valueInput.value.trim() : '';
            const node = nodes.find(n => n.id === nId || n.id === nodeId);
            if (!node) {
                console.error('Node not found:', nodeId);
                return;
            }

            if (!node.descs) node.descs = [];

            // Check if same tag type already exists
            const existingTag = node.descs.find(d =>
                (typeof d === 'object' ? d.tid : d) === tagId
            );
            if (existingTag) {
                showToast('This tag type already exists');
                return;
            }

            saveUndoState('add tag');
            // Use new format {tid, val}
            const desc = descTypes.find(d => d.id === tagId);
            node.descs.push({
                tid: tagId,
                val: tagValue || (desc ? sanitizeText(desc.name) : 'Tag')
            });
            renderNode(node);
            updatePropertiesPanel(nodeId);
            autoSave();

            // Clear selection
            select.value = '';
            if (valueInput) valueInput.value = '';
            showToast('Tag added');
        }

        function escapeHtml(text) {
            if (!text) return '';
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // Convert HTML to plain text for display
        function htmlToPlainText(html) {
            if (!html) return '';
            const div = document.createElement('div');
            div.innerHTML = html;
            return div.textContent || div.innerText || '';
        }

        // Load properties panel state on startup
        function loadPropertiesPanelState() {
            const saved = localStorage.getItem('propertiesPanelVisible');
            if (saved === 'true') {
                propertiesPanelVisible = true;
                const panel = document.getElementById('propertiesPanel');
                const menuLabel = document.getElementById('propertiesPanelMenuLabel');
                const zoomControls = document.getElementById('zoomControls');
                if (panel) panel.classList.add('active');
                if (menuLabel) menuLabel.textContent = 'Hide Properties Panel';
                // Move zoom controls left to avoid overlap
                if (zoomControls) zoomControls.style.right = '340px';
            }
        }

        function addNode(type) {
            hideAllMenus();

            // Save state for undo
            saveUndoState('add node');

            const sL = canvasContainer.scrollLeft;
            const sT = canvasContainer.scrollTop;

            const newNode = {
                id: 'node_' + (idCounter.node++),
                type,
                title: type.toUpperCase(),
                summary: 'Add summary...',
                fullText: '',
                povId: null,
                descs: [],
                notes: '',
                x: 100 + sL,
                y: 100 + sT
            };

            nodes.push(newNode);
            renderNode(newNode);
            selectNode(newNode.id);
            openFullEditor(newNode.id);
            updateAllStats();
            renderOutline();
        }

        // Function to get all task types (default + custom)
        function getAllTaskTypes() {
            const types = { ...TASK_NODE_TYPES };
            CUSTOM_TASK_TYPES.forEach(t => {
                types[t.id] = { icon: t.icon, name: t.name, color: t.color };
            });
            return types;
        }

        function addTaskNode(taskType) {
            hideAllMenus();
            saveUndoState('add task node');

            const sL = canvasContainer.scrollLeft;
            const sT = canvasContainer.scrollTop;
            const allTypes = getAllTaskTypes();
            const typeInfo = allTypes[taskType] || TASK_NODE_TYPES['todo'];

            const newNode = {
                id: 'node_' + (idCounter.node++),
                type: taskType,
                isTaskNode: true,
                title: typeInfo.name.toUpperCase(),
                summary: '',
                fullText: '',
                x: 100 + sL,
                y: 100 + sT,
                // Task specific properties
                taskStatus: 'todo',
                taskPriority: 'medium',
                taskProgress: 0,
                taskDateStart: new Date().toISOString().slice(0, 16),
                taskDateDue: '',
                taskAssignedBy: '',
                taskDuration: 1,
                taskDurationType: 'hours',
                linkedNodeIds: [], // Nodes this task is linked to
                // Task Dependencies (Task-to-Task relationships)
                // Format: [{taskId: 'node_x', type: 'FS', lag: 0, lagUnit: 'hours'}]
                // Types: FS (Finish-to-Start), SS (Start-to-Start), FF (Finish-to-Finish), SF (Start-to-Finish)
                taskDependencies: []
            };

            // If there's an active filter, use it as default status for new task
            if (currentTaskFilter && currentTaskFilter !== 'all') {
                newNode.taskStatus = currentTaskFilter;
            }

            nodes.push(newNode);
            renderNode(newNode);
            selectNode(newNode.id);
            closeModal('taskManagerModal');
            openTaskNodeEditor(newNode.id);
            updateAllStats();
            renderOutline();
            renderTaskList(); // Update Task Manager list
            saveToLocalStorage();
            console.log('Task Node added:', newNode.type, newNode.isTaskNode);
        }

        function openTaskNodeEditor(nodeId) {
            hideAllMenus();
            const nId = nodeId || selectedNode;
            const node = nodes.find(n => String(n.id) === String(nId));
            if (!node) {
                console.warn('openTaskNodeEditor: Node not found for ID:', nId);
                return;
            }
            console.log('Opening task editor for node:', nId, 'Dependencies:', node.taskDependencies);

            // Populate task editor with node data
            document.getElementById('editingTaskId').value = '';
            document.getElementById('taskEditorTitle').textContent = `‚úèÔ∏è Edit ${TASK_NODE_TYPES[node.type]?.name || 'Task'}`;

            document.getElementById('taskTitle').value = node.title || '';
            document.getElementById('taskDescription').value = node.summary || '';

            // Populate status dropdown first, then set value
            populateTaskStatusOptions();
            document.getElementById('taskStatus').value = node.taskStatus || 'todo';
            document.getElementById('taskImportance').value = node.taskPriority || 'medium';
            document.getElementById('taskAssignedBy').value = node.taskAssignedBy || '';
            document.getElementById('taskProgress').value = node.taskProgress || 0;
            document.getElementById('taskDuration').value = node.taskDuration || 1;
            document.getElementById('taskDurationType').value = node.taskDurationType || 'hours';

            // IMPORTANT: If task has dependencies, calculate dates from parent task based on dependency type
            // This ensures SS tasks show parent's start date, FF tasks show parent's end date, etc.
            let startVal = node.taskDateStart || '';
            let endVal = node.taskDateDue || '';
            
            const hasDependencies = node.taskDependencies && node.taskDependencies.length > 0;
            if (hasDependencies) {
                const primaryDep = node.taskDependencies[0];
                const parentTask = nodes.find(n => String(n.id) === String(primaryDep.taskId));
                
                if (parentTask) {
                    const depType = primaryDep.type || 'FS';
                    const lag = primaryDep.lag || 0;
                    const lagUnit = primaryDep.lagUnit || 'days';
                    
                    // Calculate lag in milliseconds
                    let lagMs = 0;
                    switch(lagUnit) {
                        case 'minutes': lagMs = lag * 60 * 1000; break;
                        case 'hours': lagMs = lag * 60 * 60 * 1000; break;
                        case 'days': lagMs = lag * 24 * 60 * 60 * 1000; break;
                        case 'weeks': lagMs = lag * 7 * 24 * 60 * 60 * 1000; break;
                        case 'months': lagMs = lag * 30 * 24 * 60 * 60 * 1000; break;
                    }
                    
                    const parentStart = parentTask.taskDateStart ? new Date(parentTask.taskDateStart) : null;
                    const parentEnd = parentTask.taskDateDue ? new Date(parentTask.taskDateDue) : null;
                    
                    // Calculate dates based on dependency type
                    switch(depType) {
                        case 'SS': // Start-to-Start: This task starts when parent starts
                            if (parentStart) {
                                const newStart = new Date(parentStart.getTime() + lagMs);
                                startVal = newStart.toISOString().slice(0, 16);
                                // Calculate end date based on duration
                                const duration = node.taskDuration || 1;
                                const durationType = node.taskDurationType || 'days';
                                let dueDate = new Date(newStart);
                                switch(durationType) {
                                    case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                    case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                    case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                    case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                }
                                endVal = dueDate.toISOString().slice(0, 16);
                            }
                            break;
                        case 'FF': // Finish-to-Finish: This task finishes when parent finishes
                            if (parentEnd) {
                                const newEnd = new Date(parentEnd.getTime() + lagMs);
                                endVal = newEnd.toISOString().slice(0, 16);
                                // Calculate start date based on duration (backwards from end)
                                const duration = node.taskDuration || 1;
                                const durationType = node.taskDurationType || 'days';
                                let durationMs = duration * 24 * 60 * 60 * 1000;
                                if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                const newStart = new Date(newEnd.getTime() - durationMs);
                                startVal = newStart.toISOString().slice(0, 16);
                            }
                            break;
                        case 'FS': // Finish-to-Start: This task starts after parent finishes
                            if (parentEnd) {
                                const newStart = new Date(parentEnd.getTime() + lagMs);
                                startVal = newStart.toISOString().slice(0, 16);
                                // Calculate end date based on duration
                                const duration = node.taskDuration || 1;
                                const durationType = node.taskDurationType || 'days';
                                let dueDate = new Date(newStart);
                                switch(durationType) {
                                    case 'hours': dueDate.setHours(dueDate.getHours() + duration); break;
                                    case 'days': dueDate.setDate(dueDate.getDate() + duration); break;
                                    case 'weeks': dueDate.setDate(dueDate.getDate() + (duration * 7)); break;
                                    case 'months': dueDate.setMonth(dueDate.getMonth() + duration); break;
                                }
                                endVal = dueDate.toISOString().slice(0, 16);
                            }
                            break;
                        case 'SF': // Start-to-Finish: This task finishes when parent starts
                            if (parentStart) {
                                const newEnd = new Date(parentStart.getTime() + lagMs);
                                endVal = newEnd.toISOString().slice(0, 16);
                                // Calculate start date based on duration (backwards from end)
                                const duration = node.taskDuration || 1;
                                const durationType = node.taskDurationType || 'days';
                                let durationMs = duration * 24 * 60 * 60 * 1000;
                                if (durationType === 'hours') durationMs = duration * 60 * 60 * 1000;
                                else if (durationType === 'weeks') durationMs = duration * 7 * 24 * 60 * 60 * 1000;
                                else if (durationType === 'months') durationMs = duration * 30 * 24 * 60 * 60 * 1000;
                                const newStart = new Date(newEnd.getTime() - durationMs);
                                startVal = newStart.toISOString().slice(0, 16);
                            }
                            break;
                        default:
                            // No dependency logic, use node's current dates
                            if (startVal && startVal.length === 10) startVal += 'T09:00';
                            if (endVal && endVal.length === 10) endVal += 'T18:00';
                    }
                } else {
                    // Parent task not found, use node's current dates
                    if (startVal && startVal.length === 10) startVal += 'T09:00';
                    if (endVal && endVal.length === 10) endVal += 'T18:00';
                }
            } else {
                // No dependencies, use node's current dates
                if (startVal && startVal.length === 10) startVal += 'T09:00';
                if (endVal && endVal.length === 10) endVal += 'T18:00';
            }
            
            document.getElementById('taskDateStart').value = startVal;
            document.getElementById('taskDateEstimated').value = endVal;
            
            // IMPORTANT: If task has dependencies, disable date inputs and show calculated dates
            // This prevents users from manually changing dates that should be calculated from parent task
            const dateStartInput = document.getElementById('taskDateStart');
            const dateEndInput = document.getElementById('taskDateEstimated');
            if (hasDependencies && dateStartInput && dateEndInput) {
                dateStartInput.disabled = true;
                dateEndInput.disabled = true;
                dateStartInput.title = 'Bu tarih baƒüƒ±mlƒ±lƒ±k tipine g√∂re otomatik hesaplanƒ±yor (SS: parent ba≈ülangƒ±√ß, FF: parent biti≈ü)';
                dateEndInput.title = 'Bu tarih baƒüƒ±mlƒ±lƒ±k tipine g√∂re otomatik hesaplanƒ±yor (SS: parent ba≈ülangƒ±√ß, FF: parent biti≈ü)';
                dateStartInput.style.opacity = '0.7';
                dateEndInput.style.opacity = '0.7';
                dateStartInput.style.cursor = 'not-allowed';
                dateEndInput.style.cursor = 'not-allowed';
            } else if (dateStartInput && dateEndInput) {
                dateStartInput.disabled = false;
                dateEndInput.disabled = false;
                dateStartInput.title = '';
                dateEndInput.title = '';
                dateStartInput.style.opacity = '1';
                dateEndInput.style.opacity = '1';
                dateStartInput.style.cursor = 'text';
                dateEndInput.style.cursor = 'text';
            }

            // Store the node ID we're editing
            document.getElementById('editingTaskId').value = 'node:' + nId;

            populateTaskNodeSelect();

            // Get assigned node - check linkedNodeIds first, then parentId (from connection)
            let assignedNodeId = node.linkedNodeIds?.[0] || node.parentId || '';

            // Also check if there's a connection to another node
            if (!assignedNodeId) {
                const conn = connections.find(c => String(c.from) === String(nId) || String(c.to) === String(nId));
                if (conn) {
                    assignedNodeId = String(c.from) === String(nId) ? conn.to : conn.from;
                }
            }

            document.getElementById('taskAssignedNode').value = assignedNodeId;

            // Render task dependencies
            renderTaskDependencies(nId);

            // Populate dependency task select dropdown
            populateDependencyTaskSelect(nId);

            openModal('taskEditorModal');
        }

        function duplicateNode() {
            if (!selectedNode) return;
            const orig = nodes.find(n => n.id === selectedNode);
            if (!orig) return;

            const newNode = {
                ...orig,
                id: 'node_' + (idCounter.node++),
                x: orig.x + 30,
                y: orig.y + 30,
                title: orig.title + ' (kopya)',
                descs: orig.descs ? [...orig.descs] : [],
                parentId: null  // Remove parent connection - duplicate as independent node
            };

            nodes.push(newNode);
            renderNode(newNode);
            selectNode(newNode.id);
            hideAllMenus();
            updateAllStats();
            renderOutline();
            saveToLocalStorage();
            refreshTimelineIfVisible();
            showToast('Duplicated');
        }
        
        // Refresh timeline if it's currently visible
        function refreshTimelineIfVisible() {
            if (currentTaskViewMode === 'timeline') {
                renderTaskTimeline();
            }
            // Also refresh main page timeline if visible
            if (timelineBarVisible && typeof renderTimelineBar === 'function') {
                renderTimelineBar();
            }
            // Also refresh task list if visible
            const taskListContainer = document.getElementById('taskListContainer');
            if (taskListContainer && taskListContainer.style.display !== 'none') {
                renderTaskList();
            }
        }

        function deleteSelected() {
            if (!selectedNode) { showToast('√ñnce bir node se√ßin'); return; }
            if (!confirm('Silmek istediƒüinizden emin misiniz? (√á√∂p kutusundan geri alabilirsiniz)')) return;

            // Find the node to delete
            const nodeToDelete = nodes.find(n => n.id === selectedNode);
            if (!nodeToDelete) return;

            // Save to undo stack
            saveUndoState('delete');

            // Move node to trash with timestamp
            const deletedNode = {
                ...nodeToDelete,
                deletedAt: new Date().toISOString(),
                deletedConnections: connections.filter(c => c.from === selectedNode || c.to === selectedNode)
            };
            trash.push(deletedNode);

            // Remove from nodes and connections
            const nId = String(selectedNode);
            nodes = nodes.filter(n => String(n.id) !== nId);
            connections = connections.filter(c => String(c.from) !== nId && String(c.to) !== nId);

            const deletedNodeId = selectedNode;
            const el = document.getElementById(`node-${deletedNodeId}`);
            if (el) {
                el.remove();
            }

            selectedNode = null;
            hidePropertiesPanel();
            
            // Immediately re-render everything
            renderConnections();
            updateAllStats();
            renderOutline();
            refreshTimelineIfVisible();
            
            saveToLocalStorage();
            showToast('√á√∂p kutusuna ta≈üƒ±ndƒ±');
        }

        // ============ LAYOUT MENU ============
        function showLayoutMenu(e) {
            e.stopPropagation();
            document.getElementById('layoutModal').classList.add('active');
        }

        function closeLayoutMenu() {
            document.getElementById('layoutModal').classList.remove('active');
        }

        function applyLayout(type) {
            closeLayoutMenu();

            if (nodes.length === 0) {
                showToast('Node yok - √∂nce node ekleyin');
                return;
            }

            try {
            switch(type) {
                case 'tree':
                    layoutTree();
                    break;
                case 'freeform':
                    // Keep current positions, just show toast
                    showToast('üìç Free Form - drag nodes anywhere');
                    return; // Don't auto-fit for freeform
                case 'horizontal':
                    layoutHorizontal();
                    break;
                case 'vertical':
                    layoutVertical();
                    break;
                case 'grid':
                    layoutGrid();
                    break;
                case 'radial':
                    layoutRadial();
                    break;
                case 'timeline':
                    layoutTimeline();
                    break;
                case 'mindmap':
                    layoutMindMap();
                    break;
            }

                // Re-render everything
                renderAll();
                renderConnections();

            // Auto fit to screen after layout is applied
            setTimeout(() => {
                fitToScreen();
                }, 200);
            } catch (e) {
                console.error('Layout error:', e);
                showToast('‚ùå Layout hatasƒ±: ' + e.message);
            }
        }

        // SimpleMind Pro style layouts - IMPROVED spacing for large hierarchies
        const LAYOUT_CONFIG = {
            nodeWidth: 240,
            nodeHeight: 160,
            minX: 100,
            minY: 100,
            gapX: 100,  // Increased horizontal gap
            gapY: 80    // Increased vertical gap
        };

        // Clamp node position within canvas bounds
        function clampPosition(node) {
            const maxX = CANVAS_WIDTH - LAYOUT_CONFIG.nodeWidth - 50;
            const maxY = CANVAS_HEIGHT - LAYOUT_CONFIG.nodeHeight - 50;
            node.x = Math.max(20, Math.min(node.x, maxX));
            node.y = Math.max(20, Math.min(node.y, maxY));
        }

        // Adjust canvas size based on node positions - IMPROVED for large layouts
        function adjustCanvasSize() {
            if (nodes.length === 0) return;

            let maxX = 0, maxY = 0, minX = Infinity, minY = Infinity;
            nodes.forEach(n => {
                maxX = Math.max(maxX, n.x + LAYOUT_CONFIG.nodeWidth + 300);
                maxY = Math.max(maxY, n.y + LAYOUT_CONFIG.nodeHeight + 300);
                minX = Math.min(minX, n.x);
                minY = Math.min(minY, n.y);
            });

            // If nodes are positioned with negative or very small coordinates, shift them
            if (minX < 50) {
                const shiftX = 100 - minX;
                nodes.forEach(n => n.x += shiftX);
                maxX += shiftX;
            }
            if (minY < 50) {
                const shiftY = 100 - minY;
                nodes.forEach(n => n.y += shiftY);
                maxY += shiftY;
            }

            // Minimum size is base canvas, grow significantly if needed
            const newWidth = Math.max(CANVAS_WIDTH, maxX + 500);
            const newHeight = Math.max(CANVAS_HEIGHT, maxY + 500);

            const canvasEl = document.getElementById('canvas');
            const svgEl = document.getElementById('connections');

            canvasEl.style.width = newWidth + 'px';
            canvasEl.style.height = newHeight + 'px';
            svgEl.style.width = newWidth + 'px';
            svgEl.style.height = newHeight + 'px';
            svgEl.setAttribute('viewBox', `0 0 ${newWidth} ${newHeight}`);
        }

        function layoutTree() {
            autoArrange();
        }

        // Horizontal: Root on left, children branch right (SimpleMind style) - FIXED for deep hierarchy
        function layoutHorizontal() {
            const { nodeWidth, nodeHeight, minX, minY, gapX, gapY } = LAYOUT_CONFIG;
            const roots = nodes.filter(n => !n.parentId);

            // First pass: calculate subtree heights
            function getSubtreeHeight(node) {
                const children = getChildren(node.id);
                if (children.length === 0) return nodeHeight;

                let totalHeight = 0;
                children.forEach((child, i) => {
                    if (i > 0) totalHeight += gapY;
                    totalHeight += getSubtreeHeight(child);
                });
                return Math.max(nodeHeight, totalHeight);
            }

            let currentY = minY;

            function placeHorizontally(node, depth, startY, availableHeight) {
                const children = getChildren(node.id);

                // Place this node centered in available height
                node.x = minX + depth * (nodeWidth + gapX);
                node.y = startY + (availableHeight - nodeHeight) / 2;

                if (children.length === 0) return;

                // Calculate heights for each child
                const childHeights = children.map(c => getSubtreeHeight(c));
                const totalChildrenHeight = childHeights.reduce((a, b) => a + b, 0) + (children.length - 1) * gapY;

                // Start children centered under this node's available space
                let childY = startY + (availableHeight - totalChildrenHeight) / 2;

                children.forEach((child, i) => {
                    placeHorizontally(child, depth + 1, childY, childHeights[i]);
                    childY += childHeights[i] + gapY;
                });
            }

            roots.forEach(root => {
                const treeHeight = getSubtreeHeight(root);
                placeHorizontally(root, 0, currentY, treeHeight);
                currentY += treeHeight + gapY * 2;
            });

            // Place orphans
            const placed = new Set();
            function mark(n) { placed.add(n.id); getChildren(n.id).forEach(mark); }
            roots.forEach(mark);
            nodes.filter(n => !placed.has(n.id)).forEach(n => {
                n.x = minX;
                n.y = currentY;
                currentY += nodeHeight + gapY;
            });

            renderAll();
            renderConnections();
            adjustCanvasSize();
            showToast('‚ÜîÔ∏è Horizontal Layout');
        }

        // Vertical: Root on top, children below (org chart style) - FIXED for deep hierarchy
        function layoutVertical() {
            const { nodeWidth, nodeHeight, minX, minY, gapX, gapY } = LAYOUT_CONFIG;
            const roots = nodes.filter(n => !n.parentId);

            // First pass: calculate subtree widths
            function getSubtreeWidth(node) {
                const children = getChildren(node.id);
                if (children.length === 0) return nodeWidth;

                let totalWidth = 0;
                children.forEach((child, i) => {
                    if (i > 0) totalWidth += gapX;
                    totalWidth += getSubtreeWidth(child);
                });
                return Math.max(nodeWidth, totalWidth);
            }

            let currentX = minX;

            function placeVertically(node, depth, startX, availableWidth) {
                const children = getChildren(node.id);

                // Place this node centered in available width
                node.x = startX + (availableWidth - nodeWidth) / 2;
                node.y = minY + depth * (nodeHeight + gapY);

                if (children.length === 0) return;

                // Calculate widths for each child
                const childWidths = children.map(c => getSubtreeWidth(c));
                const totalChildrenWidth = childWidths.reduce((a, b) => a + b, 0) + (children.length - 1) * gapX;

                // Start children centered under this node
                let childX = startX + (availableWidth - totalChildrenWidth) / 2;

                children.forEach((child, i) => {
                    placeVertically(child, depth + 1, childX, childWidths[i]);
                    childX += childWidths[i] + gapX;
                });
            }

            roots.forEach(root => {
                const treeWidth = getSubtreeWidth(root);
                placeVertically(root, 0, currentX, treeWidth);
                currentX += treeWidth + gapX * 2;
            });

            // Place orphans
            const placed = new Set();
            function mark(n) { placed.add(n.id); getChildren(n.id).forEach(mark); }
            roots.forEach(mark);
            nodes.filter(n => !placed.has(n.id)).forEach(n => {
                n.x = currentX;
                n.y = minY;
                currentX += nodeWidth + gapX;
            });

            renderAll();
            renderConnections();
            adjustCanvasSize();
            showToast('‚ÜïÔ∏è Vertical Layout');
        }

        // Grid: Rows and columns, grouped by parent - FIXED spacing
        function layoutGrid() {
            const { nodeWidth, nodeHeight, minX, minY, gapX, gapY } = LAYOUT_CONFIG;

            // Separate by hierarchy level for better organization
            const roots = nodes.filter(n => !n.parentId);
            const sorted = [];

            function addWithChildren(node, depth) {
                sorted.push({ node, depth });
                getChildren(node.id).forEach(c => addWithChildren(c, depth + 1));
            }
            roots.forEach(r => addWithChildren(r, 0));

            // Add any orphans
            nodes.filter(n => !sorted.find(s => s.node === n)).forEach(n => sorted.push({ node: n, depth: 0 }));

            // Calculate optimal columns based on node count (max 6 for readability)
            const cols = Math.min(6, Math.max(3, Math.ceil(Math.sqrt(sorted.length))));
            const actualGapX = gapX + 20; // Extra horizontal spacing
            const actualGapY = gapY + 30; // Extra vertical spacing

            sorted.forEach(({ node }, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                node.x = minX + col * (nodeWidth + actualGapX);
                node.y = minY + row * (nodeHeight + actualGapY);
            });

            renderAll();
            renderConnections();
            adjustCanvasSize();
            showToast('‚äû Grid Layout');
        }

        // Radial: Root at center, children in expanding circles - FIXED for deep hierarchy
        function layoutRadial() {
            const { nodeWidth, nodeHeight, minX, minY, gapX, gapY } = LAYOUT_CONFIG;

            // Center position - more space for large trees
            const centerX = 1200;
            const centerY = 1000;

            const roots = nodes.filter(n => !n.parentId);
            if (roots.length === 0) return;

            const mainRoot = roots[0];

            // Place main root at center
            mainRoot.x = centerX - nodeWidth / 2;
            mainRoot.y = centerY - nodeHeight / 2;

            // Recursive function to place children in expanding circles
            function placeRadialChildren(parentNode, parentAngle, parentRadius, depth) {
                const children = getChildren(parentNode.id);
                if (children.length === 0 || depth > 10) return;

                // Increase radius with each level
                const baseRadius = 300;
                const radiusIncrement = 280;
                const radius = parentRadius + radiusIncrement;

                // Calculate angle spread based on number of children
                const angleSpread = Math.min(Math.PI * 0.8, children.length * 0.35);
                const startAngle = parentAngle - angleSpread / 2;
                const angleStep = children.length > 1 ? angleSpread / (children.length - 1) : 0;

                children.forEach((child, i) => {
                    const angle = children.length === 1 ? parentAngle : startAngle + i * angleStep;

                    child.x = centerX + radius * Math.cos(angle) - nodeWidth / 2;
                    child.y = centerY + radius * Math.sin(angle) - nodeHeight / 2;

                    // Recursively place grandchildren
                    placeRadialChildren(child, angle, radius, depth + 1);
                });
            }

            // Get direct children and distribute around the circle
            const children = getChildren(mainRoot.id);
            if (children.length > 0) {
                const angleStep = (Math.PI * 2) / children.length;

                children.forEach((child, i) => {
                    const angle = i * angleStep - Math.PI / 2;
                    const radius = 350;

                    child.x = centerX + radius * Math.cos(angle) - nodeWidth / 2;
                    child.y = centerY + radius * Math.sin(angle) - nodeHeight / 2;

                    // Place grandchildren and deeper
                    placeRadialChildren(child, angle, radius, 2);
                });
            }

            // Other roots placed in row at bottom
            let maxY = Math.max(...nodes.map(n => n.y)) + nodeHeight + 150;
            roots.slice(1).forEach((root, i) => {
                root.x = minX + i * (nodeWidth + gapX);
                root.y = maxY;

                // Place their children too
                const rootChildren = getChildren(root.id);
                rootChildren.forEach((child, j) => {
                    child.x = root.x + (j - (rootChildren.length - 1) / 2) * (nodeWidth + gapX / 2);
                    child.y = maxY + nodeHeight + gapY;
                });
            });

            renderAll();
            renderConnections();
            adjustCanvasSize();
            showToast('‚≠ï Radial Layout');
        }

        // Timeline: TRUE HORIZONTAL - roots on horizontal line, children below - FIXED spacing
        function layoutTimeline() {
            const { nodeWidth, nodeHeight, minX, minY, gapX, gapY } = LAYOUT_CONFIG;

            const actualGapX = gapX + 40; // More horizontal spacing
            const actualGapY = gapY + 20; // More vertical spacing
            const rowHeight = nodeHeight + actualGapY;

            // All roots go on the main horizontal timeline (Y = minY)
            const roots = nodes.filter(n => !n.parentId);
            let currentX = minX;

            function calculateTreeWidth(node, depth = 0) {
                if (depth > 10) return nodeWidth; // Prevent infinite recursion
                const children = getChildren(node.id);
                if (children.length === 0) return nodeWidth;

                let totalWidth = 0;
                children.forEach((child, i) => {
                    if (i > 0) totalWidth += actualGapX;
                    totalWidth += calculateTreeWidth(child, depth + 1);
                });
                return Math.max(nodeWidth, totalWidth);
            }

            function placeChildrenBelow(parent, startX, y, availableWidth, depth = 0) {
                if (depth > 10) return; // Prevent infinite recursion
                const children = getChildren(parent.id);
                if (children.length === 0) return;

                // Calculate total width of children
                const childWidths = children.map(child => calculateTreeWidth(child, depth + 1));
                const totalChildrenWidth = childWidths.reduce((a, b) => a + b, 0) + (children.length - 1) * actualGapX;

                // Center children under parent
                let childX = startX + (availableWidth - totalChildrenWidth) / 2;

                children.forEach((child, i) => {
                    const childWidth = childWidths[i];

                    // Place child centered in its allocated space
                    child.x = childX + (childWidth - nodeWidth) / 2;
                    child.y = y;

                    // Recursively place grandchildren
                    placeChildrenBelow(child, childX, y + rowHeight, childWidth, depth + 1);

                    childX += childWidth + actualGapX;
                });
            }

            roots.forEach(root => {
                // Calculate width needed for this root's tree
                const treeWidth = calculateTreeWidth(root);

                // Place root on timeline
                root.x = currentX + (treeWidth - nodeWidth) / 2;
                root.y = minY;

                // Place children below, recursively
                placeChildrenBelow(root, currentX, minY + rowHeight, treeWidth, 0);

                currentX += treeWidth + actualGapX * 2;
            });

            renderAll();
            renderConnections();
            adjustCanvasSize();
            showToast('üìÖ Timeline Layout');
        }

        // Mind Map: Root in middle, branches spread left and right - FIXED for deep hierarchy
        function layoutMindMap() {
            const { nodeWidth, nodeHeight, minX, minY, gapX, gapY } = LAYOUT_CONFIG;

            // Center should leave room for branches on both sides
            const centerX = 1500;
            const centerY = 800;
            const branchGapX = nodeWidth + 80;
            const branchGapY = nodeHeight + 50;

            const roots = nodes.filter(n => !n.parentId);
            const mainRoot = roots[0] || nodes[0];
            if (!mainRoot) return;

            // Calculate subtree height for proper spacing
            function getSubtreeHeight(node, maxDepth = 10) {
                if (maxDepth <= 0) return nodeHeight;
                const children = getChildren(node.id);
                if (children.length === 0) return nodeHeight;

                let totalHeight = 0;
                children.forEach((child, i) => {
                    if (i > 0) totalHeight += gapY;
                    totalHeight += getSubtreeHeight(child, maxDepth - 1);
                });
                return Math.max(nodeHeight, totalHeight);
            }

            // Recursive function to place branch and all descendants
            function placeBranch(node, x, startY, availableHeight, direction, depth) {
                const children = getChildren(node.id);

                // Place this node centered in available height
                node.x = x;
                node.y = startY + (availableHeight - nodeHeight) / 2;

                if (children.length === 0 || depth > 8) return;

                // Calculate heights for each child
                const childHeights = children.map(c => getSubtreeHeight(c, 8 - depth));
                const totalChildrenHeight = childHeights.reduce((a, b) => a + b, 0) + (children.length - 1) * gapY;

                // Start children centered
                let childY = startY + (availableHeight - totalChildrenHeight) / 2;
                const childX = x + direction * branchGapX;

                children.forEach((child, i) => {
                    placeBranch(child, childX, childY, childHeights[i], direction, depth + 1);
                    childY += childHeights[i] + gapY;
                });
            }

            // Place main root at center
            mainRoot.x = centerX;
            mainRoot.y = centerY;

            // Get direct children and split left/right
            const children = getChildren(mainRoot.id);
            const leftNodes = children.filter((_, i) => i % 2 === 0);
            const rightNodes = children.filter((_, i) => i % 2 === 1);

            // Place left branches (going left from root)
            const leftHeights = leftNodes.map(n => getSubtreeHeight(n));
            const totalLeftHeight = leftHeights.reduce((a, b) => a + b, 0) + (leftNodes.length - 1) * gapY;
            let leftY = centerY - totalLeftHeight / 2 + nodeHeight / 2;

            leftNodes.forEach((node, i) => {
                placeBranch(node, centerX - branchGapX, leftY, leftHeights[i], -1, 1);
                leftY += leftHeights[i] + gapY;
            });

            // Place right branches (going right from root)
            const rightHeights = rightNodes.map(n => getSubtreeHeight(n));
            const totalRightHeight = rightHeights.reduce((a, b) => a + b, 0) + (rightNodes.length - 1) * gapY;
            let rightY = centerY - totalRightHeight / 2 + nodeHeight / 2;

            rightNodes.forEach((node, i) => {
                placeBranch(node, centerX + nodeWidth + 80, rightY, rightHeights[i], 1, 1);
                rightY += rightHeights[i] + gapY;
            });

            // Other roots at bottom
            let bottomY = Math.max(...nodes.map(n => n.y), centerY) + nodeHeight + 150;
            roots.filter(r => r !== mainRoot).forEach((root, i) => {
                root.x = minX + i * (nodeWidth + gapX);
                root.y = bottomY;

                // Also place their children
                const rootChildren = getChildren(root.id);
                rootChildren.forEach((child, j) => {
                    child.x = root.x + (j + 1) * (nodeWidth + gapX / 2);
                    child.y = bottomY;
                });
            });

            renderAll();
            renderConnections();
            adjustCanvasSize();
            showToast('üß† Mind Map Layout');
        }

        // ============ AUTO ARRANGE (Tree) ============
        function autoArrange() {
            const nodeWidth = 240;
            const nodeHeight = 160;
            const horizontalGap = 100;  // Increased for better spacing
            const verticalGap = 100;    // Increased for better spacing
            const startY = 80;
            const startX = 80;
            const colWidth = nodeWidth + horizontalGap;
            const rowHeight = nodeHeight + verticalGap;

            let nextX = startX;

            // Recursive positioning - children under their parent
            // If node is collapsed, treat it as leaf (don't position hidden children)
            function positionTree(node, level, maxDepth = 15) {
                if (level > maxDepth) return { left: nextX, right: nextX + nodeWidth };

                const children = getChildren(node.id);

                // If no children OR node is collapsed, treat as leaf
                if (children.length === 0 || node.collapsed) {
                    // Leaf node or collapsed node
                    node.x = nextX;
                    node.y = startY + level * rowHeight;
                    nextX += colWidth;
                    return { left: node.x, right: node.x + nodeWidth };
                }

                // Position children first (only if not collapsed)
                let leftMost = Infinity;
                let rightMost = 0;
                children.forEach(child => {
                    const bounds = positionTree(child, level + 1, maxDepth);
                    leftMost = Math.min(leftMost, bounds.left);
                    rightMost = Math.max(rightMost, bounds.right);
                });

                // Center parent above children
                node.x = leftMost + (rightMost - leftMost - nodeWidth) / 2;
                node.y = startY + level * rowHeight;

                return { left: leftMost, right: rightMost };
            }

            // Position each root tree
            const rootNodes = nodes.filter(n => !n.parentId);
            rootNodes.forEach(root => {
                positionTree(root, 0);
                nextX += horizontalGap * 2;
            });

            // Handle orphans (nodes without parent or whose parent doesn't exist)
            const placed = new Set();
            function markVisible(n) {
                placed.add(n.id);
                if (!n.collapsed) {
                    getChildren(n.id).forEach(markVisible);
                }
            }
            rootNodes.forEach(markVisible);

            // Position unplaced nodes
            nodes.filter(n => !placed.has(n.id)).forEach((n, i) => {
                n.x = nextX + (i % 5) * colWidth;
                n.y = startY + Math.floor(i / 5) * rowHeight;
            });

            renderAll();
            renderConnections();
            adjustCanvasSize();
            showToast('‚ú® Tree arrange');
        }

        // ============ ZOOM ============
        function zoomIn() {
            zoom = Math.min(zoom + 0.1, 3);
            applyCanvasZoom();
        }

        function zoomOut() {
            zoom = Math.max(zoom - 0.1, 0.3);
            applyCanvasZoom();
        }

        function resetZoom() {
            zoom = 1;
            applyCanvasZoom();
        }

        function applyCanvasZoom() {
            // Apply transform scale to canvas and connections
            canvas.style.transform = `scale(${zoom})`;
            canvas.style.transformOrigin = '0 0';
            connectionsEl.style.transform = `scale(${zoom})`;
            connectionsEl.style.transformOrigin = '0 0';
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
        }

        function fitToScreen() {
            if (nodes.length === 0) {
                showToast('Node yok');
                return;
            }

            // Find bounds by querying all node elements directly
            let minX = Infinity, maxX = 0, minY = Infinity, maxY = 0;
            let foundNodes = 0;
            
            // Get all node elements from canvas
            const canvas = document.getElementById('canvas');
            const nodeElements = canvas.querySelectorAll('.node, .task-node-card, .folder-node, .sticky-node, .image-node');
            
            nodeElements.forEach(el => {
                const left = parseInt(el.style.left) || 0;
                const top = parseInt(el.style.top) || 0;
                const w = el.offsetWidth || 240;
                const h = el.offsetHeight || 200;
                
                minX = Math.min(minX, left);
                maxX = Math.max(maxX, left + w);
                minY = Math.min(minY, top);
                maxY = Math.max(maxY, top + h);
                foundNodes++;
            });
            
            // Fallback to node data if no DOM elements found
            if (foundNodes === 0) {
            nodes.forEach(n => {
                    const nx = Number.isFinite(n.x) ? n.x : 0;
                    const ny = Number.isFinite(n.y) ? n.y : 0;
                    const w = 240;
                    const h = 200;
                    minX = Math.min(minX, nx);
                    maxX = Math.max(maxX, nx + w);
                    minY = Math.min(minY, ny);
                    maxY = Math.max(maxY, ny + h);
                });
            }
            
            // Safety check
            if (!Number.isFinite(minX) || !Number.isFinite(maxX)) {
                minX = 0; maxX = 1000;
            }
            if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
                minY = 0; maxY = 800;
            }

            // Calculate needed zoom to fit all cards
            const contentW = maxX - minX + 100;
            const contentH = maxY - minY + 100;
            const containerW = canvasContainer.clientWidth || 800;
            const containerH = canvasContainer.clientHeight || 600;

            const fitZoom = Math.min(containerW / contentW, containerH / contentH, 1.5);
            zoom = Math.max(fitZoom, 0.2);
            applyCanvasZoom();

            // Scroll to center
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            canvasContainer.scrollLeft = (centerX * zoom) - containerW / 2;
            canvasContainer.scrollTop = (centerY * zoom) - containerH / 2;

            showToast(`üéØ Fit (${Math.round(zoom * 100)}%)`);
        }

        // ============ EXPORT/IMPORT ============
        // Save button now saves to LocalStorage (instead of downloading new file each time)
        function exportData() {
            saveToLocalStorage();
            showToast('üíæ Project saved');
        }

        // Save to LocalStorage
        function saveToLocalStorage() {
            const data = {
                nodes: nodes,
                connections: connections,
                povList: povList,
                descTypes: descTypes,
                revisionLabels: revisionLabels,
                tasks: tasks,
                taskIdCounter: taskIdCounter,
                TASK_STATUSES: TASK_STATUSES,
                TASK_NODE_TYPES: TASK_NODE_TYPES,  // Save default task types (can be edited)
                CUSTOM_TASK_TYPES: CUSTOM_TASK_TYPES,
                version: '4.1',
                lastSaved: new Date().toISOString()
            };
            localStorage.setItem('universalWriterStudio', JSON.stringify(data));
            console.log('Project saved:', new Date().toLocaleTimeString('en-US'));
        }

        // Load from LocalStorage
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('universalWriterStudio');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.nodes && data.nodes.length > 0) {
                        nodes = data.nodes;
                        connections = data.connections || [];
                        povList = data.povList || povList;
                        descTypes = data.descTypes ? sanitizeDescTypes(data.descTypes) : descTypes;
                        revisionLabels = data.revisionLabels || revisionLabels;
                        tasks = data.tasks || [];
                        taskIdCounter = data.taskIdCounter || 1;
                        // Load custom task statuses and types (with sanitization)
                        if (data.TASK_STATUSES) {
                            TASK_STATUSES = sanitizeTaskStatuses(data.TASK_STATUSES);
                        }
                        // Skip loading TASK_NODE_TYPES and CUSTOM_TASK_TYPES here
                        // They will be loaded and sanitized by loadTaskTypesFromStorage()
                        idCounter.node = Math.max(...nodes.map(n => parseInt(n.id.replace('node_', '')) || 0), 0) + 1;
                        idCounter.pov = Math.max(...povList.map(p => p.id), 0) + 1;
                        idCounter.desc = Math.max(...descTypes.map(d => d.id), 0) + 1;
                        return true;
                    }
                } catch(e) {
                    console.error('LocalStorage load error:', e);
                }
            }
            return false;
        }

        // Download as JSON file (for Backup)
        function downloadAsJson() {
            const data = { nodes, connections, povList, descTypes, revisionLabels, tasks, taskIdCounter, version: '4.1' };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '72_seconds_project.json';
            a.click();
            URL.revokeObjectURL(url);
            showToast('üì• JSON indirildi');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const data = JSON.parse(e.target.result);
                    nodes = data.nodes || [];
                    connections = data.connections || [];
                    povList = data.povList || povList;
                    descTypes = data.descTypes ? sanitizeDescTypes(data.descTypes) : descTypes;
                    tasks = data.tasks || [];
                    taskIdCounter = data.taskIdCounter || 1;
                    idCounter.node = Math.max(...nodes.map(n => parseInt(n.id.replace('node_', '')) || 0), 0) + 1;
                    idCounter.pov = Math.max(...povList.map(p => p.id), 0) + 1;
                    idCounter.desc = Math.max(...descTypes.map(d => d.id), 0) + 1;

                    renderAll();
                    updateAllStats();
                    renderOutline();
                    updateSelects();
                    adjustCanvasSize();
                    showToast('Loaded');
                } catch (err) {
                    showToast('Could not read file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ============ UNDO/REDO SYSTEM ============
        function saveUndoState(action) {
            const state = {
                action,
                nodes: JSON.parse(JSON.stringify(nodes)),
                connections: JSON.parse(JSON.stringify(connections)),
                selectedNode,
                timestamp: Date.now()
            };
            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_STACK) {
                undoStack.shift();
            }
            redoStack = []; // Clear redo stack on new action
        }

        function undoAction() {
            if (undoStack.length === 0) {
                showToast('Nothing to undo');
                return;
            }

            // Save current state to redo stack
            const currentState = {
                action: 'redo',
                nodes: JSON.parse(JSON.stringify(nodes)),
                connections: JSON.parse(JSON.stringify(connections)),
                selectedNode,
                timestamp: Date.now()
            };
            redoStack.push(currentState);

            // Restore previous state
            const prevState = undoStack.pop();
            nodes = prevState.nodes;
            connections = prevState.connections;
            selectedNode = prevState.selectedNode;

            // Re-render everything
            document.querySelectorAll('.node').forEach(n => n.remove());
            nodes.forEach(n => renderNode(n));
            renderConnections();
            renderOutline();
            updateAllStats();

            showToast('Undo: ' + prevState.action);
        }

        function redoAction() {
            if (redoStack.length === 0) {
                showToast('Nothing to redo');
                return;
            }

            // Save current state to undo stack
            const currentState = {
                action: 'undo',
                nodes: JSON.parse(JSON.stringify(nodes)),
                connections: JSON.parse(JSON.stringify(connections)),
                selectedNode,
                timestamp: Date.now()
            };
            undoStack.push(currentState);

            // Restore redo state
            const redoState = redoStack.pop();
            nodes = redoState.nodes;
            connections = redoState.connections;
            selectedNode = redoState.selectedNode;

            // Re-render everything
            document.querySelectorAll('.node').forEach(n => n.remove());
            nodes.forEach(n => renderNode(n));
            renderConnections();
            renderOutline();
            updateAllStats();

            showToast('Redo');
        }

        // ============ TRASH SYSTEM ============
        function openTrashModal() {
            const trashModal = document.getElementById('trashModal');
            if (!trashModal) {
                createTrashModal();
            }
            renderTrashList();
            document.getElementById('trashModal').classList.add('active');
        }

        function createTrashModal() {
            const modal = document.createElement('div');
            modal.id = 'trashModal';
            modal.className = 'modal manager-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>üóëÔ∏è Trash</h3>
                        <button class="modal-close" onclick="closeModal('trashModal')">√ó</button>
                    </div>
                    <div class="modal-body">
                        <div id="trashList" class="manager-list"></div>
                        <div id="trashEmpty" class="trash-empty-state">
                            <div class="empty-icon">üóëÔ∏è</div>
                            <div class="empty-title">Trash is Empty</div>
                            <div class="empty-desc">Deleted items will appear here</div>
                        </div>
                    </div>
                    <div class="modal-footer-pro">
                        <button class="btn-danger-outline" onclick="emptyTrash()">
                            <span>‚ö†Ô∏è</span> Empty Trash
                        </button>
                        <button class="btn-primary-pro" onclick="closeModal('trashModal')">Done</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function renderTrashList() {
            const list = document.getElementById('trashList');
            const empty = document.getElementById('trashEmpty');

            if (trash.length === 0) {
                list.style.display = 'none';
                empty.style.display = 'flex';
                return;
            }

            list.style.display = 'block';
            empty.style.display = 'none';

            list.innerHTML = trash.map((item, index) => {
                const deletedDate = new Date(item.deletedAt).toLocaleString();
                return `
                    <div class="manager-item">
                        <div class="item-icon">üìÑ</div>
                        <div class="item-info">
                            <div class="item-name">${item.title}</div>
                            <div class="item-desc">${deletedDate}</div>
                        </div>
                        <div class="item-actions">
                            <button onclick="restoreFromTrash(${index})" title="Restore" class="restore-btn">‚Ü©</button>
                            <button onclick="permanentDelete(${index})" title="Delete Forever" class="delete-btn">‚úï</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function restoreFromTrash(index) {
            if (index < 0 || index >= trash.length) return;

            const item = trash[index];

            // Remove from trash
            trash.splice(index, 1);

            // Restore node
            const restoredNode = { ...item };
            delete restoredNode.deletedAt;
            delete restoredNode.deletedConnections;

            nodes.push(restoredNode);
            renderNode(restoredNode);

            // Restore connections if possible
            if (item.deletedConnections) {
                item.deletedConnections.forEach(conn => {
                    const fromExists = nodes.some(n => n.id === conn.from);
                    const toExists = nodes.some(n => n.id === conn.to);
                    if (fromExists && toExists) {
                        connections.push(conn);
                    }
                });
                renderConnections();
            }

            renderOutline();
            updateAllStats();
            renderTrashList();
            showToast('Node restored');
        }

        function permanentDelete(index) {
            if (!confirm('Permanently delete? This cannot be undone.')) return;
            trash.splice(index, 1);
            renderTrashList();
            showToast('Permanently deleted');
        }

        function emptyTrash() {
            if (trash.length === 0) {
                showToast('Trash is already empty');
                return;
            }
            if (!confirm('Empty trash? This cannot be undone.')) return;
            trash = [];
            renderTrashList();
            showToast('Trash emptied');
        }

        // ============ PRINT FUNCTION ============
        function printProject() {
            openPrintModal();
        }
        
        function openPrintModal() {
            // Create print modal if not exists
            let modal = document.getElementById('printModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'printModal';
                modal.className = 'modal';
                modal.style.zIndex = '4000';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width:900px; max-height:90vh; background:#1e1e2e; overflow:hidden; display:flex; flex-direction:column;">
                        <div class="modal-header" style="background:#2d2d3d; padding:16px 20px; border-bottom:1px solid #444;">
                            <h2 style="margin:0; color:#fff; font-size:18px;">üñ®Ô∏è PDF √áƒ±ktƒ± Ayarlarƒ±</h2>
                            <button class="close-btn" onclick="closeModal('printModal')" style="background:#555; color:#fff;">√ó</button>
                        </div>
                        <div style="display:flex; flex:1; overflow:hidden;">
                            <!-- Options Panel -->
                            <div style="width:280px; background:#252535; padding:20px; overflow-y:auto; border-right:1px solid #444;">
                                <div style="margin-bottom:20px;">
                                    <label style="color:#aaa; font-size:12px; display:block; margin-bottom:8px;">üìÑ SAYFA BOYUTU</label>
                                    <select id="printPageSize" style="width:100%; padding:10px; background:#1e1e2e; border:1px solid #555; color:#fff; border-radius:6px;">
                                        <option value="a4">A4 (210 √ó 297 mm)</option>
                                        <option value="letter">Letter (8.5 √ó 11 in)</option>
                                        <option value="a3">A3 (297 √ó 420 mm)</option>
                                        <option value="custom">√ñzel Boyut</option>
                                    </select>
                                </div>
                                <div style="margin-bottom:20px;">
                                    <label style="color:#aaa; font-size:12px; display:block; margin-bottom:8px;">üîÑ Y√ñNLENDIRME</label>
                                    <div style="display:flex; gap:10px;">
                                        <button id="printOrientPortrait" onclick="setPrintOrientation('portrait')" style="flex:1; padding:12px; background:#3b82f6; border:none; color:#fff; border-radius:6px; cursor:pointer;">üìÑ Dikey</button>
                                        <button id="printOrientLandscape" onclick="setPrintOrientation('landscape')" style="flex:1; padding:12px; background:#333; border:1px solid #555; color:#fff; border-radius:6px; cursor:pointer;">üìÉ Yatay</button>
                                    </div>
                                </div>
                                <div style="margin-bottom:20px;">
                                    <label style="color:#aaa; font-size:12px; display:block; margin-bottom:8px;">üìè KENAR BO≈ûLUKLARI (mm)</label>
                                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                                        <input type="number" id="printMarginTop" value="20" placeholder="√úst" style="padding:8px; background:#1e1e2e; border:1px solid #555; color:#fff; border-radius:4px;">
                                        <input type="number" id="printMarginRight" value="20" placeholder="Saƒü" style="padding:8px; background:#1e1e2e; border:1px solid #555; color:#fff; border-radius:4px;">
                                        <input type="number" id="printMarginBottom" value="20" placeholder="Alt" style="padding:8px; background:#1e1e2e; border:1px solid #555; color:#fff; border-radius:4px;">
                                        <input type="number" id="printMarginLeft" value="20" placeholder="Sol" style="padding:8px; background:#1e1e2e; border:1px solid #555; color:#fff; border-radius:4px;">
                                    </div>
                                </div>
                                <div style="margin-bottom:20px;">
                                    <label style="color:#aaa; font-size:12px; display:block; margin-bottom:8px;">üé® ƒ∞√áERƒ∞K SE√áENEKLERƒ∞</label>
                                    <div style="display:flex; flex-direction:column; gap:8px;">
                                        <label style="display:flex; align-items:center; gap:8px; color:#fff; cursor:pointer;">
                                            <input type="checkbox" id="printIncludeConnections" checked style="width:18px; height:18px;">
                                            Baƒülantƒ±larƒ± g√∂ster
                                        </label>
                                        <label style="display:flex; align-items:center; gap:8px; color:#fff; cursor:pointer;">
                                            <input type="checkbox" id="printIncludeImages" checked style="width:18px; height:18px;">
                                            Resimleri dahil et
                                        </label>
                                        <label style="display:flex; align-items:center; gap:8px; color:#fff; cursor:pointer;">
                                            <input type="checkbox" id="printDarkMode" style="width:18px; height:18px;">
                                            Koyu tema
                                        </label>
                                    </div>
                                </div>
                                <div style="margin-bottom:20px;">
                                    <label style="color:#aaa; font-size:12px; display:block; margin-bottom:8px;">üîç √ñL√áEK</label>
                                    <input type="range" id="printScale" min="50" max="150" value="100" style="width:100%;">
                                    <div style="display:flex; justify-content:space-between; color:#888; font-size:11px;">
                                        <span>50%</span>
                                        <span id="printScaleValue">100%</span>
                                        <span>150%</span>
                                    </div>
                                </div>
                            </div>
                            <!-- Preview Panel -->
                            <div style="flex:1; background:#333; padding:20px; overflow:auto; display:flex; flex-direction:column;">
                                <div style="color:#aaa; font-size:12px; margin-bottom:10px;">üëÅÔ∏è √ñNƒ∞ZLEME</div>
                                <div id="printPreview" style="flex:1; background:#fff; border-radius:8px; overflow:hidden; box-shadow:0 4px 20px rgba(0,0,0,0.3);">
                                    <!-- Preview will be rendered here -->
                                </div>
                            </div>
                        </div>
                        <div style="padding:16px 20px; background:#2d2d3d; border-top:1px solid #444; display:flex; justify-content:flex-end; gap:12px;">
                            <button onclick="closeModal('printModal')" style="padding:12px 24px; background:#555; border:none; color:#fff; border-radius:8px; cursor:pointer;">ƒ∞ptal</button>
                            <button onclick="exportCanvasToPDF()" style="padding:12px 24px; background:#3b82f6; border:none; color:#fff; border-radius:8px; cursor:pointer; font-weight:600;">üì• PDF ƒ∞ndir</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                
                // Add scale slider event
                document.getElementById('printScale').addEventListener('input', (e) => {
                    document.getElementById('printScaleValue').textContent = e.target.value + '%';
                    updatePrintPreview();
                });
            }
            
            modal.classList.add('active');
            updatePrintPreview();
        }
        
        let printOrientation = 'portrait';
        
        function setPrintOrientation(orient) {
            printOrientation = orient;
            document.getElementById('printOrientPortrait').style.background = orient === 'portrait' ? '#3b82f6' : '#333';
            document.getElementById('printOrientPortrait').style.border = orient === 'portrait' ? 'none' : '1px solid #555';
            document.getElementById('printOrientLandscape').style.background = orient === 'landscape' ? '#3b82f6' : '#333';
            document.getElementById('printOrientLandscape').style.border = orient === 'landscape' ? 'none' : '1px solid #555';
            updatePrintPreview();
        }
        
        function updatePrintPreview() {
            const preview = document.getElementById('printPreview');
            if (!preview) return;
            
            const scale = (document.getElementById('printScale')?.value || 100) / 100;
            const darkMode = document.getElementById('printDarkMode')?.checked;
            const bgColor = darkMode ? '#1e1e2e' : '#fff';
            const textColor = darkMode ? '#fff' : '#333';
            
            // Separate regular nodes and special nodes
            const regularNodes = nodes.filter(n => !n.nodeType || !['folder', 'sticky', 'image'].includes(n.nodeType));
            const specialNodesList = nodes.filter(n => n.nodeType && ['folder', 'sticky', 'image'].includes(n.nodeType));
            
            // Generate node previews
            let nodePreviewsHtml = '';
            regularNodes.slice(0, 8).forEach(node => {
                const color = node.color || '#3b82f6';
                const isTask = node.isTaskNode || TASK_NODE_TYPES[node.type];
                const icon = isTask ? 'üìã' : 'üìÑ';
                nodePreviewsHtml += `
                    <div style="background:${color}; color:#fff; padding:6px 10px; border-radius:6px; font-size:9px; margin:3px; display:inline-block; max-width:100px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                        ${icon} ${node.title || 'Untitled'}
                    </div>
                `;
            });
            
            // Add special nodes
            specialNodesList.slice(0, 4).forEach(node => {
                const icon = node.nodeType === 'folder' ? 'üìÅ' : node.nodeType === 'sticky' ? 'üìù' : 'üñºÔ∏è';
                const color = node.nodeType === 'folder' ? '#e67e22' : node.nodeType === 'sticky' ? '#f1c40f' : '#e91e63';
                nodePreviewsHtml += `
                    <div style="background:${color}; color:#fff; padding:6px 10px; border-radius:6px; font-size:9px; margin:3px; display:inline-block;">
                        ${icon} ${node.title || node.nodeType}
                    </div>
                `;
            });
            
            // Show more indicator
            const totalShown = Math.min(regularNodes.length, 8) + Math.min(specialNodesList.length, 4);
            const remaining = nodes.length - totalShown;
            if (remaining > 0) {
                nodePreviewsHtml += `<div style="color:#888; font-size:9px; margin:3px; display:inline-block;">+${remaining} daha...</div>`;
            }
            
            // If no nodes, show message
            if (nodes.length === 0) {
                nodePreviewsHtml = `<div style="color:#888; font-size:10px; padding:20px; text-align:center;">Hen√ºz node yok</div>`;
            }
            
            preview.innerHTML = `
                <div style="transform:scale(${scale}); transform-origin:top left; padding:15px; background:${bgColor}; min-height:100%; color:${textColor};">
                    <div style="font-size:11px; text-align:center; padding:8px; border-bottom:1px solid ${darkMode ? '#444' : '#ddd'}; margin-bottom:10px;">
                        <strong>${currentProjectName || 'Untitled'}</strong><br>
                        <span style="color:#888; font-size:9px;">${nodes.length} nodes ‚Ä¢ ${connections.length} connections</span>
                    </div>
                    <div style="display:flex; flex-wrap:wrap; gap:3px; justify-content:center; padding:10px;">
                        ${nodePreviewsHtml}
                    </div>
                </div>
            `;
        }
        
        function exportCanvasToPDF() {
            showToast('üì• PDF olu≈üturuluyor...');
            
            const includeConnections = document.getElementById('printIncludeConnections')?.checked ?? true;
            const darkMode = document.getElementById('printDarkMode')?.checked ?? false;
            const scale = (document.getElementById('printScale')?.value || 100) / 100;
            
            // Get all node styles from the document
            let stylesHtml = '';
            document.querySelectorAll('style').forEach(style => {
                stylesHtml += style.outerHTML;
            });
            
            // Clone nodes with computed positions
            let nodesHtml = '';
            document.querySelectorAll('#canvas .node, #canvas .task-node-card, #canvas .folder-node, #canvas .sticky-node, #canvas .image-node').forEach(node => {
                const clone = node.cloneNode(true);
                // Make positions relative for print layout
                clone.style.position = 'relative';
                clone.style.left = 'auto';
                clone.style.top = 'auto';
                clone.style.margin = '10px';
                clone.style.display = 'inline-block';
                clone.style.verticalAlign = 'top';
                nodesHtml += clone.outerHTML;
            });
            
            // Create hidden iframe for printing (avoids popup blocker)
            let printFrame = document.getElementById('printFrame');
            if (!printFrame) {
                printFrame = document.createElement('iframe');
                printFrame.id = 'printFrame';
                printFrame.style.cssText = 'position:absolute;left:-9999px;width:1px;height:1px;';
                document.body.appendChild(printFrame);
            }
            
            const bgColor = darkMode ? '#1e1e2e' : '#fff';
            const textColor = darkMode ? '#fff' : '#333';
            
            const printContent = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${currentProjectName || 'Project'} - PDF Export</title>
                    ${stylesHtml}
                    <style>
                        * { box-sizing: border-box; }
                        body { 
                            margin: 0; 
                            padding: 20mm;
                            background: ${bgColor} !important; 
                            color: ${textColor} !important;
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        }
                        .print-header {
                            text-align: center;
                            padding-bottom: 20px;
                            border-bottom: 2px solid ${darkMode ? '#444' : '#eee'};
                            margin-bottom: 30px;
                        }
                        .print-header h1 { margin: 0; font-size: 24px; color: ${textColor}; }
                        .print-header p { margin: 5px 0 0; color: #888; }
                        .nodes-container {
                            display: flex;
                            flex-wrap: wrap;
                            gap: 15px;
                            justify-content: flex-start;
                            transform: scale(${scale});
                            transform-origin: top left;
                        }
                        .node, .task-node-card, .folder-node, .sticky-node, .image-node {
                            break-inside: avoid;
                            page-break-inside: avoid;
                        }
                        @media print {
                            body { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
                            .node, .task-node-card, .folder-node, .sticky-node, .image-node {
                                box-shadow: none !important;
                            }
                        }
                    </style>
                </head>
                <body>
                    <div class="print-header">
                        <h1>${currentProjectName || 'Untitled Project'}</h1>
                        <p>${nodes.length} nodes ‚Ä¢ ${connections.length} connections ‚Ä¢ ${new Date().toLocaleDateString('tr-TR')}</p>
                    </div>
                    <div class="nodes-container">
                        ${nodesHtml}
                    </div>
                </body>
                </html>
            `;
            
            const frameDoc = printFrame.contentWindow || printFrame.contentDocument;
            const doc = frameDoc.document || frameDoc;
            doc.open();
            doc.write(printContent);
            doc.close();
            
            // Wait for content to load then print
            setTimeout(() => {
                printFrame.contentWindow.focus();
                printFrame.contentWindow.print();
                closeModal('printModal');
            }, 500);
        }

        // ============ CLEAR STORAGE ============
        function clearStorage() {
            // Calculate current storage usage
            let total = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    total += localStorage[key].length * 2; // UTF-16 = 2 bytes per char
                }
            }
            const usedMB = (total / 1024 / 1024).toFixed(2);

            const projects = JSON.parse(localStorage.getItem('offlineProjects')) || [];
            const projectCount = projects.length;

            if (!confirm(`‚ö†Ô∏è Clear All Storage?\n\nCurrently using: ${usedMB} MB\nProjects stored: ${projectCount}\n\nThis will delete ALL saved projects from browser storage.\nMake sure to export important projects first with File ‚Üí Save!\n\nContinue?`)) {
                return;
            }

            // Double confirm for safety
            if (!confirm('üö® FINAL WARNING!\n\nAre you absolutely sure?\nThis action cannot be undone!')) {
                return;
            }

            // Clear all localStorage
            localStorage.clear();

            // Reset current state
            nodes = [];
            connections = [];
            trash = [];
            currentProjectId = null;
            currentProjectName = 'Untitled';
            currentFileHandle = null;
            lastSavedURL = null;
            selectedNode = null;
            window.projectMetadata = {};

            // Clear canvas DOM elements
            const canvas = document.getElementById('canvas');
            const nodeElements = canvas.querySelectorAll('.node, .task-node-card, .folder-node, .sticky-node, .image-node');
            nodeElements.forEach(el => el.remove());
            
            // Clear connections SVG
            const connectionsEl = document.getElementById('connections');
            if (connectionsEl) {
                connectionsEl.innerHTML = '';
            }
            
            // Clear outline
            const outlineTree = document.getElementById('outlineTree');
            if (outlineTree) {
                outlineTree.innerHTML = '<div style="color:#888; text-align:center; padding:20px;">No items yet</div>';
            }
            
            // Clear stats panel content
            const statsContent = document.getElementById('statsContent');
            if (statsContent) {
                statsContent.innerHTML = '<div style="color:#888; text-align:center; padding:40px;">No data</div>';
            }

            // Reset UI
            document.getElementById('currentFileName').textContent = 'No file opened';
            hidePropertiesPanel();
            
            try {
            loadProjectsSideList();
            } catch(e) {}

            showToast('üóëÔ∏è T√ºm veriler temizlendi! ' + usedMB + ' MB bo≈üaltƒ±ldƒ±.');
        }

        // ============ UI HELPERS ============
        function showMenu(id, x, y) {
            hideAllMenus();
            const menu = document.getElementById(id);
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');
        }

        function showAddMenu(e) {
            if (e) e.stopPropagation();
            hideAllMenus();

            // Close any open menu dropdowns first
            document.querySelectorAll('.menu-dropdown').forEach(d => {
                d.style.display = '';
                d.style.opacity = '';
                d.style.visibility = '';
            });

            const menu = document.getElementById('addMenu');

            // Position menu - use event coordinates or center of screen
            let x = (e && e.clientX) ? e.clientX : window.innerWidth / 2 - 120;
            let y = (e && e.clientY) ? e.clientY : 100;

            // Make sure menu is visible
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');

            // Adjust if off-screen
            setTimeout(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - rect.width - 20) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = (window.innerHeight - rect.height - 20) + 'px';
                }
            }, 10);
        }

        function showAddTaskMenu(e) {
            if (e) e.stopPropagation();
            hideAllMenus();

            // Populate task type list dynamically
            const taskTypeList = document.getElementById('taskTypeList');
            const allTypes = getAllTaskTypes();

            let html = '';

            // Default types first
            Object.keys(TASK_NODE_TYPES).forEach(typeId => {
                const type = TASK_NODE_TYPES[typeId];
                html += `
                    <div class="context-menu-item" onclick="addTaskNode('${typeId}'); hideAllMenus();">
                        <span class="item-icon">${type.icon}</span> ${type.name}
                    </div>
                `;
            });

            // Custom types
            if (CUSTOM_TASK_TYPES.length > 0) {
                html += '<div class="context-menu-divider"></div>';
                html += '<div class="context-menu-header">üé® √ñzel Tipler</div>';
                CUSTOM_TASK_TYPES.forEach(type => {
                    html += `
                        <div class="context-menu-item" onclick="addTaskNode('${type.id}'); hideAllMenus();">
                            <span class="item-icon">${type.icon}</span> ${type.name}
                            <span style="width:12px; height:12px; background:${type.color}; border-radius:50%; margin-left:auto;"></span>
                        </div>
                    `;
                });
            }

            taskTypeList.innerHTML = html;

            const menu = document.getElementById('addTaskMenu');

            // Position menu
            let x = (e && e.clientX) ? e.clientX : window.innerWidth / 2 - 120;
            let y = (e && e.clientY) ? e.clientY : 100;

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');

            // Adjust if off-screen
            setTimeout(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - rect.width - 20) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = (window.innerHeight - rect.height - 20) + 'px';
                }
            }, 10);
        }

        function showAddSpecialMenu(e) {
            if (e) e.stopPropagation();
            hideAllMenus();

            // Create special node menu if it doesn't exist
            let menu = document.getElementById('addSpecialMenu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'addSpecialMenu';
                menu.className = 'context-menu';
                menu.innerHTML = `
                    <div class="context-menu-header">‚ú® √ñzel Node Ekle</div>
                    <div class="context-menu-item" onclick="addSpecialNode('folder'); hideAllMenus();">
                        <span class="item-icon">üìÅ</span> Folder (Klas√∂r)
                        <span style="font-size:10px; color:var(--text-tertiary); margin-left:auto;">Dosya konteyneri</span>
                    </div>
                    <div class="context-menu-item" onclick="addSpecialNode('sticky'); hideAllMenus();">
                        <span class="item-icon">üìù</span> Sticky Note
                        <span style="font-size:10px; color:var(--text-tertiary); margin-left:auto;">Yapƒ±≈ükan not</span>
                    </div>
                    <div class="context-menu-item" onclick="addSpecialNode('image'); hideAllMenus();">
                        <span class="item-icon">üñºÔ∏è</span> Image (Resim)
                        <span style="font-size:10px; color:var(--text-tertiary); margin-left:auto;">G√∂rsel node</span>
                    </div>
                    <div class="context-menu-divider"></div>
                    <div class="context-menu-header">üé® Sticky Note Renkleri</div>
                    <div style="display:flex; gap:6px; padding:8px 12px; flex-wrap:wrap;">
                        <div onclick="addSpecialNode('sticky', 'yellow'); hideAllMenus();" style="width:24px;height:24px;background:#fde047;border-radius:4px;cursor:pointer;border:2px solid transparent;" title="Sarƒ±"></div>
                        <div onclick="addSpecialNode('sticky', 'red'); hideAllMenus();" style="width:24px;height:24px;background:#f87171;border-radius:4px;cursor:pointer;border:2px solid transparent;" title="Kƒ±rmƒ±zƒ± - Important"></div>
                        <div onclick="addSpecialNode('sticky', 'green'); hideAllMenus();" style="width:24px;height:24px;background:#4ade80;border-radius:4px;cursor:pointer;border:2px solid transparent;" title="Ye≈üil - Done/Idea"></div>
                        <div onclick="addSpecialNode('sticky', 'blue'); hideAllMenus();" style="width:24px;height:24px;background:#60a5fa;border-radius:4px;cursor:pointer;border:2px solid transparent;" title="Mavi - Info"></div>
                        <div onclick="addSpecialNode('sticky', 'purple'); hideAllMenus();" style="width:24px;height:24px;background:#a78bfa;border-radius:4px;cursor:pointer;border:2px solid transparent;" title="Mor - Creative"></div>
                        <div onclick="addSpecialNode('sticky', 'orange'); hideAllMenus();" style="width:24px;height:24px;background:#fb923c;border-radius:4px;cursor:pointer;border:2px solid transparent;" title="Turuncu - Don't Forget"></div>
                        <div onclick="addSpecialNode('sticky', 'pink'); hideAllMenus();" style="width:24px;height:24px;background:#f472b6;border-radius:4px;cursor:pointer;border:2px solid transparent;" title="Pembe"></div>
                    </div>
                `;
                document.body.appendChild(menu);
            }

            // Position menu
            let x = (e && e.clientX) ? e.clientX : window.innerWidth / 2 - 120;
            let y = (e && e.clientY) ? e.clientY : 100;

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');

            // Adjust if off-screen
            setTimeout(() => {
                const rect = menu.getBoundingClientRect();
                if (rect.right > window.innerWidth) {
                    menu.style.left = (window.innerWidth - rect.width - 20) + 'px';
                }
                if (rect.bottom > window.innerHeight) {
                    menu.style.top = (window.innerHeight - rect.height - 20) + 'px';
                }
            }, 10);
        }

        function addSpecialNode(type, color = null) {
            saveUndoState('add special node');

            const container = document.getElementById('canvasContainer');
            const containerRect = container.getBoundingClientRect();
            const scrollLeft = container.scrollLeft;
            const scrollTop = container.scrollTop;

            // Calculate center position
            const centerX = (scrollLeft + containerRect.width / 2 - 100) / zoom;
            const centerY = (scrollTop + containerRect.height / 2 - 60) / zoom;

            const newId = 'special_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

            const node = {
                id: newId,
                type: type,
                title: type === 'folder' ? 'Yeni Klas√∂r' : (type === 'sticky' ? 'Yeni Not' : 'Yeni Resim'),
                x: centerX + Math.random() * 50 - 25,
                y: centerY + Math.random() * 50 - 25,
                summary: '',
                createdAt: new Date().toISOString()
            };

            // Type-specific properties
            if (type === 'folder') {
                node.folderFiles = [];
            } else if (type === 'sticky') {
                node.stickyColor = color || 'yellow';
                node.stickyTag = 'none';
                node.stickyContent = '';
            } else if (type === 'image') {
                node.imageData = null;
                node.imageSrc = null;
                node.imageCaption = '';
            }

            nodes.push(node);
            renderNode(node);
            selectNode(node.id);
            autoSave();

            const typeNames = { folder: 'üìÅ Klas√∂r', sticky: 'üìù Sticky Note', image: 'üñºÔ∏è Resim' };
            showToast(`${typeNames[type] || 'Node'} eklendi`);
        }

        function hideAllMenus() {
            document.querySelectorAll('.context-menu').forEach(m => m.classList.remove('active'));
        }

        function openModal(id) {
            const modal = document.getElementById(id);
            if (modal) {
                modal.classList.add('active');
                modal.style.display = 'flex';
            }
        }

        function closeModal(id) {
            const modal = document.getElementById(id);
            if (modal) {
                modal.classList.remove('active');
                modal.style.display = 'none';
                // Reset editor text area mode classes when closing editor
                if (id === 'editorModal') {
                    modal.classList.remove('editor-light-mode', 'editor-dark-mode');
                    modal.classList.remove('focus-mode-active', 'focus-light', 'focus-dark');
                }
            }
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2000);
        }

        document.addEventListener('click', e => {
            if (!e.target.closest('.context-menu') && !e.target.closest('button')) {
                hideAllMenus();
            }
        });

        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.closest('[contenteditable]')) return;
            if (e.key === 'Delete') deleteSelected();
            else if (e.key === 'Escape') {
                hideAllMenus();
                document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
                isConnecting = false;
            }
            else if (e.ctrlKey && e.key === 's') { e.preventDefault(); exportData(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undoAction(); }
            else if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'z') { e.preventDefault(); redoAction(); }
            else if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redoAction(); }
        });

        // ============ PANEL RESIZE ============
        let isResizingPanel = false;

        document.getElementById('panelResizeHandle').addEventListener('mousedown', function(e) {
            isResizingPanel = true;
            document.body.style.cursor = 'ew-resize';
            document.body.style.userSelect = 'none';
            this.classList.add('dragging');
        });

        document.addEventListener('mousemove', function(e) {
            if (!isResizingPanel) return;
            const panel = document.getElementById('sidePanel');
            const newWidth = e.clientX;
            if (newWidth >= 200 && newWidth <= 500) {
                panel.style.width = newWidth + 'px';
            }
        });

        document.addEventListener('mouseup', function() {
            if (isResizingPanel) {
                isResizingPanel = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                document.getElementById('panelResizeHandle').classList.remove('dragging');
            }
        });

        // ============ SNAPSHOTS (Scrivener style - each section has its own snapshots) ============

        // Editor snapshot panel toggle
        function toggleEditorSnapshotPanel() {
            const panel = document.getElementById('editorSnapshotPanel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                renderEditorSnapshots();
            }
        }

        // Get active section's snapshots
        function getNodeSnapshots(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            return (node && node.snapshots) ? node.snapshots : [];
        }

        // Take snapshot from editor - ONLY save active section text
        function takeEditorSnapshot() {
            if (!editingNodeId) {
                showToast('Open a section first');
                return;
            }

            const editor = document.getElementById('fullTextEditor');
            const node = nodes.find(n => n.id === editingNodeId);

            if (!node || !editor) {
                showToast('Section not found');
                return;
            }

            // Save current content to node
            node.fullText = editor.innerHTML;

            // Create node's snapshot array (if missing)
            if (!node.snapshots) {
                node.snapshots = [];
            }

            const nameInput = document.getElementById('editorSnapshotName');
            const customName = nameInput ? nameInput.value.trim() : '';
            const name = customName || new Date().toLocaleString('en-US');

            // Calculate word count
            const plainText = (node.fullText || '').replace(/<[^>]*>/g, '');
            const wordCount = plainText.trim() ? plainText.trim().split(/\s+/).length : 0;

            // Create snapshot - ONLY this section's text
            const snapshot = {
                id: Date.now(),
                name: name,
                date: new Date().toISOString(),
                text: node.fullText, // Sadece metin
                wordCount: wordCount
            };

            // Add to beginning
            node.snapshots.unshift(snapshot);

            // Max 20 snapshot tut
            if (node.snapshots.length > 20) {
                node.snapshots = node.snapshots.slice(0, 20);
            }

            if (nameInput) nameInput.value = '';
            renderEditorSnapshots();
            showToast(`üì∏ "${node.title}" snapshot taken`);
        }

        // Restore snapshot - ONLY replace text
        function restoreNodeSnapshot(snapshotId) {
            if (!editingNodeId) return;

            const node = nodes.find(n => n.id === editingNodeId);
            if (!node || !node.snapshots) return;

            const snapshot = node.snapshots.find(s => s.id === snapshotId);
            if (!snapshot) return;

            if (!confirm(`"${snapshot.name}" Are you sure you want to restore this snapshot?\n\nCurrent text will be lost!`)) {
                return;
            }

            // Auto-save current text as snapshot
            const editor = document.getElementById('fullTextEditor');
            const currentText = editor.innerHTML;
            const plainText = currentText.replace(/<[^>]*>/g, '');
            const wordCount = plainText.trim() ? plainText.trim().split(/\s+/).length : 0;

            node.snapshots.unshift({
                id: Date.now(),
                name: `Auto Backup`,
                date: new Date().toISOString(),
                text: currentText,
                wordCount: wordCount,
                isBackup: true
            });

            // Restore snapshot
            node.fullText = snapshot.text;
            editor.innerHTML = snapshot.text;

            renderEditorSnapshots();
            updateEditorStats();
            showToast(`‚úÖ "${snapshot.name}" restored`);
        }

        // Delete snapshot
        function deleteNodeSnapshot(snapshotId) {
            if (!editingNodeId) return;

            const node = nodes.find(n => n.id === editingNodeId);
            if (!node || !node.snapshots) return;

            const snapshot = node.snapshots.find(s => s.id === snapshotId);
            if (!snapshot) return;

            if (!confirm(`"${snapshot.name}" Are you sure you want to delete this snapshot?`)) {
                return;
            }

            node.snapshots = node.snapshots.filter(s => s.id !== snapshotId);
            renderEditorSnapshots();
            showToast('üóëÔ∏è Snapshot deleted');
        }

        // Render snapshot list in editor
        function renderEditorSnapshots() {
            const list = document.getElementById('editorSnapshotList');
            if (!list) return;

            const nodeSnapshots = getNodeSnapshots(editingNodeId);

            if (nodeSnapshots.length === 0) {
                list.innerHTML = '<div style="text-align:center; color:#888; padding:15px; font-size:0.85em;">No snapshots for this section yet</div>';
                return;
            }

            list.innerHTML = nodeSnapshots.map(s => {
                const date = new Date(s.date);
                const dateStr = date.toLocaleDateString('en-US');
                const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                const backupBadge = s.isBackup ? ' <span style="background:#FF9800; color:white; padding:1px 4px; border-radius:3px; font-size:0.7em;">Backup</span>' : '';

                return `
                    <div class="editor-snapshot-item">
                        <div class="snap-info">
                            <div class="snap-name">${s.name}${backupBadge}</div>
                            <div class="snap-date">${dateStr} ${timeStr} ‚Ä¢ ${s.wordCount || 0} words</div>
                        </div>
                        <div class="snap-actions">
                            <button class="snap-restore" onclick="restoreNodeSnapshot(${s.id})" title="Restore">‚Ü©Ô∏è</button>
                            <button class="snap-delete" onclick="deleteNodeSnapshot(${s.id})" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // ============ AUTO-SAVE ============
        let autoSaveInterval = null;
        let lastAutoSaveTime = null;

        function startAutoSave() {
            // Get interval from settings or default 5 minutes
            const interval = appSettings.autoSaveInterval || 300000;
            if (interval > 0) {
                autoSaveInterval = setInterval(() => {
                    performAutoSave();
                }, interval);
                console.log(`Start auto-saveed (every  ${interval/60000} minutes)`);
            }
        }

        async function performAutoSave() {
            const indicator = document.getElementById('autosaveIndicator');
            const text = document.getElementById('autosaveText');

            // Show saving indicator
            indicator.className = 'autosave-indicator show saving';
            text.textContent = 'Saving...';

            try {
                // Offline mode: save to localStorage session
                const sessionData = {
                    nodes, connections, povList, descTypes, revisionLabels,
                    projectName: currentProjectName,
                    projectMetadata: window.projectMetadata || {},
                    TASK_NODE_TYPES: TASK_NODE_TYPES,
                    CUSTOM_TASK_TYPES: CUSTOM_TASK_TYPES,
                    TASK_STATUSES: TASK_STATUSES
                };
                localStorage.setItem('writerLastSession', JSON.stringify(sessionData));
                text.textContent = 'Auto-saved';

                lastAutoSaveTime = new Date();

                // Show saved indicator
                indicator.className = 'autosave-indicator show saved';

                // Hide after 2 seconds
                setTimeout(() => {
                    indicator.className = 'autosave-indicator';
                }, 2000);

                console.log('Auto-save completed:', lastAutoSaveTime.toLocaleTimeString('en-US'));
            } catch(e) {
                console.error('Auto-save error:', e);
                // Fallback to localStorage on cloud error
                try {
                    saveToLocalStorage();
                    text.textContent = 'Local Saved';
                    indicator.className = 'autosave-indicator show saved';
                    setTimeout(() => {
                        indicator.className = 'autosave-indicator';
                    }, 2000);
                } catch(e2) {
                    indicator.className = 'autosave-indicator';
                }
            }
        }

        // ============ GLOBAL SEARCH ============
        let globalSearchFilter = 'all';
        let globalSearchMode = 'contains'; // 'contains' or 'exact'

        function setSearchMode(mode) {
            globalSearchMode = mode;
            document.querySelectorAll('.search-mode-btn').forEach(btn => {
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                    btn.style.background = '#e94560';
                    btn.style.borderColor = '#e94560';
                    btn.style.color = 'white';
                } else {
                    btn.classList.remove('active');
                    btn.style.background = 'transparent';
                    btn.style.borderColor = '#555';
                    btn.style.color = '#aaa';
                }
            });
            performGlobalSearch();
        }

        function openGlobalSearch() {
            document.getElementById('globalSearchModal').classList.add('active');
            document.getElementById('globalSearchInput').value = '';
            document.getElementById('globalSearchInput').focus();
            document.getElementById('globalSearchResults').innerHTML = '<div style="text-align:center; color:#666; padding:30px;">Start typing to search...</div>';
        }

        function closeGlobalSearch() {
            document.getElementById('globalSearchModal').classList.remove('active');
        }

        function setSearchFilter(filter) {
            globalSearchFilter = filter;
            document.querySelectorAll('.search-filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            performGlobalSearch();
        }

        function performGlobalSearch() {
            const query = document.getElementById('globalSearchInput').value.trim();
            const queryLower = query.toLowerCase();
            const resultsEl = document.getElementById('globalSearchResults');
            const isExact = globalSearchMode === 'exact';

            if (!query || query.length < 2) {
                resultsEl.innerHTML = '<div style="text-align:center; color:#666; padding:30px;">Enter at least 2 characters...</div>';
                return;
            }

            // Match function based on mode
            const matches = (text, search) => {
                if (!text) return false;
                if (isExact) {
                    // Exact match: word boundaries
                    const regex = new RegExp(`\\b${search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                    return regex.test(text);
                } else {
                    return text.toLowerCase().includes(search.toLowerCase());
                }
            };

            const results = [];

            // Search in each node
            nodes.forEach(node => {
                // Determine node type for icon
                const isSpecialNode = SPECIAL_NODE_TYPES && SPECIAL_NODE_TYPES[node.type];
                const isTaskNode = node.isTaskNode || (TASK_NODE_TYPES && TASK_NODE_TYPES[node.type]);

                // Filter by type
                if (globalSearchFilter === 'folder' && node.type !== 'folder') return;
                if (globalSearchFilter === 'sticky' && node.type !== 'sticky') return;
                if (globalSearchFilter === 'image' && node.type !== 'image') return;
                if (globalSearchFilter === 'task' && !isTaskNode) return;

                // Search in title
                if ((globalSearchFilter === 'all' || globalSearchFilter === 'title' ||
                     globalSearchFilter === 'folder' || globalSearchFilter === 'sticky' ||
                     globalSearchFilter === 'image' || globalSearchFilter === 'task') &&
                    matches(node.title, query)) {
                    let typeLabel = 'title';
                    let context = node.summary || '';

                    if (node.type === 'folder') {
                        typeLabel = 'folder';
                        const fileCount = (node.folderFiles || []).length;
                        const typeInfo = FOLDER_TYPES.find(t => t.id === node.folderType) || FOLDER_TYPES[0];
                        context = `${typeInfo.icon} Klas√∂r - ${fileCount} dosya`;
                    } else if (node.type === 'sticky') {
                        typeLabel = 'sticky';
                        context = node.stickyContent || node.summary || 'Sticky Note';
                    } else if (node.type === 'image') {
                        typeLabel = 'image';
                        context = node.imageCaption || 'Resim';
                    } else if (isTaskNode) {
                        typeLabel = 'task';
                        const taskType = TASK_NODE_TYPES[node.type] || {};
                        context = `${taskType.icon || '‚ñ¢'} ${taskType.name || 'G√∂rev'} - ${node.taskStatus || 'pending'}`;
                    }

                    results.push({
                        nodeId: node.id,
                        type: typeLabel,
                        title: node.title,
                        context: context,
                        match: node.title,
                        nodeType: node.type
                    });
                }

                // Search in text/content
                if (globalSearchFilter === 'all' || globalSearchFilter === 'text') {
                    // Regular node fullText
                    if (node.fullText && !isSpecialNode && !isTaskNode) {
                        const plainText = node.fullText.replace(/<[^>]*>/g, ' ');
                        if (matches(plainText, query)) {
                            const idx = plainText.toLowerCase().indexOf(queryLower);
                            if (idx !== -1) {
                                const start = Math.max(0, idx - 40);
                                const end = Math.min(plainText.length, idx + query.length + 40);
                                const context = (start > 0 ? '...' : '') + plainText.substring(start, end) + (end < plainText.length ? '...' : '');
                                results.push({
                                    nodeId: node.id,
                                    type: 'text',
                                    title: node.title,
                                    context: context,
                                    match: query,
                                    nodeType: node.type
                                });
                            }
                        }
                    }
                }

                // Search in sticky note content
                if ((globalSearchFilter === 'all' || globalSearchFilter === 'text' || globalSearchFilter === 'sticky') &&
                    node.type === 'sticky' && (node.stickyContent || node.summary)) {
                    const stickyText = node.stickyContent || node.summary;
                    if (matches(stickyText, query)) {
                        const idx = stickyText.toLowerCase().indexOf(queryLower);
                        if (idx !== -1) {
                            const start = Math.max(0, idx - 40);
                            const end = Math.min(stickyText.length, idx + query.length + 40);
                            const context = (start > 0 ? '...' : '') + stickyText.substring(start, end) + (end < stickyText.length ? '...' : '');
                            // Avoid duplicate if already added via title search
                            const alreadyAdded = results.some(r => r.nodeId === node.id && r.type === 'sticky');
                            if (!alreadyAdded) {
                                results.push({
                                    nodeId: node.id,
                                    type: 'sticky',
                                    title: node.title,
                                    context: context,
                                    match: query,
                                    nodeType: 'sticky'
                                });
                            }
                        }
                    }
                }

                // Search in image caption
                if ((globalSearchFilter === 'all' || globalSearchFilter === 'text' || globalSearchFilter === 'image') &&
                    node.type === 'image' && node.imageCaption) {
                    if (matches(node.imageCaption, query)) {
                        // Avoid duplicate if already added via title search
                        const alreadyAdded = results.some(r => r.nodeId === node.id && r.type === 'image');
                        if (!alreadyAdded) {
                            results.push({
                                nodeId: node.id,
                                type: 'image',
                                title: node.title,
                                context: node.imageCaption,
                                match: query,
                                nodeType: 'image'
                            });
                        }
                    }
                }

                // Search in folder file names
                if ((globalSearchFilter === 'all' || globalSearchFilter === 'file' || globalSearchFilter === 'folder') &&
                    node.type === 'folder' && node.folderFiles) {
                    node.folderFiles.forEach((file, fileIndex) => {
                        if (matches(file.name, query)) {
                            results.push({
                                nodeId: node.id,
                                type: 'file',
                                title: file.name,
                                context: `üìÅ ${node.title} - ${formatFileSize(file.size)}`,
                                match: query,
                                nodeType: 'folder',
                                fileIndex: fileIndex
                            });
                        }
                    });
                }

                // Search in tags
                if ((globalSearchFilter === 'all' || globalSearchFilter === 'desc' || globalSearchFilter === 'location') && node.descs) {
                    node.descs.forEach(desc => {
                        if (desc.val && matches(desc.val, query)) {
                            const descType = descTypes.find(dt => dt.id === desc.tid);
                            results.push({
                                nodeId: node.id,
                                type: 'desc',
                                title: node.title,
                                context: `${descType ? descType.name : 'Tags'}: ${desc.val}`,
                                match: desc.val,
                                nodeType: node.type
                            });
                        }
                    });
                }
            });

            // Search in task nodes specifically
            if (globalSearchFilter === 'all' || globalSearchFilter === 'task') {
                nodes.forEach(node => {
                    const isTaskNode = node.isTaskNode || (TASK_NODE_TYPES && TASK_NODE_TYPES[node.type]);
                    if (isTaskNode && node.taskDescription && matches(node.taskDescription, query)) {
                        const alreadyAdded = results.some(r => r.nodeId === node.id);
                        if (!alreadyAdded) {
                            const taskType = TASK_NODE_TYPES[node.type] || {};
                            results.push({
                                nodeId: node.id,
                                type: 'task',
                                title: node.title,
                                context: node.taskDescription,
                                match: query,
                                nodeType: node.type
                            });
                        }
                    }
                });
            }

            // Search in standalone tasks array
            if (globalSearchFilter === 'all' || globalSearchFilter === 'task') {
                tasks.forEach(task => {
                    if (matches(task.title, query) || matches(task.description, query)) {
                        results.push({
                            nodeId: task.assignedNodeId,
                            type: 'task-item',
                            title: `üìã ${task.title}`,
                            context: task.description || `Status: ${task.status}`,
                            match: query,
                            nodeType: 'task'
                        });
                    }
                });
            }

            // Search in authors
            if (globalSearchFilter === 'all' || globalSearchFilter === 'pov') {
                povList.forEach(pov => {
                    if (matches(pov.name, query)) {
                        const povNodes = nodes.filter(n => n.povId === pov.id);
                        results.push({
                            nodeId: povNodes.length > 0 ? povNodes[0].id : null,
                            type: 'pov',
                            title: `POV: ${pov.name}`,
                            context: `${povNodes.length} sections contain this`,
                            match: pov.name
                        });
                    }
                });
            }

            // Show results
            if (results.length === 0) {
                resultsEl.innerHTML = `<div style="text-align:center; color:#666; padding:30px;">No results found ${isExact ? '(Exact Match)' : ''}</div>`;
                return;
            }

            const escQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            resultsEl.innerHTML = results.map(r => {
                // Icon based on type
                let typeIcon = 'üìñ';
                if (r.type === 'text') typeIcon = 'üìù';
                else if (r.type === 'pov') typeIcon = 'üë§';
                else if (r.type === 'desc') typeIcon = 'üè∑Ô∏è';
                else if (r.type === 'file') typeIcon = 'üìÑ';
                else if (r.type === 'folder' || r.nodeType === 'folder') typeIcon = 'üìÅ';
                else if (r.type === 'sticky' || r.nodeType === 'sticky') typeIcon = 'üìå';
                else if (r.type === 'image' || r.nodeType === 'image') typeIcon = 'üñºÔ∏è';
                else if (r.type === 'task' || r.type === 'task-item' || r.nodeType === 'task') typeIcon = '‚úÖ';

                // Type label in Turkish
                let typeLabel = r.type.toUpperCase();
                if (r.type === 'folder') typeLabel = 'KLAS√ñR';
                else if (r.type === 'sticky') typeLabel = 'NOT';
                else if (r.type === 'image') typeLabel = 'RESƒ∞M';
                else if (r.type === 'task' || r.type === 'task-item') typeLabel = 'G√ñREV';
                else if (r.type === 'file') typeLabel = 'DOSYA';
                else if (r.type === 'text') typeLabel = 'ƒ∞√áERƒ∞K';
                else if (r.type === 'title') typeLabel = 'BA≈ûLIK';

                const highlighted = r.context.replace(new RegExp(escQuery, 'gi'), '<mark>$&</mark>');
                const clickHandler = r.nodeId !== null && r.nodeId !== undefined ? `goToSearchResult('${r.nodeId}')` : '';
                return `
                    <div class="search-result-item" onclick="${clickHandler}" style="cursor: ${clickHandler ? 'pointer' : 'default'}">
                        <div class="search-result-title">${typeIcon} ${r.title}</div>
                        <div class="search-result-context">${highlighted}</div>
                        <div class="search-result-meta">${typeLabel}</div>
                    </div>
                `;
            }).join('');
        }

        function goToSearchResult(nodeId) {
            console.log('goToSearchResult called with:', nodeId);
            closeGlobalSearch();

            // Find the node first to verify it exists
            const node = nodes.find(n => String(n.id) === String(nodeId));
            if (!node) {
                console.error('goToSearchResult: Node not found:', nodeId);
                showToast('Node bulunamadƒ±', 'error');
                return;
            }

            // Use the actual node.id to ensure type consistency
            focusNode(node.id);

            // Check if it's a special node type (folder, sticky, image)
            const isSpecialNode = SPECIAL_NODE_TYPES && SPECIAL_NODE_TYPES[node.type];
            const isTaskNode = node.isTaskNode || (TASK_NODE_TYPES && TASK_NODE_TYPES[node.type]);

            if (isSpecialNode) {
                // Open special node editor for folder, sticky, image
                openSpecialNodeEditor(node.id);
            } else if (isTaskNode) {
                // Open task editor for task nodes
                openTaskEditor(node.id);
            } else {
                // Open full text editor for regular nodes
                openFullEditor(node.id);
            }
        }

        // ============ COMMENTS ============
        function addComment() {
            const editor = document.getElementById('fullTextEditor');
            const selection = window.getSelection();

            if (!selection || selection.isCollapsed) {
                showToast('Select text to add comment first');
                return;
            }

            const comment = prompt('Enter your comment:');
            if (!comment) return;

            const range = selection.getRangeAt(0);
            const span = document.createElement('span');
            span.className = 'comment-highlight';
            span.setAttribute('data-comment', comment);
            span.setAttribute('data-comment-id', Date.now());
            span.setAttribute('title', comment);

            try {
                range.surroundContents(span);
                showToast('Comment added');
                updateCommentsList();
            } catch(e) {
                showToast('Selection contains multiple elements');
            }
        }

        function toggleCommentsPanel() {
            const panel = document.getElementById('commentsPanel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                updateCommentsList();
            }
        }

        function updateCommentsList() {
            const editor = document.getElementById('fullTextEditor');
            const comments = editor.querySelectorAll('.comment-highlight');
            const list = document.getElementById('commentsList');
            const countEl = document.getElementById('commentCount');

            countEl.textContent = comments.length;

            if (comments.length === 0) {
                list.innerHTML = '<div style="color:#888; font-size:0.8em; text-align:center; padding:10px;">No comments yet</div>';
                return;
            }

            list.innerHTML = Array.from(comments).map((c, i) => {
                const text = c.textContent.substring(0, 30) + (c.textContent.length > 30 ? '...' : '');
                const comment = c.getAttribute('data-comment');
                const id = c.getAttribute('data-comment-id');
                return `
                    <div class="comment-item">
                        <div class="comment-item-text">
                            <strong>"${text}"</strong><br>
                            ${comment}
                        </div>
                        <div class="comment-item-actions">
                            <button onclick="goToComment('${id}')" title="Git">üìç</button>
                            <button onclick="editComment('${id}')" title="Edit">‚úèÔ∏è</button>
                            <button onclick="deleteComment('${id}')" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function goToComment(id) {
            const editor = document.getElementById('fullTextEditor');
            const comment = editor.querySelector(`[data-comment-id="${id}"]`);
            if (comment) {
                comment.scrollIntoView({ behavior: 'smooth', block: 'center' });
                comment.style.animation = 'pulse 0.5s ease 2';
            }
        }

        function editComment(id) {
            const editor = document.getElementById('fullTextEditor');
            const comment = editor.querySelector(`[data-comment-id="${id}"]`);
            if (comment) {
                const newComment = prompt('Edit comment:', comment.getAttribute('data-comment'));
                if (newComment !== null) {
                    comment.setAttribute('data-comment', newComment);
                    comment.setAttribute('title', newComment);
                    updateCommentsList();
                    showToast('Comment updated');
                }
            }
        }

        function deleteComment(id) {
            if (!confirm('Are you sure you want to delete this comment?')) return;

            const editor = document.getElementById('fullTextEditor');
            const comment = editor.querySelector(`[data-comment-id="${id}"]`);
            if (comment) {
                // Remove span but keep content
                const text = comment.textContent;
                comment.replaceWith(document.createTextNode(text));
                updateCommentsList();
                showToast('Comment deleted');
            }
        }

        // ============ FONT & PARAGRAPH SETTINGS ============
        // Se√ßimi sakla (dropdown tƒ±klandƒ±ƒüƒ±nda kaybolmasƒ±n)
        let savedSelection = null;
        let savedSelectionText = '';

        // Yeni yazƒ±lacak metin i√ßin bekleyen stiller
        let pendingStyles = {
            fontSize: null,
            fontFamily: null,
            color: null
        };

        function saveSelection() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) {
                console.log('‚ùå saveSelection: editor not found');
                return;
            }

            const sel = window.getSelection();
            console.log('saveSelection called, rangeCount:', sel.rangeCount, 'isCollapsed:', sel.isCollapsed);

            if (sel.rangeCount > 0 && !sel.isCollapsed) {
                // Editor i√ßinde olup olmadƒ±ƒüƒ±nƒ± kontrol etme - her yerden al
                savedSelection = sel.getRangeAt(0).cloneRange();
                savedSelectionText = sel.toString();
                console.log('‚úÖ Selection SAVED:', savedSelectionText);
            } else {
                console.log('‚ùå No selection to save');
            }
        }

        function restoreSelection() {
            if (savedSelection) {
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(savedSelection);
                return true;
            }
            return false;
        }

        // Editor'dan se√ßim yapƒ±ldƒ±ƒüƒ±nda otomatik kaydet - GLOBAL listener
        document.addEventListener('selectionchange', function() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            const sel = window.getSelection();
            if (sel.rangeCount > 0 && !sel.isCollapsed && editor.contains(sel.anchorNode)) {
                savedSelection = sel.getRangeAt(0).cloneRange();
                savedSelectionText = sel.toString();
                console.log('Selection saved:', savedSelectionText);
            }
        });

        // Mouseup ile de kaydet (backup)
        document.addEventListener('mouseup', function() {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            const sel = window.getSelection();
            if (sel.rangeCount > 0 && !sel.isCollapsed && editor.contains(sel.anchorNode)) {
                savedSelection = sel.getRangeAt(0).cloneRange();
                savedSelectionText = sel.toString();
            }
        });

        function applyFontFamily() {
            const font = document.getElementById('fontFamily').value;
            applyStyleToSelection('fontFamily', font);
        }

        function applyFontSize() {
            const size = document.getElementById('fontSize').value;
            applyStyleToSelection('fontSize', size);
        }

        function increaseFontSize() {
            const select = document.getElementById('fontSize');
            const options = Array.from(select.options);
            const currentIndex = select.selectedIndex;
            if (currentIndex < options.length - 1) {
                select.selectedIndex = currentIndex + 1;
                applyFontSize();
            }
        }

        function decreaseFontSize() {
            const select = document.getElementById('fontSize');
            const currentIndex = select.selectedIndex;
            if (currentIndex > 0) {
                select.selectedIndex = currentIndex - 1;
                applyFontSize();
            }
        }

        // Tek bir fonksiyon ile t√ºm stil deƒüi≈üikliklerini y√∂net
        function applyStyleToSelection(styleProp, value) {
            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            console.log('üîµ applyStyleToSelection:', styleProp, value);

            // Her zaman edit√∂re focus ver
            editor.focus();

            // Mevcut se√ßimi kontrol et
            const sel = window.getSelection();
            let hasSelection = sel.rangeCount > 0 && !sel.isCollapsed && sel.toString().length > 0;

            // Kayƒ±tlƒ± se√ßim varsa onu kullan
            if (!hasSelection && savedSelection && savedSelectionText) {
                sel.removeAllRanges();
                sel.addRange(savedSelection);
                hasSelection = !sel.isCollapsed && sel.toString().length > 0;
            }

            if (hasSelection) {
                // SE√áƒ∞Lƒ∞ METƒ∞N VAR - Ona stil uygula
                console.log('üü¢ Applying to selection:', sel.toString());

                const range = sel.getRangeAt(0);
                const span = document.createElement('span');
                span.style[styleProp] = value;

                const contents = range.extractContents();
                span.appendChild(contents);
                range.insertNode(span);

                // Selection'ƒ± g√ºncelle
                sel.removeAllRanges();
                const newRange = document.createRange();
                newRange.selectNodeContents(span);
                sel.addRange(newRange);
                savedSelection = newRange.cloneRange();
                savedSelectionText = sel.toString();

                showToast(`‚ú® Se√ßili metin: ${value}`);
            } else {
                // SE√áƒ∞M YOK - pendingStyles'a kaydet, beforeinput kullanacak
                console.log('üü° No selection - setting pendingStyles for typing');

                pendingStyles[styleProp] = value;

                // Kullanƒ±cƒ±ya bildir
                if (styleProp === 'fontSize') {
                    showToast(`‚ú® Yeni metin boyutu: ${value}`);
                } else if (styleProp === 'color') {
                    showToast(`‚ú® Yeni metin rengi ayarlandƒ±`);
                } else if (styleProp === 'fontFamily') {
                    showToast(`‚ú® Yeni font: ${value}`);
                }
            }
        }

        function applyLineHeight() {
            const height = document.getElementById('lineHeight').value;
            const editor = document.getElementById('fullTextEditor');
            if (editor) {
                editor.style.setProperty('line-height', height, 'important');
            }
        }

        function setAlignment(align) {
            document.execCommand('justify' + align.charAt(0).toUpperCase() + align.slice(1), false, null);
        }

        function adjustIndent(amount) {
            const editor = document.getElementById('fullTextEditor');
            const current = parseInt(editor.style.paddingLeft) || 20;
            const newPadding = Math.max(20, current + amount);
            editor.style.paddingLeft = newPadding + 'px';
        }

        function saveFontSettings() {
            const settings = {
                fontFamily: document.getElementById('fontFamily').value,
                fontSize: document.getElementById('fontSize').value,
                lineHeight: document.getElementById('lineHeight').value
            };
            localStorage.setItem('universalWriterFontSettings', JSON.stringify(settings));
            showToast('Font settings saved');
        }

        function loadFontSettings() {
            const saved = localStorage.getItem('universalWriterFontSettings');
            if (saved) {
                const settings = JSON.parse(saved);
                document.getElementById('fontFamily').value = settings.fontFamily || 'Georgia';
                document.getElementById('fontSize').value = settings.fontSize || '16px';
                document.getElementById('lineHeight').value = settings.lineHeight || '1.8';

                const editor = document.getElementById('fullTextEditor');
                if (editor) {
                    editor.style.fontFamily = settings.fontFamily || 'Georgia';
                    editor.style.fontSize = settings.fontSize || '16px';
                    editor.style.lineHeight = settings.lineHeight || '1.8';
                }
            }
        }

        // ============ ACTIVE TYPING MODES ============
        let currentTypingRevision = null;
        let currentTypingBold = false;
        let currentTypingItalic = false;
        let currentTypingUnderline = false;
        let currentTypingHighlight = null; // null, 'yellow', 'green', 'blue'
        let currentTypingBullet = false;
        let currentTypingNumber = false;
        let bulletCounter = 1; // For numbered lists

        function setActiveTypingRevision(revId) {
            const indicator = document.getElementById('revisionModeIndicator');
            const revNameEl = document.getElementById('currentRevisionName');

            // Just switch typing mode - don't modify any existing text
            // Works the same way for Normal and all other revisions
            currentTypingRevision = revId;

            if (revId === null) {
                // Normal mode - no color for new text
                if (quillEditor) {
                    // Remove color format for future typing
                    quillEditor.format('color', false);
                }
                indicator.classList.remove('active');
                indicator.style.borderColor = '';
                showToast('‚úèÔ∏è Normal writing mode');
            } else {
                const rev = revisionLabels.find(r => r.id === revId);

                if (rev) {
                    // Set color for future typing in Quill
                    if (quillEditor) {
                        quillEditor.format('color', rev.text);
                    }

                    // Show indicator
                    indicator.classList.add('active');
                    indicator.style.borderColor = rev.text;
                    indicator.style.background = rev.bg;
                    indicator.style.color = rev.text;
                    revNameEl.textContent = rev.name;

                    showToast(`‚úèÔ∏è Writing mode: ${rev.name}`);
                }
            }

            renderRevisionLabels();
        }

        // Helper: Move cursor out of colored span so new text won't inherit color
        function breakOutOfColoredSpan(editor) {
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            if (!range.collapsed) return; // Only for cursor, not selection

            // Check if cursor is inside a colored span
            let node = range.startContainer;
            let coloredSpan = null;

            while (node && node !== editor) {
                if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SPAN' && node.style.color) {
                    coloredSpan = node;
                    break;
                }
                node = node.parentNode;
            }

            if (coloredSpan) {
                // Insert a zero-width space after the span and move cursor there
                const zws = document.createTextNode('\u200B');
                coloredSpan.parentNode.insertBefore(zws, coloredSpan.nextSibling);

                // Move cursor after the zero-width space
                const newRange = document.createRange();
                newRange.setStartAfter(zws);
                newRange.setEndAfter(zws);
                selection.removeAllRanges();
                selection.addRange(newRange);
            }
        }

        // Remove color formatting from selected text (return to normal)
        function removeColorFromSelection() {
            const selection = window.getSelection();
            if (!selection || selection.isCollapsed) return;

            const editor = document.getElementById('fullTextEditor');
            if (!editor) return;

            // Get the range
            const range = selection.getRangeAt(0);

            // Find all colored spans within the selection
            const container = range.commonAncestorContainer;

            // If selection is inside a single span with color
            let targetSpan = null;
            if (container.nodeType === Node.TEXT_NODE && container.parentNode.tagName === 'SPAN') {
                targetSpan = container.parentNode;
            } else if (container.tagName === 'SPAN') {
                targetSpan = container;
            }

            if (targetSpan && targetSpan.style.color) {
                // Unwrap the span - replace it with its text content
                const text = targetSpan.textContent;
                const textNode = document.createTextNode(text);
                targetSpan.parentNode.replaceChild(textNode, targetSpan);
                showToast('üßπ Color removed');
                return;
            }

            // If selection spans multiple elements, remove color from all spans
            const spans = editor.querySelectorAll('span[style*="color"]');
            spans.forEach(span => {
                // Check if span is within the selection
                if (selection.containsNode(span, true)) {
                    const text = span.textContent;
                    const textNode = document.createTextNode(text);
                    span.parentNode.replaceChild(textNode, span);
                }
            });

            showToast('üßπ Formatting removed');
        }

        // Apply active revision color while typing in editor (Scrivener style)
        // ONLY newly typed characters will be colored, existing text will NOT change
        // Track active typing font size (null = use default editor font)
        let currentTypingFontSize = null;

        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                const editor = document.getElementById('fullTextEditor');
                if (editor) {
                    // Set initial font size from dropdown
                    const fontSizeSelect = document.getElementById('fontSize');
                    if (fontSizeSelect) {
                        editor.style.fontSize = fontSizeSelect.value;
                        editorBaseFontSize = parseInt(fontSizeSelect.value);
                    }

                    // beforeinput: Intercept BEFORE character is typed
                    editor.addEventListener('beforeinput', function(e) {
                        if (e.inputType !== 'insertText' || !e.data) return;

                        // Check all active typing modes
                        const rev = currentTypingRevision ? revisionLabels.find(r => r.id === currentTypingRevision) : null;
                        const customFontSize = currentTypingFontSize || pendingStyles.fontSize;
                        const customColor = pendingStyles.color;
                        const customFontFamily = pendingStyles.fontFamily;
                        const hasBold = currentTypingBold;
                        const hasItalic = currentTypingItalic;
                        const hasUnderline = currentTypingUnderline;
                        const hasHighlight = currentTypingHighlight;

                        // Check if any special formatting is active
                        const hasAnyFormatting = rev || customFontSize || customColor || customFontFamily || hasBold || hasItalic || hasUnderline || hasHighlight;

                        // Check if cursor is inside a styled element
                        const selection = window.getSelection();
                        if (!selection.rangeCount) return;
                        const range = selection.getRangeAt(0);
                        let insideStyledSpan = false;
                        let node = range.startContainer;
                        while (node && node !== editor) {
                            if (node.nodeType === Node.ELEMENT_NODE && node.style &&
                                (node.style.color || node.style.fontWeight || node.style.fontStyle ||
                                 node.style.textDecoration || node.style.backgroundColor || node.style.fontSize)) {
                                insideStyledSpan = true;
                                break;
                            }
                            node = node.parentNode;
                        }

                        // Normal mode (no formatting): Need to break out of styled spans
                        if (!hasAnyFormatting) {
                            if (!insideStyledSpan) return; // Not inside styled span, let browser handle

                            // Inside a styled span - we need to insert plain text AFTER the span
                            e.preventDefault();

                            // Find the outermost styled span
                            let styledSpan = null;
                            let checkNode = range.startContainer;
                            while (checkNode && checkNode !== editor) {
                                if (checkNode.nodeType === Node.ELEMENT_NODE && checkNode.style &&
                                    (checkNode.style.color || checkNode.style.fontWeight || checkNode.style.fontStyle ||
                                     checkNode.style.textDecoration || checkNode.style.backgroundColor || checkNode.style.fontSize)) {
                                    styledSpan = checkNode;
                                }
                                checkNode = checkNode.parentNode;
                            }

                            // Create plain text node
                            const textNode = document.createTextNode(e.data);

                            if (styledSpan && styledSpan.parentNode) {
                                // Insert after the styled span
                                if (styledSpan.nextSibling) {
                                    styledSpan.parentNode.insertBefore(textNode, styledSpan.nextSibling);
                                } else {
                                    styledSpan.parentNode.appendChild(textNode);
                                }
                            } else {
                                // Fallback: insert at cursor
                                range.insertNode(textNode);
                            }

                            // Move cursor after the text
                            const newRange = document.createRange();
                            newRange.setStartAfter(textNode);
                            newRange.setEndAfter(textNode);
                            selection.removeAllRanges();
                            selection.addRange(newRange);

                            updateEditorStats();
                            return;
                        }

                        // Has formatting - apply styled span
                        e.preventDefault();

                        // Create styled span for new character
                        const span = document.createElement('span');
                        if (rev) span.style.color = rev.text;
                        else if (customColor) span.style.color = customColor;
                        if (customFontSize) span.style.fontSize = customFontSize;
                        if (customFontFamily) span.style.fontFamily = customFontFamily;
                        if (hasBold) span.style.fontWeight = 'bold';
                        if (hasItalic) span.style.fontStyle = 'italic';
                        if (hasUnderline) span.style.textDecoration = 'underline';
                        if (hasHighlight === 'yellow') span.style.backgroundColor = '#ffeb3b';
                        if (hasHighlight === 'green') span.style.backgroundColor = '#a5d6a7';
                        if (hasHighlight === 'blue') span.style.backgroundColor = '#90caf9';
                        span.textContent = e.data;

                        // Insert at cursor position
                        range.deleteContents(); // Delete if selected
                        range.insertNode(span);

                        // Move cursor to end of span
                        range.setStartAfter(span);
                        range.setEndAfter(span);
                        selection.removeAllRanges();
                        selection.addRange(range);

                        updateEditorStats();
                    });

                    // For Enter key - continue styling on new line OR add bullet/number
                    editor.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') {
                            // Handle bullet/number list mode
                            if (currentTypingBullet || currentTypingNumber) {
                                e.preventDefault();
                                const selection = window.getSelection();
                                if (selection.rangeCount > 0) {
                                    const range = selection.getRangeAt(0);

                                    // Create new line with bullet/number
                                    const br = document.createElement('br');
                                    range.deleteContents();
                                    range.insertNode(br);
                                    range.setStartAfter(br);
                                    range.setEndAfter(br);

                                    // Add bullet or number
                                    let prefix = '';
                                    if (currentTypingBullet) {
                                        prefix = '‚Ä¢ ';
                                    } else if (currentTypingNumber) {
                                        bulletCounter++;
                                        prefix = bulletCounter + '. ';
                                    }

                                    const textNode = document.createTextNode(prefix);
                                    range.insertNode(textNode);
                                    range.setStartAfter(textNode);
                                    range.setEndAfter(textNode);
                                    selection.removeAllRanges();
                                    selection.addRange(range);
                                    updateEditorStats();
                                }
                                return;
                            }

                            // Handle revision/font styling on new line
                            if (currentTypingRevision || currentTypingFontSize) {
                                setTimeout(() => {
                                    const rev = currentTypingRevision ? revisionLabels.find(r => r.id === currentTypingRevision) : null;
                                    if (rev || currentTypingFontSize) {
                                        const selection = window.getSelection();
                                        if (selection.rangeCount > 0) {
                                            const range = selection.getRangeAt(0);
                                            const span = document.createElement('span');
                                            if (rev) span.style.color = rev.text;
                                            if (currentTypingFontSize) span.style.fontSize = currentTypingFontSize;
                                            span.innerHTML = '&#8203;'; // Zero-width space
                                            range.insertNode(span);
                                            range.setStart(span, 1);
                                            range.setEnd(span, 1);
                                            selection.removeAllRanges();
                                            selection.addRange(range);
                                        }
                                    }
                                }, 10);
                            }
                        }
                    });

                    // For paste
                    editor.addEventListener('paste', function(e) {
                        const rev = currentTypingRevision ? revisionLabels.find(r => r.id === currentTypingRevision) : null;

                        // If no special styling, let default paste happen
                        if (!rev && !currentTypingFontSize) return;

                        e.preventDefault();
                        const text = e.clipboardData.getData('text/plain');

                        const span = document.createElement('span');
                        if (rev) span.style.color = rev.text;
                        if (currentTypingFontSize) span.style.fontSize = currentTypingFontSize;
                        span.textContent = text;

                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            range.deleteContents();
                            range.insertNode(span);
                            range.setStartAfter(span);
                            range.setEndAfter(span);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }

                        updateEditorStats();
                    });
                }

                // Load font settings
                loadFontSettings();
            }, 500);
        });

        // Ctrl+Shift+F global arama
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'F') {
                e.preventDefault();
                openGlobalSearch();
            }
            // Escape closes global search
            if (e.key === 'Escape' && document.getElementById('globalSearchModal').classList.contains('active')) {
                closeGlobalSearch();
            }
            // Ctrl+M comment
            if ((e.ctrlKey || e.metaKey) && e.key === 'm' && document.getElementById('editorModal').classList.contains('active')) {
                e.preventDefault();
                addComment();
            }
        });

        // ============ TEXT COLOR ============
        function showTextColorPicker() {
            const picker = document.getElementById('textColorPicker');
            picker.click();
        }

        function applyTextColor(color) {
            applyStyleToSelection('color', color);
        }

        // ============ SETTINGS ============
        let appSettings = {
            autoSaveInterval: 300000,
            fontFamily: 'Georgia',
            fontSize: '16px',
            theme: 'dark',
            cardSize: 'medium'
        };

        function openSettingsModal() {
            // Load current settings
            loadAppSettings();
            document.getElementById('autoSaveInterval').value = appSettings.autoSaveInterval;
            document.getElementById('settingsFontFamily').value = appSettings.fontFamily;
            document.getElementById('settingsFontSize').value = appSettings.fontSize;
            document.getElementById('settingsTheme').value = appSettings.theme;
            document.getElementById('settingsCardSize').value = appSettings.cardSize;
            const modal = document.getElementById('settingsModal');
            modal.style.display = 'flex';
            modal.classList.add('active');
        }

        function loadAppSettings() {
            const saved = localStorage.getItem('universalWriterSettings');
            if (saved) {
                try {
                    appSettings = { ...appSettings, ...JSON.parse(saved) };
                } catch(e) {}
            }
            applyCardSize();
        }

        function saveAllSettings() {
            appSettings.autoSaveInterval = parseInt(document.getElementById('autoSaveInterval').value);
            appSettings.fontFamily = document.getElementById('settingsFontFamily').value;
            appSettings.fontSize = document.getElementById('settingsFontSize').value;
            appSettings.theme = document.getElementById('settingsTheme').value;
            appSettings.cardSize = document.getElementById('settingsCardSize').value;

            localStorage.setItem('universalWriterSettings', JSON.stringify(appSettings));
            updateAutoSaveInterval();
            applyTheme();
            applyCardSize();
            closeModal('settingsModal');
            showToast('Settings saved');
        }

        function applyCardSize() {
            const size = appSettings.cardSize || 'medium';
            const canvas = document.getElementById('canvas');

            // Remove existing size classes
            canvas.classList.remove('card-small', 'card-medium', 'card-large');
            canvas.classList.add('card-' + size);

            // Re-render nodes with new size
            renderAll();
        }

        function updateAutoSaveInterval() {
            const interval = parseInt(document.getElementById('autoSaveInterval').value);

            // Clear current interval
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }

            // Start new interval
            if (interval > 0) {
                autoSaveInterval = setInterval(performAutoSave, interval);
                console.log(`Auto-save: Her ${interval / 60000} minutes bir`);
            } else {
                console.log('Auto-save disabled');
            }
        }

        function applyTheme() {
            const theme = document.getElementById('settingsTheme').value;
            // Theme changes can be applied here (keep it simple for now)
        }

        function resetSettings() {
            if (!confirm('Are you sure you want to reset all settings to default?')) return;

            appSettings = {
                autoSaveInterval: 300000,
                fontFamily: 'Georgia',
                fontSize: '16px',
                theme: 'dark',
                cardSize: 'medium'
            };

            document.getElementById('autoSaveInterval').value = appSettings.autoSaveInterval;
            document.getElementById('settingsFontFamily').value = appSettings.fontFamily;
            document.getElementById('settingsFontSize').value = appSettings.fontSize;
            document.getElementById('settingsTheme').value = appSettings.theme;
            document.getElementById('settingsCardSize').value = appSettings.cardSize;

            localStorage.removeItem('universalWriterSettings');
            applyCardSize();
            showToast('Settings reset to default');
        }

        // ============ NODE TYPE (LEGEND) MANAGER ============
        const defaultNodeTypes = [
            { id: 'section', name: 'Section', emoji: 'üìÑ', color: '#4fc3f7', textColor: '#1a1a1a', prefix: '', isDefault: true },
            { id: 'group', name: 'Group', emoji: 'üìÅ', color: '#f7971e', textColor: '#1a1a1a', prefix: '', isDefault: true },
            { id: 'introduction', name: 'Introduction', emoji: 'üé¨', color: '#667eea', textColor: '#ffffff', prefix: '', isDefault: true },
            { id: 'note', name: 'Note', emoji: 'üìù', color: '#9C27B0', textColor: '#ffffff', prefix: '', isDefault: true },
            { id: 'research', name: 'Research', emoji: 'üî¨', color: '#00c853', textColor: '#ffffff', prefix: '', isDefault: true },
            { id: 'reference', name: 'Reference', emoji: 'üìö', color: '#00d2ff', textColor: '#ffffff', prefix: '', isDefault: true },
            { id: 'draft', name: 'Draft', emoji: '‚úèÔ∏è', color: '#FF9800', textColor: '#1a1a1a', prefix: '', isDefault: true },
            { id: 'conclusion', name: 'Conclusion', emoji: 'üèÅ', color: '#d50000', textColor: '#ffffff', prefix: '', isDefault: true },
            { id: 'appendix', name: 'Appendix', emoji: 'üìé', color: '#607D8B', textColor: '#ffffff', prefix: '', isDefault: true },
            { id: 'abstract', name: 'Abstract', emoji: 'üìã', color: '#8e2de2', textColor: '#ffffff', prefix: '', isDefault: true }
        ];

        let nodeTypes = JSON.parse(JSON.stringify(defaultNodeTypes));
        let editingNodeTypeId = null;

        function openNodeTypeManager() {
            const modal = document.getElementById('nodeTypeManagerModal');
            modal.classList.add('active');
            modal.style.display = 'flex';
            renderNodeTypeList();
            cancelNodeTypeEdit();
        }

        // Helper function for settings button
        function openLegendManagerFromSettings() {
            // First hide settings modal
            const settingsModal = document.getElementById('settingsModal');
            settingsModal.classList.remove('active');
            settingsModal.style.display = 'none';

            // Then open Legend Manager immediately
            openNodeTypeManager();
        }

        function renderNodeTypeList() {
            const list = document.getElementById('nodeTypeManagerList');
            let html = '';

            nodeTypes.forEach(nt => {
                html += `
                <div class="manager-item" style="display:flex; align-items:center; gap:10px; padding:10px; background:#333; border-radius:6px; margin-bottom:8px;">
                    <span style="font-size:1.5em;">${nt.emoji}</span>
                    <div style="flex:1;">
                        <div style="font-weight:bold; color:#fff;">${nt.name}</div>
                        <div style="font-size:0.8em; color:#888;">ID: ${nt.id}</div>
                    </div>
                    <div style="width:30px; height:30px; border-radius:6px; background:${nt.color};"></div>
                    <button onclick="editNodeType('${nt.id}')" style="background:#2196F3; color:#fff; border:none; padding:6px 10px; border-radius:4px; cursor:pointer;">‚úèÔ∏è</button>
                    ${!nt.isDefault ? `<button onclick="deleteNodeType('${nt.id}')" style="background:#f44336; color:#fff; border:none; padding:6px 10px; border-radius:4px; cursor:pointer;">üóëÔ∏è</button>` : ''}
                </div>`;
            });

            list.innerHTML = html;
        }

        function editNodeType(id) {
            const nt = nodeTypes.find(t => t.id === id);
            if (!nt) return;

            editingNodeTypeId = id;
            document.getElementById('nodeTypeFormTitle').textContent = '‚úèÔ∏è Edit Type';
            document.getElementById('nodeTypeIdInput').value = nt.id;
            document.getElementById('nodeTypeIdInput').disabled = true;
            document.getElementById('nodeTypeNameInput').value = nt.name;
            document.getElementById('nodeTypeEmojiInput').value = nt.emoji;
            document.getElementById('nodeTypeColorInput').value = nt.color;
            document.getElementById('nodeTypeTextColorInput').value = nt.textColor || '#ffffff';
            document.getElementById('nodeTypePrefixInput').value = nt.prefix || '';
        }

        function cancelNodeTypeEdit() {
            editingNodeTypeId = null;
            document.getElementById('nodeTypeFormTitle').textContent = '‚ûï Add New Type';
            document.getElementById('nodeTypeIdInput').value = '';
            document.getElementById('nodeTypeIdInput').disabled = false;
            document.getElementById('nodeTypeNameInput').value = '';
            document.getElementById('nodeTypeEmojiInput').value = '';
            document.getElementById('nodeTypeColorInput').value = '#9C27B0';
            document.getElementById('nodeTypeTextColorInput').value = '#ffffff';
            document.getElementById('nodeTypePrefixInput').value = '';
            // Don't close modal here - this function just resets the form
        }

        // Separate function to close the modal (called by Cancel button)
        function closeLegendManager() {
            cancelNodeTypeEdit();
            closeModal('nodeTypeManagerModal');
        }

        function saveNodeType() {
            const id = document.getElementById('nodeTypeIdInput').value.toLowerCase().trim().replace(/\s+/g, '');
            const name = document.getElementById('nodeTypeNameInput').value.trim();
            const emoji = document.getElementById('nodeTypeEmojiInput').value.trim() || 'üìÑ';
            const color = document.getElementById('nodeTypeColorInput').value;
            const textColor = document.getElementById('nodeTypeTextColorInput').value;
            const prefix = document.getElementById('nodeTypePrefixInput').value.trim();

            if (!id || !name) {
                showToast('ID ve Ad zorunlu!', 'error');
                return;
            }

            if (editingNodeTypeId) {
                // Editme
                const idx = nodeTypes.findIndex(t => t.id === editingNodeTypeId);
                if (idx !== -1) {
                    nodeTypes[idx] = { ...nodeTypes[idx], name, emoji, color, textColor, prefix };
                }
            } else {
                // New addition
                if (nodeTypes.find(t => t.id === id)) {
                    showToast('Bu ID zaten var!', 'error');
                    return;
                }
                nodeTypes.push({ id, name, emoji, color, textColor, prefix, isDefault: false });
            }

            saveNodeTypes();
            applyNodeTypeStyles();
            updateNodeTypeSelects();
            updateAddMenu();
            renderNodeTypeList();
            cancelNodeTypeEdit();
            showToast('Type saved!');
        }

        function deleteNodeType(id) {
            if (!confirm('Are you sure you want to delete this type?')) return;

            nodeTypes = nodeTypes.filter(t => t.id !== id);
            saveNodeTypes();
            applyNodeTypeStyles();
            updateNodeTypeSelects();
            updateAddMenu();
            renderNodeTypeList();
            showToast('Type deleted');
        }

        function saveNodeTypes() {
            localStorage.setItem('universalWriterNodeTypes', JSON.stringify(nodeTypes));
        }

        function loadNodeTypes() {
            const saved = localStorage.getItem('universalWriterNodeTypes');
            if (saved) {
                try {
                    nodeTypes = JSON.parse(saved);
                } catch(e) {}
            }
            applyNodeTypeStyles();
            updateNodeTypeSelects();
            updateAddMenu();
        }

        function applyNodeTypeStyles() {
            let styleEl = document.getElementById('nodeTypeStyles');
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = 'nodeTypeStyles';
                document.head.appendChild(styleEl);
            }

            let css = '';
            nodeTypes.forEach(nt => {
                css += `.node-${nt.id} .node-header { background: ${nt.color} !important; color: ${nt.textColor} !important; }\n`;
            });

            styleEl.textContent = css;
        }

        function updateNodeTypeSelects() {
            const select = document.getElementById('editType');
            if (!select) return;

            select.innerHTML = '';
            nodeTypes.forEach(nt => {
                const opt = document.createElement('option');
                opt.value = nt.id;
                opt.textContent = nt.name;
                select.appendChild(opt);
            });
        }

        function updateAddMenu() {
            const menu = document.getElementById('addMenu');
            if (!menu) return;

            let html = '';
            nodeTypes.forEach(nt => {
                html += `<div class="context-menu-item" onclick="addNode('${nt.id}')">${nt.emoji} ${nt.name}</div>`;
            });

            menu.innerHTML = html;
        }

        // ============ BACKUP ============
        let lastBackupDate = null;

        function openBackupModal() {
            const now = new Date();
            const dateStr = now.toISOString().slice(0, 10).replace(/-/g, '');
            document.getElementById('backupFileName').value = `project_backup_${dateStr}`;

            // Show last backup time
            const lastBackup = localStorage.getItem('universalWriterLastBackup');
            if (lastBackup) {
                document.getElementById('lastBackupTime').textContent = new Date(lastBackup).toLocaleString('en-US');
            }

            document.getElementById('backupModal').classList.add('active');
        }

        function performBackup() {
            const fileName = document.getElementById('backupFileName').value || 'backup';
            const format = document.getElementById('backupFormat').value;
            const includeNodes = document.getElementById('backupIncludeNodes').checked;
            const includeConnections = document.getElementById('backupIncludeConnections').checked;
            const includeSnapshots = document.getElementById('backupIncludeSnapshots').checked;
            const includeMeta = document.getElementById('backupIncludeMeta').checked;

            let content, ext, mime;

            if (format === 'json') {
                const data = {};
                if (includeNodes) data.nodes = nodes;
                if (includeConnections) data.connections = connections;
                if (includeMeta) {
                    data.povList = povList;
                    data.descTypes = descTypes;
                    data.revisionLabels = revisionLabels;
                }
                data.version = '4.0';
                data.backupDate = new Date().toISOString();
                content = JSON.stringify(data, null, 2);
                ext = 'json';
                mime = 'application/json';
            } else if (format === 'txt') {
                content = generatePlainTextExport();
                ext = 'txt';
                mime = 'text/plain';
            } else if (format === 'md') {
                content = generateMarkdownExport();
                ext = 'md';
                mime = 'text/markdown';
            }

            // Download
            const blob = new Blob([content], { type: mime });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName}.${ext}`;
            a.click();
            URL.revokeObjectURL(url);

            // Save last backup time
            localStorage.setItem('universalWriterLastBackup', new Date().toISOString());
            document.getElementById('lastBackupTime').textContent = new Date().toLocaleString('en-US');

            closeModal('backupModal');
            showToast(`üì¶ Backup saved: ${fileName}.${ext}`);
        }

        function generatePlainTextExport() {
            let text = '72 SECONDS: THE AWAKENING\n';
            text += '='.repeat(40) + '\n\n';

            nodes.forEach(node => {
                text += `\n${'='.repeat(40)}\n`;
                text += `${node.type.toUpperCase()}: ${node.title}\n`;
                text += '='.repeat(40) + '\n\n';

                if (node.summary) {
                    text += `Summary: ${node.summary}\n\n`;
                }

                if (node.fullText) {
                    const plainText = node.fullText.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '');
                    text += plainText + '\n';
                }
            });

            return text;
        }

        function generateMarkdownExport() {
            let md = '# 72 SECONDS: THE AWAKENING\n\n';

            nodes.forEach(node => {
                md += `\n---\n\n`;
                md += `## ${node.title}\n\n`;
                md += `*${node.type.toUpperCase()}*\n\n`;

                if (node.summary) {
                    md += `> ${node.summary}\n\n`;
                }

                if (node.fullText) {
                    const text = node.fullText
                        .replace(/<br\s*\/?>/gi, '\n')
                        .replace(/<\/?p>/gi, '\n\n')
                        .replace(/<\/?b>/gi, '**')
                        .replace(/<\/?strong>/gi, '**')
                        .replace(/<\/?i>/gi, '*')
                        .replace(/<\/?em>/gi, '*')
                        .replace(/<[^>]*>/g, '');
                    md += text + '\n';
                }
            });

            return md;
        }

        function loadBackupFile() {
            document.getElementById('backupLoadFile').click();
        }

        function importBackupFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = e => {
                try {
                    if (file.name.endsWith('.json')) {
                        const data = JSON.parse(e.target.result);
                        if (data.nodes) nodes = data.nodes;
                        if (data.connections) connections = data.connections;
                        if (data.povList) povList = data.povList;
                        if (data.descTypes) descTypes = data.descTypes;
                        if (data.revisionLabels) revisionLabels = data.revisionLabels;

                        idCounter.node = Math.max(...nodes.map(n => parseInt(n.id.replace('node_', '')) || 0), 0) + 1;
                        idCounter.pov = Math.max(...povList.map(p => p.id), 0) + 1;
                        idCounter.desc = Math.max(...descTypes.map(d => d.id), 0) + 1;

                        renderAll();
                        updateAllStats();
                        renderOutline();
                        updateSelects();
                        closeModal('backupModal');
                        showToast('Backup loaded');
                    } else {
                        showToast('Currently only JSON backup files can be loaded');
                    }
                } catch (err) {
                    showToast('Could not read file');
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // ============ COMPILE (Scrivener Style) ============
        let compileFormat = 'pdf';
        let compileSelectedNodes = [];
        let compileSelectedSpecialNodes = [];

        function openCompileModal() {
            // Start with all nodes selected (both regular and special)
            compileSelectedNodes = nodes.map(n => n.id);
            compileSelectedSpecialNodes = (window.specialNodes || []).map(n => n.id);
            renderCompileNodeList();
            updateCompilePreview();
            
            // Set PDF as default
            selectCompileFormat('pdf');
            document.getElementById('compileModal').classList.add('active');
        }

        function selectCompileFormat(format) {
            compileFormat = format;
            document.querySelectorAll('.compile-format-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.format === format);
            });

            // Show note when PDF is selected
            const pdfNote = document.getElementById('compilePdfNote');
            if (pdfNote) {
                pdfNote.style.display = format === 'pdf' ? 'block' : 'none';
            }
        }

        function renderCompileNodeList() {
            const container = document.getElementById('compileNodeList');
            const typeIcons = {
                prologue: 'üé¨', chapter: 'üìñ', act: 'üé≠', plotpoint: 'üéØ',
                midpoint: '‚ö°', climax: 'üî•', resolution: 'üåü', ending: 'üìï',
                folder: 'üìÅ', sticky: 'üìù', image: 'üñºÔ∏è', task: 'üìã'
            };
            
            const specialNodesList = window.specialNodes || [];
            
            // Regular nodes
            let html = '<div style="margin-bottom:8px; font-weight:bold; color:#666; font-size:0.85em;">üìÑ Section Nodes</div>';
            html += nodes.map(node => {
                const checked = compileSelectedNodes.includes(node.id) ? 'checked' : '';
                const words = countWords(node.fullText);
                return `
                    <div class="compile-node-item" onclick="toggleCompileNode('${node.id}')">
                        <input type="checkbox" ${checked} onclick="event.stopPropagation(); toggleCompileNode('${node.id}')">
                        <span>${typeIcons[node.type] || 'üìÑ'}</span>
                        <span style="flex:1;">${node.title}</span>
                        <span class="node-type-badge">${node.type}</span>
                        <span style="color:#888; font-size:0.8em;">${words}k</span>
                    </div>
                `;
            }).join('');
            
            // Special nodes (folder, sticky, image)
            const folderNodes = specialNodesList.filter(n => n.nodeType === 'folder');
            const stickyNodes = specialNodesList.filter(n => n.nodeType === 'sticky');
            const imageNodes = specialNodesList.filter(n => n.nodeType === 'image');
            
            if (folderNodes.length > 0) {
                html += '<div style="margin-top:12px; margin-bottom:8px; font-weight:bold; color:#e67e22; font-size:0.85em;">üìÅ Folder Nodes</div>';
                html += folderNodes.map(node => {
                    const checked = compileSelectedSpecialNodes.includes(node.id) ? 'checked' : '';
                    return `
                        <div class="compile-node-item" onclick="toggleCompileSpecialNode('${node.id}')" style="background:#fff3e0;">
                            <input type="checkbox" ${checked} onclick="event.stopPropagation(); toggleCompileSpecialNode('${node.id}')">
                            <span>üìÅ</span>
                            <span style="flex:1;">${node.title || 'Folder'}</span>
                            <span style="color:#888; font-size:0.8em;">${(node.files || []).length} files</span>
                    </div>
                `;
            }).join('');
            }
            
            if (stickyNodes.length > 0) {
                html += '<div style="margin-top:12px; margin-bottom:8px; font-weight:bold; color:#f1c40f; font-size:0.85em;">üìù Sticky Notes</div>';
                html += stickyNodes.map(node => {
                    const checked = compileSelectedSpecialNodes.includes(node.id) ? 'checked' : '';
                    return `
                        <div class="compile-node-item" onclick="toggleCompileSpecialNode('${node.id}')" style="background:#fff9c4;">
                            <input type="checkbox" ${checked} onclick="event.stopPropagation(); toggleCompileSpecialNode('${node.id}')">
                            <span>üìù</span>
                            <span style="flex:1;">${node.title || 'Sticky Note'}</span>
                        </div>
                    `;
                }).join('');
            }
            
            if (imageNodes.length > 0) {
                html += '<div style="margin-top:12px; margin-bottom:8px; font-weight:bold; color:#e91e63; font-size:0.85em;">üñºÔ∏è Image Nodes</div>';
                html += imageNodes.map(node => {
                    const checked = compileSelectedSpecialNodes.includes(node.id) ? 'checked' : '';
                    return `
                        <div class="compile-node-item" onclick="toggleCompileSpecialNode('${node.id}')" style="background:#fce4ec;">
                            <input type="checkbox" ${checked} onclick="event.stopPropagation(); toggleCompileSpecialNode('${node.id}')">
                            <span>üñºÔ∏è</span>
                            <span style="flex:1;">${node.title || 'Image'}</span>
                        </div>
                    `;
                }).join('');
            }
            
            container.innerHTML = html;
        }
        
        function toggleCompileSpecialNode(id) {
            if (compileSelectedSpecialNodes.includes(id)) {
                compileSelectedSpecialNodes = compileSelectedSpecialNodes.filter(x => x !== id);
            } else {
                compileSelectedSpecialNodes.push(id);
            }
            renderCompileNodeList();
            updateCompilePreview();
        }

        function toggleCompileNode(id) {
            if (compileSelectedNodes.includes(id)) {
                compileSelectedNodes = compileSelectedNodes.filter(x => x !== id);
            } else {
                compileSelectedNodes.push(id);
            }
            renderCompileNodeList();
            updateCompilePreview();
        }

        function selectAllCompileNodes() {
            compileSelectedNodes = nodes.map(n => n.id);
            compileSelectedSpecialNodes = (window.specialNodes || []).map(n => n.id);
            renderCompileNodeList();
            updateCompilePreview();
        }

        function deselectAllCompileNodes() {
            compileSelectedNodes = [];
            compileSelectedSpecialNodes = [];
            renderCompileNodeList();
            updateCompilePreview();
        }

        function updateCompilePreview() {
            const preview = document.getElementById('compilePreview');
            const selectedNodes = nodes.filter(n => compileSelectedNodes.includes(n.id));
            const specialNodesList = window.specialNodes || [];
            const selectedSpecialNodes = specialNodesList.filter(n => compileSelectedSpecialNodes.includes(n.id));
            const totalWords = selectedNodes.reduce((sum, n) => sum + countWords(n.fullText), 0);
            const folderCount = selectedSpecialNodes.filter(n => n.nodeType === 'folder').length;
            const stickyCount = selectedSpecialNodes.filter(n => n.nodeType === 'sticky').length;
            const imageCount = selectedSpecialNodes.filter(n => n.nodeType === 'image').length;

            if (selectedNodes.length === 0 && selectedSpecialNodes.length === 0) {
                preview.innerHTML = '<p style="color:#888;">ƒ∞√ßerik se√ßin...</p>';
                return;
            }

            let html = `<p><strong>${selectedNodes.length}</strong> section | <strong>${totalWords.toLocaleString()}</strong> kelime</p>`;
            
            // Special nodes summary
            if (folderCount > 0 || stickyCount > 0 || imageCount > 0) {
                html += '<p style="margin-top:5px; font-size:0.9em; color:#666;">';
                if (folderCount > 0) html += `üìÅ ${folderCount} klas√∂r `;
                if (stickyCount > 0) html += `üìù ${stickyCount} not `;
                if (imageCount > 0) html += `üñºÔ∏è ${imageCount} resim`;
                html += '</p>';
            }
            
            html += '<ol style="margin:10px 0 0 20px; color:#666;">';
            selectedNodes.slice(0, 5).forEach(n => {
                html += `<li>${n.title}</li>`;
            });
            if (selectedNodes.length > 5) {
                html += `<li>... ve ${selectedNodes.length - 5} section daha</li>`;
            }
            html += '</ol>';

            preview.innerHTML = html;
        }

        function previewCompile() {
            const selectedNodes = nodes.filter(n => compileSelectedNodes.includes(n.id));
            if (selectedNodes.length === 0) {
                showToast('Select a section first');
                return;
            }
            const content = generateCompileContent('html');
            const previewWindow = window.open('', '_blank', 'width=900,height=700');
            if (previewWindow) {
                previewWindow.document.write(content);
                previewWindow.document.close();
            } else {
                showToast('Pop-up blocked, please allow');
            }
        }

        function performCompile() {
            const selectedNodes = nodes.filter(n => compileSelectedNodes.includes(n.id));
            if (selectedNodes.length === 0) {
                showToast('No sections selected');
                return;
            }

            const content = generateCompileContent(compileFormat);
            const bookTitle = document.getElementById('compileBookTitle').value || 'My Project';

            let ext, mime;
            switch(compileFormat) {
                case 'docx':
                    // Real DOCX format using docx blob
                    ext = 'doc';
                    mime = 'application/msword';
                    break;
                case 'pdf':
                    // Generate real PDF using jsPDF
                    generateRealPDF(bookTitle);
                    return;
                case 'txt':
                    ext = 'txt';
                    mime = 'text/plain';
                    break;
                case 'md':
                    ext = 'md';
                    mime = 'text/markdown';
                    break;
                case 'html':
                    ext = 'html';
                    mime = 'text/html';
                    break;
            }

            const blob = new Blob([content], { type: mime });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${bookTitle.replace(/\s+/g, '_')}.${ext}`;
            a.click();
            URL.revokeObjectURL(url);

            closeModal('compileModal');
            showToast(`üìö Compiled: ${bookTitle}.${ext}`);
        }

        // Real PDF Generation with jsPDF
        async function generateRealPDF(bookTitle) {
            showToast('üìÑ Generating PDF...');

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });

                const selectedNodes = nodes.filter(n => compileSelectedNodes.includes(n.id));
                const specialNodesList = window.specialNodes || [];
                const selectedSpecialNodes = specialNodesList.filter(n => compileSelectedSpecialNodes.includes(n.id));
                
                // Content type options
                const includeNodeContent = document.getElementById('compileIncludeNodes')?.checked ?? true;
                const includeTaskContent = document.getElementById('compileIncludeTasks')?.checked ?? true;
                const includeFolderContent = document.getElementById('compileIncludeFolders')?.checked ?? true;
                const includeImageContent = document.getElementById('compileIncludeImages')?.checked ?? true;
                const includeStickyContent = document.getElementById('compileIncludeSticky')?.checked ?? true;
                
                const includeTitles = document.getElementById('compileIncludeTitles').checked;
                const includeSummary = document.getElementById('compileIncludeSummary').checked;
                const pageBreaks = document.getElementById('compilePageBreaks').checked;
                const includePov = document.getElementById('compileIncludePov').checked;
                const includeCover = document.getElementById('compileIncludeCover').checked;
                const authorName = document.getElementById('compileAuthorName').value;
                const fontFamily = document.getElementById('compileFontFamily').value;
                const fontSize = parseInt(document.getElementById('compileFontSize').value) || 12;
                const lineSpacing = parseFloat(document.getElementById('compileLineSpacing').value) || 1.5;

                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const marginLeft = 25;
                const marginRight = 25;
                const marginTop = 30;
                const marginBottom = 25;
                const contentWidth = pageWidth - marginLeft - marginRight;
                let yPos = marginTop;

                // Cover page
                if (includeCover) {
                    doc.setFontSize(28);
                    doc.setFont('helvetica', 'bold');
                    const titleLines = doc.splitTextToSize(bookTitle, contentWidth);
                    doc.text(titleLines, pageWidth / 2, pageHeight / 3, { align: 'center' });

                    if (authorName) {
                        doc.setFontSize(16);
                        doc.setFont('helvetica', 'italic');
                        doc.text(`by ${authorName}`, pageWidth / 2, pageHeight / 3 + 20, { align: 'center' });
                    }

                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.text(new Date().toLocaleDateString(), pageWidth / 2, pageHeight - 30, { align: 'center' });

                    doc.addPage();
                    yPos = marginTop;
                }

                // Content pages
                selectedNodes.forEach((node, idx) => {
                    if (idx > 0 && pageBreaks) {
                        doc.addPage();
                        yPos = marginTop;
                    }

                    // Section title
                    if (includeTitles) {
                        doc.setFontSize(18);
                        doc.setFont('helvetica', 'bold');
                        const titleLines = doc.splitTextToSize(node.title || 'Untitled', contentWidth);

                        if (yPos + (titleLines.length * 8) > pageHeight - marginBottom) {
                            doc.addPage();
                            yPos = marginTop;
                        }

                        doc.text(titleLines, marginLeft, yPos);
                        yPos += titleLines.length * 8 + 5;

                        // Underline
                        doc.setDrawColor(200, 200, 200);
                        doc.line(marginLeft, yPos - 3, pageWidth - marginRight, yPos - 3);
                        yPos += 8;
                    }

                    // Summary
                    if (includeSummary && node.summary) {
                        doc.setFontSize(fontSize - 1);
                        doc.setFont('helvetica', 'italic');
                        doc.setTextColor(100, 100, 100);
                        const summaryLines = doc.splitTextToSize(node.summary, contentWidth - 10);

                        if (yPos + (summaryLines.length * 5) > pageHeight - marginBottom) {
                            doc.addPage();
                            yPos = marginTop;
                        }

                        doc.text(summaryLines, marginLeft + 5, yPos);
                        yPos += summaryLines.length * 5 + 8;
                        doc.setTextColor(0, 0, 0);
                    }

                    // POV/Author
                    if (includePov && node.povId) {
                        const pov = povList.find(p => p.id === node.povId);
                        if (pov) {
                            doc.setFontSize(fontSize - 2);
                            doc.setFont('helvetica', 'italic');
                            doc.setTextColor(120, 120, 120);
                            doc.text(`POV: ${pov.name}`, marginLeft, yPos);
                            yPos += 8;
                            doc.setTextColor(0, 0, 0);
                        }
                    }

                    // Main content
                    doc.setFontSize(fontSize);
                    doc.setFont('helvetica', 'normal');

                    let textContent = node.fullText || '';
                    // Clean HTML
                    textContent = textContent
                        .replace(/<br\s*\/?>/gi, '\n')
                        .replace(/<\/p>\s*<p[^>]*>/gi, '\n\n')
                        .replace(/<[^>]*>/g, '')
                        .replace(/&nbsp;/g, ' ')
                        .replace(/&amp;/g, '&')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&quot;/g, '"')
                        .trim();

                    const paragraphs = textContent.split(/\n\n+/);

                    paragraphs.forEach(para => {
                        if (!para.trim()) return;

                        const lines = doc.splitTextToSize(para.trim(), contentWidth);
                        const lineHeight = fontSize * 0.4 * lineSpacing;

                        lines.forEach(line => {
                            if (yPos + lineHeight > pageHeight - marginBottom) {
                                doc.addPage();
                                yPos = marginTop;
                            }
                            doc.text(line, marginLeft, yPos);
                            yPos += lineHeight;
                        });

                        yPos += lineHeight * 0.5; // Paragraph spacing
                    });

                    yPos += 10;
                });
                
                // Add special nodes content
                // Sticky Notes
                if (includeStickyContent) {
                    const stickyNodes = selectedSpecialNodes.filter(n => n.nodeType === 'sticky');
                    if (stickyNodes.length > 0) {
                        if (pageBreaks && selectedNodes.length > 0) {
                            doc.addPage();
                            yPos = marginTop;
                        }
                        
                        // Section header
                        doc.setFontSize(20);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(241, 196, 15);
                        doc.text('üìù Notlar', marginLeft, yPos);
                        yPos += 15;
                        doc.setTextColor(0, 0, 0);
                        
                        stickyNodes.forEach(note => {
                            if (yPos > pageHeight - marginBottom - 30) {
                                doc.addPage();
                                yPos = marginTop;
                            }
                            
                            // Note title
                            doc.setFontSize(14);
                            doc.setFont('helvetica', 'bold');
                            doc.text(note.title || 'Not', marginLeft, yPos);
                            yPos += 8;
                            
                            // Note content
                            if (note.content) {
                                doc.setFontSize(fontSize);
                                doc.setFont('helvetica', 'normal');
                                const noteLines = doc.splitTextToSize(note.content, contentWidth);
                                noteLines.forEach(line => {
                                    if (yPos + 6 > pageHeight - marginBottom) {
                                        doc.addPage();
                                        yPos = marginTop;
                                    }
                                    doc.text(line, marginLeft, yPos);
                                    yPos += 6;
                                });
                            }
                            yPos += 10;
                        });
                    }
                }
                
                // Folder Nodes
                if (includeFolderContent) {
                    const folderNodes = selectedSpecialNodes.filter(n => n.nodeType === 'folder');
                    if (folderNodes.length > 0) {
                        if (pageBreaks) {
                            doc.addPage();
                            yPos = marginTop;
                        }
                        
                        // Section header
                        doc.setFontSize(20);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(230, 126, 34);
                        doc.text('üìÅ Klas√∂rler', marginLeft, yPos);
                        yPos += 15;
                        doc.setTextColor(0, 0, 0);
                        
                        folderNodes.forEach(folder => {
                            if (yPos > pageHeight - marginBottom - 30) {
                                doc.addPage();
                                yPos = marginTop;
                            }
                            
                            // Folder title
                            doc.setFontSize(14);
                            doc.setFont('helvetica', 'bold');
                            doc.text(folder.title || 'Klas√∂r', marginLeft, yPos);
                            yPos += 8;
                            
                            // Files list
                            if (folder.files && folder.files.length > 0) {
                                doc.setFontSize(fontSize - 1);
                                doc.setFont('helvetica', 'normal');
                                folder.files.forEach(file => {
                                    if (yPos + 6 > pageHeight - marginBottom) {
                                        doc.addPage();
                                        yPos = marginTop;
                                    }
                                    const fileSize = file.size ? `(${(file.size / 1024).toFixed(1)} KB)` : '';
                                    doc.text(`‚Ä¢ ${file.name} ${fileSize}`, marginLeft + 5, yPos);
                                    yPos += 6;
                                });
                            }
                            yPos += 10;
                        });
                    }
                }
                
                // Image Nodes
                if (includeImageContent) {
                    const imageNodes = selectedSpecialNodes.filter(n => n.nodeType === 'image');
                    if (imageNodes.length > 0) {
                        if (pageBreaks) {
                            doc.addPage();
                            yPos = marginTop;
                        }
                        
                        // Section header
                        doc.setFontSize(20);
                        doc.setFont('helvetica', 'bold');
                        doc.setTextColor(233, 30, 99);
                        doc.text('üñºÔ∏è Resimler', marginLeft, yPos);
                        yPos += 15;
                        doc.setTextColor(0, 0, 0);
                        
                        for (const img of imageNodes) {
                            if (yPos > pageHeight - marginBottom - 60) {
                                doc.addPage();
                                yPos = marginTop;
                            }
                            
                            // Image title
                            doc.setFontSize(14);
                            doc.setFont('helvetica', 'bold');
                            doc.text(img.title || 'Resim', marginLeft, yPos);
                            yPos += 8;
                            
                            // Try to add image
                            if (img.imageData) {
                                try {
                                    const imgWidth = 80;
                                    const imgHeight = 60;
                                    if (yPos + imgHeight > pageHeight - marginBottom) {
                                        doc.addPage();
                                        yPos = marginTop;
                                    }
                                    doc.addImage(img.imageData, 'JPEG', marginLeft, yPos, imgWidth, imgHeight);
                                    yPos += imgHeight + 5;
                                } catch (e) {
                                    doc.setFontSize(fontSize - 2);
                                    doc.setFont('helvetica', 'italic');
                                    doc.text('[Resim y√ºklenemedi]', marginLeft, yPos);
                                    yPos += 8;
                                }
                            }
                            
                            // Caption
                            if (img.caption) {
                                doc.setFontSize(fontSize - 2);
                                doc.setFont('helvetica', 'italic');
                                doc.setTextColor(100, 100, 100);
                                const captionLines = doc.splitTextToSize(img.caption, contentWidth);
                                captionLines.forEach(line => {
                                    doc.text(line, marginLeft, yPos);
                                    yPos += 5;
                                });
                                doc.setTextColor(0, 0, 0);
                            }
                            yPos += 10;
                        }
                    }
                }

                // Add page numbers
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFontSize(10);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor(150, 150, 150);
                    doc.text(`${i} / ${pageCount}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
                }

                // Save PDF
                doc.save(`${bookTitle.replace(/\s+/g, '_')}.pdf`);
                closeModal('compileModal');
                showToast(`üìï PDF exported: ${bookTitle}.pdf`);

            } catch (error) {
                console.error('PDF generation error:', error);
                showToast('‚ùå PDF generation failed. Trying alternative method...');

                // Fallback to print method
                const content = generateCompileContent('pdf');
                const pdfWindow = window.open('', '_blank', 'width=900,height=700');
                if (pdfWindow) {
                    pdfWindow.document.write(content);
                    pdfWindow.document.close();
                    pdfWindow.onload = function() {
                        setTimeout(() => pdfWindow.print(), 500);
                    };
                }
            }
        }

        function generateCompileContent(format) {
            const selectedNodes = nodes.filter(n => compileSelectedNodes.includes(n.id));
            const includeTitles = document.getElementById('compileIncludeTitles').checked;
            const includeSummary = document.getElementById('compileIncludeSummary').checked;
            const pageBreaks = document.getElementById('compilePageBreaks').checked;
            const includePov = document.getElementById('compileIncludePov').checked;
            const stripFormatting = document.getElementById('compileStripFormatting').checked;
            const includeCover = document.getElementById('compileIncludeCover').checked;
            const bookTitle = document.getElementById('compileBookTitle').value || '72 Seconds';
            const authorName = document.getElementById('compileAuthorName').value;
            const fontFamily = document.getElementById('compileFontFamily').value;
            const fontSize = document.getElementById('compileFontSize').value;
            const lineSpacing = document.getElementById('compileLineSpacing').value;

            if (format === 'txt') {
                let text = '';
                if (includeCover) {
                    text += bookTitle.toUpperCase() + '\n';
                    if (authorName) text += `by ${authorName}\n`;
                    text += '\n' + '='.repeat(50) + '\n\n';
                }
                selectedNodes.forEach((node, i) => {
                    if (i > 0 && pageBreaks) text += '\n\n' + '-'.repeat(50) + '\n\n';
                    if (includeTitles) text += `\n${node.title.toUpperCase()}\n${'='.repeat(node.title.length)}\n\n`;
                    if (includeSummary && node.summary) text += `[${node.summary}]\n\n`;
                    if (includePov && node.povId) {
                        const pov = povList.find(p => p.id === node.povId);
                        if (pov) text += `POV: ${pov.name}\n\n`;
                    }
                    let content = node.fullText || '';
                    content = content.replace(/<br\s*\/?>/gi, '\n').replace(/<[^>]*>/g, '');
                    text += content + '\n';
                });
                return text;
            }

            if (format === 'md') {
                let md = '';
                if (includeCover) {
                    md += `# ${bookTitle}\n\n`;
                    if (authorName) md += `*${authorName}*\n\n`;
                    md += '---\n\n';
                }
                selectedNodes.forEach((node, i) => {
                    if (i > 0 && pageBreaks) md += '\n---\n\n';
                    if (includeTitles) md += `## ${node.title}\n\n`;
                    if (includeSummary && node.summary) md += `> ${node.summary}\n\n`;
                    if (includePov && node.povId) {
                        const pov = povList.find(p => p.id === node.povId);
                        if (pov) md += `*POV: ${pov.name}*\n\n`;
                    }
                    let content = node.fullText || '';
                    if (stripFormatting) {
                        content = content.replace(/<[^>]*>/g, '');
                    } else {
                        content = content
                            .replace(/<\/?b>/gi, '**').replace(/<\/?strong>/gi, '**')
                            .replace(/<\/?i>/gi, '*').replace(/<\/?em>/gi, '*')
                            .replace(/<br\s*\/?>/gi, '\n')
                            .replace(/<[^>]*>/g, '');
                    }
                    md += content + '\n\n';
                });
                return md;
            }

            // HTML/DOCX/PDF
            let html = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${bookTitle}</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: "${fontFamily}", serif;
            font-size: ${fontSize}pt;
            line-height: ${lineSpacing};
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 50px;
            color: #222;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2em;
            color: #111;
        }
        .author {
            text-align: center;
            font-style: italic;
            margin-bottom: 50px;
            font-size: 1.1em;
            color: #555;
        }
        .chapter {
            margin-top: 60px;
            ${pageBreaks ? 'page-break-before: always;' : ''}
        }
        .chapter:first-of-type {
            page-break-before: auto;
            margin-top: 40px;
        }
        h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #111;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .summary {
            font-style: italic;
            color: #666;
            margin-bottom: 15px;
            padding: 10px;
            background: #f9f9f9;
            border-left: 3px solid #ddd;
        }
        .pov {
            font-size: 0.9em;
            color: #888;
            margin-bottom: 20px;
        }
        .content { margin-top: 20px; }
        .content p, p { text-indent: 2em; margin: 0.8em 0; }
        hr { margin: 50px 0; border: none; border-top: 1px solid #ccc; }
        @media print {
            body { padding: 20px; }
            .chapter { page-break-before: ${pageBreaks ? 'always' : 'auto'}; }
            .chapter:first-of-type { page-break-before: auto; }
        }
        @media screen {
            body { background: #fff; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
        }
    </style>
</head>
<body>`;

            if (includeCover) {
                html += `<h1>${bookTitle}</h1>`;
                if (authorName) html += `<p class="author">${authorName}</p>`;
                html += '<hr style="margin: 40px 0;">';
            }

            selectedNodes.forEach((node, i) => {
                html += `<div class="chapter">`;
                if (includeTitles) html += `<h2>${node.title}</h2>`;
                if (includeSummary && node.summary) html += `<p class="summary">${node.summary}</p>`;
                if (includePov && node.povId) {
                    const pov = povList.find(p => p.id === node.povId);
                    if (pov) html += `<p class="pov">POV: ${pov.name}</p>`;
                }
                let content = node.fullText || '';
                if (stripFormatting) {
                    content = content.replace(/<[^>]*>/g, '');
                    content = content.split(/\n\n+/).filter(p => p.trim()).map(p => `<p>${p}</p>`).join('');
                }
                html += `<div class="content">${content || '<p><em>(No content yet)</em></p>'}</div>`;
                html += `</div>`;
            });

            html += '</body></html>';
            return html;
        }

        // ============ EDITOR ZOOM ============
        // Zoom changes TEXT SIZE, not view transform
        let editorZoom = 100;
        let editorBaseFontSize = 18; // Base font size - realistic 18px

        function editorZoomIn() {
            if (editorZoom >= 350) return; // Max 350% to prevent window expansion
            // Increment by larger steps at higher zoom levels
            if (editorZoom >= 200) editorZoom += 50;
            else editorZoom += 10;
            applyEditorZoom();
        }

        function editorZoomOut() {
            if (editorZoom <= 25) return;
            // Decrement by larger steps at higher zoom levels
            if (editorZoom > 500) editorZoom -= 100;
            else if (editorZoom > 200) editorZoom -= 50;
            else editorZoom -= 10;
            applyEditorZoom();
        }

        function editorZoomReset() {
            editorZoom = 100;
            applyEditorZoom();
        }

        function applyEditorZoom() {
            const editor = document.getElementById('fullTextEditor');
            const wrapper = document.getElementById('textEditorWrapper');

            if (editor) {
                // Use transform scale for zoom - keeps window size fixed
                const scale = editorZoom / 100;
                editor.style.transform = `scale(${scale})`;
                editor.style.transformOrigin = 'top left';
                // Adjust width to fill wrapper when scaled
                editor.style.width = (100 / scale) + '%';
                editor.style.minHeight = (100 / scale) + '%';
            }
            const zoomLabel = document.getElementById('editorZoomLevel');
            if (zoomLabel) zoomLabel.textContent = editorZoom + '%';
        }

        // ============ EDITOR TEXT AREA DARK/LIGHT MODE ============
        // This toggle ONLY affects the text writing area background
        // Independent from system theme - uses both CSS classes AND inline styles for maximum override
        let editorTextLight = false; // false = dark text area, true = light text area

        function toggleEditorDarkMode() {
            editorTextLight = !editorTextLight;
            const editor = document.getElementById('fullTextEditor');
            const modal = document.getElementById('editorModal');
            const btn = document.getElementById('darkModeBtn');

            if (editorTextLight) {
                // Light text area (white background, dark text)
                modal.classList.remove('editor-dark-mode');
                modal.classList.add('editor-light-mode');
                // Set only background and color - preserve other styles like font-size
                editor.style.setProperty('background', '#ffffff', 'important');
                editor.style.setProperty('color', '#1f2328', 'important');
                btn.style.background = '#e94560';
                btn.innerHTML = 'üåô';
                btn.title = 'Dark Mode';
                showToast('‚òÄÔ∏è Text Area Light Mode');
            } else {
                // Dark text area (dark background, light text)
                modal.classList.remove('editor-light-mode');
                modal.classList.add('editor-dark-mode');
                // Set only background and color - preserve other styles like font-size
                editor.style.setProperty('background', '#1a1a2e', 'important');
                editor.style.setProperty('color', '#e0e0e0', 'important');
                btn.style.background = '#333';
                btn.innerHTML = '‚òÄÔ∏è';
                btn.title = 'Light Mode';
                showToast('üåô Text Area Dark Mode');
            }
        }

        // ============ FOCUS MODE ============
        let focusModeActive = false;

        function toggleFocusMode() {
            focusModeActive = !focusModeActive;
            const modal = document.getElementById('editorModal');
            const btn = document.getElementById('focusModeBtn');
            const editor = document.getElementById('fullTextEditor');

            if (focusModeActive) {
                modal.classList.add('focus-mode-active');
                btn.style.background = '#e94560';
                btn.innerHTML = 'üéØ‚úì';

                // Reset focus zoom and apply it
                focusZoom = 100;
                document.getElementById('focusZoomLevel').textContent = '100%';
                
                // Set initial font size for focus mode
                if (editor) {
                    editor.style.setProperty('font-size', focusBaseFontSize + 'px', 'important');
                    editor.style.setProperty('line-height', '2.0', 'important');
                }

                // Initialize focus width slider
                focusWidthPercent = 80;
                const widthSlider = document.getElementById('focusWidthSlider');
                const widthLabel = document.getElementById('focusWidthLabel');
                if (widthSlider) widthSlider.value = 80;
                if (widthLabel) widthLabel.textContent = '80%';
                setFocusWidth(80);

                // Initialize focus theme based on system theme
                initFocusTheme();

                // Listen for ESC key
                document.addEventListener('keydown', focusModeEscHandler);

                showToast('üéØ Focus Mode - Press ESC to exit');
            } else {
                modal.classList.remove('focus-mode-active');
                modal.classList.remove('focus-dark');
                modal.classList.remove('focus-light');
                btn.style.background = '#6366f1';
                btn.innerHTML = 'üéØ';

                // Reset editor styles
                if (editor) {
                    editor.style.transform = '';
                    editor.style.width = '';
                    editor.style.removeProperty('padding-left');
                    editor.style.removeProperty('padding-right');
                    editor.style.removeProperty('font-size');
                    editor.style.removeProperty('line-height');
                }

                // Reset CSS variable
                document.documentElement.style.removeProperty('--focus-padding');

                document.removeEventListener('keydown', focusModeEscHandler);

                showToast('Focus Mode Closed');
            }
        }

        function focusModeEscHandler(e) {
            if (e.key === 'Escape' && focusModeActive) {
                toggleFocusMode();
            }
        }

        // ============ FOCUS MODE ZOOM ============
        // Zoom changes TEXT SIZE, not view transform
        let focusZoom = 100;
        const focusBaseFontSize = 20; // Focus mode base font size - larger for reading

        function focusZoomIn() {
            if (focusZoom >= 4000) return;
            // Increment by larger steps at higher zoom levels
            if (focusZoom >= 500) focusZoom += 100;
            else if (focusZoom >= 200) focusZoom += 50;
            else focusZoom += 10;
            applyFocusZoom();
        }

        function focusZoomOut() {
            if (focusZoom <= 25) return;
            // Decrement by larger steps at higher zoom levels
            if (focusZoom > 500) focusZoom -= 100;
            else if (focusZoom > 200) focusZoom -= 50;
            else focusZoom -= 10;
            applyFocusZoom();
        }

        function focusZoomReset() {
            focusZoom = 100;
            applyFocusZoom();
        }

        function applyFocusZoom() {
            const editor = document.getElementById('fullTextEditor');
            if (editor && focusModeActive) {
                // Change font size based on zoom percentage
                const newFontSize = focusBaseFontSize * (focusZoom / 100);
                editor.style.setProperty('font-size', newFontSize + 'px', 'important');
                // Scale line-height proportionally for better readability
                const lineHeight = Math.max(1.6, 2.2 - (focusZoom - 100) / 500);
                editor.style.setProperty('line-height', lineHeight.toFixed(2), 'important');
                // Don't override width - let CSS handle it
                editor.style.transform = 'none';
            }
            const zoomLabel = document.getElementById('focusZoomLevel');
            if (zoomLabel) zoomLabel.textContent = focusZoom + '%';
        }

        // ============ FOCUS MODE WIDTH CONTROL ============
        let focusWidthPercent = 80; // Default 80% width (10% padding each side)

        function setFocusWidth(value) {
            focusWidthPercent = parseInt(value);
            const padding = (100 - focusWidthPercent) / 2;

            // Update CSS variable
            document.documentElement.style.setProperty('--focus-padding', padding + '%');

            // Update label
            const label = document.getElementById('focusWidthLabel');
            if (label) label.textContent = focusWidthPercent + '%';

            // Apply to editor directly as well
            const editor = document.getElementById('fullTextEditor');
            if (editor && focusModeActive) {
                editor.style.setProperty('padding-left', padding + '%', 'important');
                editor.style.setProperty('padding-right', padding + '%', 'important');
            }
        }

        // ============ FOCUS MODE LIGHT/DARK TOGGLE ============
        let focusDarkMode = false;

        function toggleFocusDarkMode() {
            focusDarkMode = !focusDarkMode;
            const modal = document.getElementById('editorModal');
            const editor = document.getElementById('fullTextEditor');
            const btn = document.getElementById('focusDarkBtn');

            if (focusDarkMode) {
                // Dark mode
                modal.classList.remove('focus-light');
                modal.classList.add('focus-dark');
                // Force inline styles for focus mode
                editor.style.setProperty('background', '#1a1a2e', 'important');
                editor.style.setProperty('color', '#d4d4d4', 'important');
                btn.innerHTML = '‚òÄÔ∏è';
                btn.title = 'Light Mode';
            } else {
                // Light mode
                modal.classList.remove('focus-dark');
                modal.classList.add('focus-light');
                // Force inline styles for focus mode
                editor.style.setProperty('background', '#fafafa', 'important');
                editor.style.setProperty('color', '#333', 'important');
                btn.innerHTML = 'üåô';
                btn.title = 'Dark Mode';
            }
        }

        // Initialize focus mode theme based on system theme
        function initFocusTheme() {
            const modal = document.getElementById('editorModal');
            const editor = document.getElementById('fullTextEditor');
            const btn = document.getElementById('focusDarkBtn');
            const isSystemDark = !document.body.classList.contains('light-mode');

            if (isSystemDark) {
                // System is dark, focus starts dark
                focusDarkMode = true;
                modal.classList.remove('focus-light');
                modal.classList.add('focus-dark');
                editor.style.setProperty('background', '#1a1a2e', 'important');
                editor.style.setProperty('color', '#d4d4d4', 'important');
                btn.innerHTML = '‚òÄÔ∏è';
                btn.title = 'Light Mode';
            } else {
                // System is light, focus starts light
                focusDarkMode = false;
                modal.classList.remove('focus-dark');
                modal.classList.add('focus-light');
                editor.style.setProperty('background', '#fafafa', 'important');
                editor.style.setProperty('color', '#333', 'important');
                btn.innerHTML = 'üåô';
                btn.title = 'Dark Mode';
            }
        }

        // ============ FOCUS MODE FIND & REPLACE ============
        let focusFindMatches = [];
        let focusCurrentMatch = 0;

        function toggleFocusFindBar() {
            const panel = document.getElementById('focusFindPanel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                document.getElementById('focusFindInput').focus();
            } else {
                clearFocusFindHighlights();
                hideFocusFindResults();
            }
        }

        function focusFindText() {
            const editor = document.getElementById('fullTextEditor');
            const searchTerm = document.getElementById('focusFindInput').value;
            const matchCase = document.getElementById('focusMatchCase').checked;
            const wholeWord = document.getElementById('focusWholeWord').checked;

            clearFocusFindHighlights();
            focusFindMatches = [];
            focusCurrentMatch = 0;

            if (!searchTerm) {
                document.getElementById('focusFindCount').textContent = '';
                return;
            }

            const text = editor.innerText || editor.textContent;

            try {
                let pattern = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                if (wholeWord) pattern = `\\b${pattern}\\b`;
                const flags = matchCase ? 'g' : 'gi';
                const regex = new RegExp(pattern, flags);

                let match;
                while ((match = regex.exec(text)) !== null) {
                    focusFindMatches.push({ index: match.index, length: match[0].length, text: match[0] });
                }
            } catch (e) {
                document.getElementById('focusFindCount').textContent = 'Error!';
                return;
            }

            if (focusFindMatches.length > 0) {
                highlightFocusMatches(searchTerm, matchCase, wholeWord);
                scrollToFocusMatch(0);
                updateFocusFindCount();
                showFocusFindResults(searchTerm, text, matchCase);
            } else {
                document.getElementById('focusFindCount').textContent = '0 results';
                hideFocusFindResults();
            }
        }

        function showFocusFindResults(searchTerm, fullText, matchCase) {
            const resultsDiv = document.getElementById('focusFindResults');
            const listDiv = document.getElementById('focusFindResultsList');

            if (focusFindMatches.length === 0) {
                resultsDiv.classList.remove('active');
                return;
            }

            let html = '';
            focusFindMatches.forEach((match, index) => {
                const pos = match.index;
                const matchLength = match.length;
                const matchText = match.text;

                // Get surrounding text (context)
                const start = Math.max(0, pos - 30);
                const end = Math.min(fullText.length, pos + matchLength + 40);
                let context = fullText.substring(start, end);

                // Add ... if truncated at start or end
                if (start > 0) context = '...' + context;
                if (end < fullText.length) context = context + '...';

                // Highlight found words
                const escapedMatch = matchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const flags = matchCase ? 'g' : 'gi';
                const regex = new RegExp(`(${escapedMatch})`, flags);
                context = context.replace(regex, '<mark>$1</mark>');

                const isCurrent = index === focusCurrentMatch ? 'current' : '';
                html += `<div class="focus-result-item ${isCurrent}" onclick="goToFocusResult(${index})">
                    <span class="result-num">${index + 1}</span>
                    <span class="result-context">${context}</span>
                </div>`;
            });

            listDiv.innerHTML = html;
            resultsDiv.classList.add('active');
        }

        function hideFocusFindResults() {
            document.getElementById('focusFindResults').classList.remove('active');
        }

        function goToFocusResult(index) {
            focusCurrentMatch = index;
            scrollToFocusMatch(index);
            updateFocusFindCount();
            updateFocusResultsList();
        }

        function updateFocusResultsList() {
            const items = document.querySelectorAll('.focus-result-item');
            items.forEach((item, index) => {
                if (index === focusCurrentMatch) {
                    item.classList.add('current');
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } else {
                    item.classList.remove('current');
                }
            });
        }

        function highlightFocusMatches(searchTerm, matchCase, wholeWord) {
            const editor = document.getElementById('fullTextEditor');
            const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null, false);
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }

            let pattern = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            if (wholeWord) pattern = `\\b${pattern}\\b`;
            const flags = matchCase ? 'g' : 'gi';

            try {
                const regex = new RegExp(`(${pattern})`, flags);

                textNodes.forEach(textNode => {
                    const text = textNode.nodeValue;
                    if (regex.test(text)) {
                        regex.lastIndex = 0;
                        const fragment = document.createDocumentFragment();
                        let lastIndex = 0;
                        let match;

                        while ((match = regex.exec(text)) !== null) {
                            if (match.index > lastIndex) {
                                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                            }
                            const span = document.createElement('span');
                            span.className = 'focus-find-highlight';
                            span.style.background = '#ffeb3b';
                            span.style.color = '#333';
                            span.style.padding = '0 2px';
                            span.style.borderRadius = '2px';
                            span.textContent = match[0];
                            fragment.appendChild(span);
                            lastIndex = regex.lastIndex;
                        }

                        if (lastIndex < text.length) {
                            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                        }

                        textNode.parentNode.replaceChild(fragment, textNode);
                    }
                });
            } catch(e) {
                console.error('Focus find regex error:', e);
            }
        }

        function clearFocusFindHighlights() {
            const editor = document.getElementById('fullTextEditor');
            const highlights = editor.querySelectorAll('.focus-find-highlight');
            highlights.forEach(h => {
                h.replaceWith(document.createTextNode(h.textContent));
            });
        }

        function scrollToFocusMatch(index) {
            const editor = document.getElementById('fullTextEditor');
            const highlights = editor.querySelectorAll('.focus-find-highlight');

            highlights.forEach((h, i) => {
                h.style.background = i === index ? '#e94560' : '#ffeb3b';
                h.style.color = i === index ? 'white' : '#333';
            });

            if (highlights[index]) {
                highlights[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function updateFocusFindCount() {
            if (focusFindMatches.length > 0) {
                document.getElementById('focusFindCount').textContent =
                    `${focusCurrentMatch + 1} / ${focusFindMatches.length} results`;
            } else {
                document.getElementById('focusFindCount').textContent = '0 results';
            }
        }

        function focusFindNext() {
            if (focusFindMatches.length === 0) return;
            focusCurrentMatch = (focusCurrentMatch + 1) % focusFindMatches.length;
            scrollToFocusMatch(focusCurrentMatch);
            updateFocusFindCount();
            updateFocusResultsList();
        }

        function focusFindPrev() {
            if (focusFindMatches.length === 0) return;
            focusCurrentMatch = (focusCurrentMatch - 1 + focusFindMatches.length) % focusFindMatches.length;
            scrollToFocusMatch(focusCurrentMatch);
            updateFocusResultsList();
            updateFocusFindCount();
        }

        function focusReplaceText() {
            if (focusFindMatches.length === 0) return;
            const editor = document.getElementById('fullTextEditor');
            const replaceWith = document.getElementById('focusReplaceInput').value;
            const highlights = editor.querySelectorAll('.focus-find-highlight');

            if (highlights[focusCurrentMatch]) {
                highlights[focusCurrentMatch].replaceWith(document.createTextNode(replaceWith));
                focusFindMatches.splice(focusCurrentMatch, 1);
                if (focusFindMatches.length > 0) {
                    if (focusCurrentMatch >= focusFindMatches.length) focusCurrentMatch = 0;
                    scrollToFocusMatch(focusCurrentMatch);
                    updateFocusFindCount();
                } else {
                    document.getElementById('focusFindCount').textContent = '0';
                }
                showToast('Replaceildi');
            }
        }

        function focusReplaceAll() {
            if (focusFindMatches.length === 0) return;
            const editor = document.getElementById('fullTextEditor');
            const replaceWith = document.getElementById('focusReplaceInput').value;
            const highlights = editor.querySelectorAll('.focus-find-highlight');
            const count = highlights.length;

            highlights.forEach(h => {
                h.replaceWith(document.createTextNode(replaceWith));
            });

            focusFindMatches = [];
            focusCurrentMatch = 0;
            document.getElementById('focusFindCount').textContent = '0';
            showToast(`${count} changes made`);
        }

        // ============ SYSTEM THEME TOGGLE ============
        // This affects the whole application
        let systemLightMode = false;

        function toggleSystemTheme() {
            systemLightMode = !systemLightMode;
            const themeIcon = document.getElementById('themeIcon');
            const themeMenuIcon = document.getElementById('themeMenuIcon');
            const themeMenuLabel = document.getElementById('themeMenuLabel');
            const settingsSelect = document.getElementById('settingsTheme');

            if (systemLightMode) {
                // Light mode for entire system
                document.body.classList.add('light-mode');
                if (themeIcon) themeIcon.textContent = 'üåô';
                if (themeMenuIcon) themeMenuIcon.textContent = 'üåô';
                if (themeMenuLabel) themeMenuLabel.textContent = 'Dark Mode';
                if (settingsSelect) settingsSelect.value = 'light';
                localStorage.setItem('universalWriterTheme', 'light');
                showToast('‚òÄÔ∏è Light Mode');
            } else {
                // Dark mode for entire system
                document.body.classList.remove('light-mode');
                if (themeIcon) themeIcon.textContent = '‚òÄÔ∏è';
                if (themeMenuIcon) themeMenuIcon.textContent = '‚òÄÔ∏è';
                if (themeMenuLabel) themeMenuLabel.textContent = 'Light Mode';
                if (settingsSelect) settingsSelect.value = 'dark';
                localStorage.setItem('universalWriterTheme', 'dark');
                showToast('üåô Dark Mode');
            }
        }

        // Load saved theme on startup
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('universalWriterTheme');
            if (savedTheme === 'light') {
                systemLightMode = true;
                document.body.classList.add('light-mode');
                const themeIcon = document.getElementById('themeIcon');
                const themeMenuIcon = document.getElementById('themeMenuIcon');
                const themeMenuLabel = document.getElementById('themeMenuLabel');
                if (themeIcon) themeIcon.textContent = 'üåô';
                if (themeMenuIcon) themeMenuIcon.textContent = 'üåô';
                if (themeMenuLabel) themeMenuLabel.textContent = 'Dark Mode';
            }
        }

        // ============ USER MENU ============
        function toggleUserMenu() {
            // Offline mode - always show menu
            const container = document.getElementById('userMenuContainer');
            container.classList.toggle('open');
        }

        // Close user menu when clicking outside
        document.addEventListener('click', function(e) {
            const userMenu = document.getElementById('userMenuContainer');
            if (userMenu && !userMenu.contains(e.target)) {
                userMenu.classList.remove('open');
            }
        });

        function updateUserMenuUI() {
            const nameSmall = document.getElementById('userNameSmall');
            const dropdownName = document.getElementById('dropdownUserName');
            const dropdownEmail = document.getElementById('dropdownUserEmail');
            const signOutBtn = document.getElementById('signOutBtn');

            if (currentUser) {
                if (nameSmall) nameSmall.textContent = currentUser.username || 'User';
                if (dropdownName) dropdownName.textContent = currentUser.username || 'User';
                if (dropdownEmail) dropdownEmail.textContent = currentUser.email || '';
                if (signOutBtn) signOutBtn.style.display = 'flex';
            } else {
                if (nameSmall) nameSmall.textContent = 'Sign In';
                if (dropdownName) dropdownName.textContent = 'Guest';
                if (dropdownEmail) dropdownEmail.textContent = 'Not signed in';
                if (signOutBtn) signOutBtn.style.display = 'none';
            }
        }

        function showAccountSettings() {
            document.getElementById('userMenuContainer').classList.remove('open');
            if (currentUser) {
                openSettingsModal();
            } else {
                showAuthModal();
            }
        }

        function showKeyboardShortcuts() {
            document.getElementById('userMenuContainer').classList.remove('open');
            showToast('‚å®Ô∏è Keyboard shortcuts: Ctrl+S (Save), Ctrl+F (Search), Delete (Delete node)');
        }

        function showAbout() {
            document.getElementById('userMenuContainer').classList.remove('open');
            showToast('‚ú® Universal Writer Studio v1.0 - Modern writing app');
        }

        function signOut() {
            document.getElementById('userMenuContainer').classList.remove('open');
            doLogout();
        }

        // ============ SYNC STATUS ============
        function updateSyncStatus(status, text) {
            const statusEl = document.getElementById('syncStatus');
            const iconEl = document.getElementById('syncIcon');
            const textEl = document.getElementById('syncText');

            statusEl.className = 'sync-status';

            switch(status) {
                case 'synced':
                    statusEl.classList.add('synced');
                    iconEl.textContent = '‚òÅÔ∏è';
                    textEl.textContent = text || 'Synced';
                    break;
                case 'syncing':
                    statusEl.classList.add('syncing');
                    iconEl.textContent = 'üîÑ';
                    textEl.textContent = text || 'Syncing...';
                    break;
                case 'error':
                    statusEl.classList.add('error');
                    iconEl.textContent = '‚ö†Ô∏è';
                    textEl.textContent = text || 'Sync Error';
                    break;
                case 'offline':
                    statusEl.classList.add('offline');
                    iconEl.textContent = 'üì¥';
                    textEl.textContent = text || 'Offline';
                    break;
            }
        }

        // ============ COMMAND PALETTE ============
        function openCommandPalette() {
            document.getElementById('commandPaletteOverlay').classList.add('active');
            document.getElementById('commandInput').focus();
            document.getElementById('commandInput').value = '';
            filterCommands();
        }

        function closeCommandPalette() {
            document.getElementById('commandPaletteOverlay').classList.remove('active');
        }

        function filterCommands() {
            const query = document.getElementById('commandInput').value.toLowerCase();
            const items = document.querySelectorAll('.command-item');

            items.forEach(item => {
                const text = item.querySelector('.command-item-text').textContent.toLowerCase();
                item.style.display = text.includes(query) ? 'flex' : 'none';
            });

            // Show/hide groups based on visible items
            document.querySelectorAll('.command-group').forEach(group => {
                const visibleItems = group.querySelectorAll('.command-item[style="display: flex;"], .command-item:not([style])');
                const hasVisible = Array.from(group.querySelectorAll('.command-item')).some(item => item.style.display !== 'none');
                group.style.display = hasVisible ? 'block' : 'none';
            });
        }

        function executeCommand(cmd) {
            closeCommandPalette();

            switch(cmd) {
                case 'save': cloudSave(); break;
                case 'search': openGlobalSearch(); break;
                case 'newNode': showAddMenu(event); break;
                case 'compile': openCompileModal(); break;
                case 'toggleTheme': toggleSystemTheme(); break;
                case 'zoomIn': zoomIn(); break;
                case 'zoomOut': zoomOut(); break;
                case 'fitScreen': fitToScreen(); break;
                case 'projects': switchTab('outline'); break;
                case 'export': downloadAsJson(); break;
                case 'backup': openBackupModal(); break;
                case 'settings': openSettingsModal(); break;
            }
        }

        // Keyboard shortcut for command palette (Ctrl/Cmd + K) and Properties Panel (Ctrl/Cmd + I)
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                openCommandPalette();
            }
            // Cmd+I for Properties Panel (only when editor is not open)
            if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
                const editorModal = document.getElementById('editorModal');
                if (!editorModal || !editorModal.classList.contains('active')) {
                    e.preventDefault();
                    togglePropertiesPanel();
                }
            }
            // Cmd+T for Add Task Menu
            if ((e.ctrlKey || e.metaKey) && e.key === 't') {
                const editorModal = document.getElementById('editorModal');
                if (!editorModal || !editorModal.classList.contains('active')) {
                    e.preventDefault();
                    showAddTaskMenu(e);
                }
            }
            // Cmd+N for Add Node Menu
            if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
                const editorModal = document.getElementById('editorModal');
                if (!editorModal || !editorModal.classList.contains('active')) {
                    e.preventDefault();
                    showAddMenu(e);
                }
            }
            if (e.key === 'Escape') {
                closeCommandPalette();
                hideAllMenus();
            }
        });

        // Settings theme change handler
        function applyThemeFromSettings() {
            const theme = document.getElementById('settingsTheme').value;
            if (theme === 'light' && !systemLightMode) {
                toggleSystemTheme();
            } else if (theme === 'dark' && systemLightMode) {
                toggleSystemTheme();
            }
        }

        // Initialize
        init();
        loadSavedTheme();
        loadNodeTypes();
        loadAppSettings();
        loadPropertiesPanelState();
    </script>

    <!-- File Preview Modal -->
    <div class="file-preview-modal" id="filePreviewModal" onclick="if(event.target===this)closeFilePreview()">
        <div class="file-preview-content">
            <div class="file-preview-header">
                <span id="previewFileName">File Preview</span>
                <button onclick="closeFilePreview()" style="background:none;border:none;color:#fff;font-size:1.5em;cursor:pointer;">√ó</button>
            </div>
            <div class="file-preview-body" id="previewBody"></div>
            <div class="file-preview-actions">
                <button class="preview-download-btn" onclick="downloadCurrentPreview()">‚¨áÔ∏è Download</button>
                <button class="preview-close-btn" onclick="closeFilePreview()">Close</button>
            </div>
        </div>
    </div>
</body>
</html>
